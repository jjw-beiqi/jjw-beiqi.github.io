<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mysql | BeiQi.</title><meta name="keywords" content="Mysql"><meta name="author" content="贝奇野菜汁"><meta name="copyright" content="贝奇野菜汁"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MysqlSQL的分类  多表查询多表查询也称为关联查询 前提条件：这些表之间是有关系的（一对一，一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键 为什么需要多表查询呢，因为如果合成为一张表的话，粒度太大了，当一个线程操作数据库时，可能导致其他线程不能操作；且合成为一张表时可能会造成空间的浪费 实现 例如：  练习： 1234#查询员工id为...的人在哪个部门工">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql">
<meta property="og:url" content="https://jjw-beiqi.github.io/2022/05/04/Mysql/index.html">
<meta property="og:site_name" content="BeiQi.">
<meta property="og:description" content="MysqlSQL的分类  多表查询多表查询也称为关联查询 前提条件：这些表之间是有关系的（一对一，一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键 为什么需要多表查询呢，因为如果合成为一张表的话，粒度太大了，当一个线程操作数据库时，可能导致其他线程不能操作；且合成为一张表时可能会造成空间的浪费 实现 例如：  练习： 1234#查询员工id为...的人在哪个部门工">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jjw-beiqi.github.io/img/cover21.png">
<meta property="article:published_time" content="2022-05-04T07:12:02.000Z">
<meta property="article:modified_time" content="2022-05-25T06:36:21.803Z">
<meta property="article:author" content="贝奇野菜汁">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jjw-beiqi.github.io/img/cover21.png"><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://jjw-beiqi.github.io/2022/05/04/Mysql/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Mysql',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-25 14:36:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover21.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">BeiQi.</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Mysql</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-04T07:12:02.000Z" title="发表于 2022-05-04 15:12:02">2022-05-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-25T06:36:21.803Z" title="更新于 2022-05-25 14:36:21">2022-05-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Mysql"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="SQL的分类"><a href="#SQL的分类" class="headerlink" title="SQL的分类"></a>SQL的分类</h2><p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220508180752532.png" alt="image-20220508180752532"></p>
<hr>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表查询也称为关联查询</p>
<p>前提条件：这些表之间是有关系的（一对一，一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键</p>
<p>为什么需要多表查询呢，因为如果合成为一张表的话，粒度太大了，当一个线程操作数据库时，可能导致其他线程不能操作；且合成为一张表时可能会造成空间的浪费</p>
<p><strong>实现</strong></p>
<p>例如：</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220504170357225.png" alt="image-20220504170357225"></p>
<p>练习：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询员工id为...的人在哪个部门工作</span><br><span class="line"><span class="keyword">select</span> employee_id , department_name</span><br><span class="line"><span class="keyword">from</span> emp,dep #连接两张表操作</span><br><span class="line"><span class="keyword">where</span> emp.departemt_id <span class="operator">=</span> dep.department_id</span><br></pre></td></tr></table></figure>

<p>注意：如果查询语句中出现多个表中都存在的字段，则必须指明此字段所在的表；从sql优化的角度来看，建议多表查询时，每个查询字段都指明其所在表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询员工的employee_id,department_name,city</span><br><span class="line"><span class="keyword">select</span> employee_id,department_name,city</span><br><span class="line"><span class="keyword">from</span> emp e ,dep d ,location l #连接三张表</span><br><span class="line"><span class="keyword">where</span> e.department_id <span class="operator">=</span> d.department_id <span class="keyword">and</span> d.location_id <span class="operator">=</span> l.location_id</span><br></pre></td></tr></table></figure>



<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自己连接自己</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询员工id，员工姓名，及其管理者的id和姓名</span><br><span class="line"><span class="keyword">select</span> emp1.employee_id,emp1.last_name,emp2.employee_id,emp2.last_name</span><br><span class="line"><span class="keyword">from</span> emp emp1,emp emp2</span><br><span class="line"><span class="keyword">where</span> emp1.manager_id <span class="operator">=</span> emp2.employee_id</span><br></pre></td></tr></table></figure>



<h3 id="JOIN语法"><a href="#JOIN语法" class="headerlink" title="JOIN语法"></a>JOIN语法</h3><p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220506111517236.png" alt="image-20220506111517236"></p>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>合并具有同一列的两个以上的表的行，结果集中不包含一个表与另一个表不匹配的行；只查询出能完全匹配的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询员工的employee_id,department_name信息</span><br><span class="line"><span class="keyword">select</span> employee_id,department_name</span><br><span class="line"><span class="keyword">from</span> emp e </span><br><span class="line"><span class="keyword">join</span> dep d</span><br><span class="line"><span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br></pre></td></tr></table></figure>



<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>合并具有同一列的两个以上的表的行，结果集中除了包含一个表与另一个表匹配的行之外，还查询到左表或右表中不匹配的行</p>
<p><strong>左外连接</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询所有员工的employee_id,department_name信息</span><br><span class="line"><span class="keyword">select</span> employee_id,department_name</span><br><span class="line"><span class="keyword">from</span> emp e </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dep d</span><br><span class="line"><span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line">#结果集中包含不匹配的结果，匹配不到的结果以<span class="keyword">null</span>表示</span><br></pre></td></tr></table></figure>



<p><strong>右外连接</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询所有员工的employee_id,department_name信息</span><br><span class="line"><span class="keyword">select</span> employee_id,department_name</span><br><span class="line"><span class="keyword">from</span> emp e </span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> dep d</span><br><span class="line"><span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line">#结果集中包含不匹配的结果，匹配不到的结果以<span class="keyword">null</span>表示</span><br></pre></td></tr></table></figure>



<p><strong>满外连接</strong></p>
<p>使用 full 关键字（Mysql不支持）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询所有员工的employee_id,department_name信息</span><br><span class="line"><span class="keyword">select</span> employee_id,department_name</span><br><span class="line"><span class="keyword">from</span> emp e </span><br><span class="line"><span class="keyword">full</span> <span class="keyword">join</span> dep d</span><br><span class="line"><span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line">#结果集中包含不匹配的结果，匹配不到的结果以<span class="keyword">null</span>表示</span><br></pre></td></tr></table></figure>



<p>使用 union all 关键字</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#利用 <span class="keyword">union</span> 关键字，可以给出多条<span class="keyword">select</span>语句，并将它们的结果集合成为单个结果集，并且去除重复的部分，合并时，两个表对应的列数和数据类型必须相同，且互相对应；<span class="keyword">union</span> <span class="keyword">all</span> 关键字不会去重，效率相对高一些</span><br><span class="line"></span><br><span class="line">#左外连接去除重复部分</span><br><span class="line"><span class="keyword">select</span> employee_id,department_name</span><br><span class="line"><span class="keyword">from</span> emp e </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dep d</span><br><span class="line"><span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">where</span> d.department_id <span class="keyword">is</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">#右外连接</span><br><span class="line"><span class="keyword">select</span> employee_id,department_name</span><br><span class="line"><span class="keyword">from</span> emp e </span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> dep d</span><br><span class="line"><span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br></pre></td></tr></table></figure>





<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>不够灵活，了解即可</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#我们可以把自然连接理解为等值连接，它会自动查询两种链接表中所有相同的字段，然后进行等值连接</span><br><span class="line"><span class="keyword">select</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">from</span> emp e </span><br><span class="line"><span class="keyword">natural</span> <span class="keyword">join</span> dep d</span><br></pre></td></tr></table></figure>



<hr>
<p>我们在使用SQL语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即DBMS。<strong>DBMS之间的差异性很大</strong>，远大于同一个语言不同版本之间的差异。实际上，只有很少的函数是被DBMS同时支持的。比如，大多数DBMS使用（||）或者（+）来做拼接符，而在MYSQL 中的字符串拼接函数为concat()。大部分DBMS会有自己特定的函数，这就意味着采用SQL函数的代码可移植性是很差的，因此在使用函数的时候需要特别注意。</p>
<p><strong>MySQL的内置函数</strong></p>
<p>MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。</p>
<p>MySQL提供的内置函数从实现的功能角度可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MysQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类:单行函数、聚合函数（或分组函数）</p>
<p><strong>单行函数：</strong>接收一条数据，产生一条数据</p>
<p><strong>聚合函数：</strong>接收多条数据，产生一条数据</p>
<h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><p><strong>数值基本函数</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ABS(X)</td>
<td>返回x的绝对值</td>
</tr>
<tr>
<td>SIGN(X)</td>
<td>返回x的符号；正数1，负数-1</td>
</tr>
<tr>
<td>PI()</td>
<td>返回圆周率的值</td>
</tr>
<tr>
<td>FLOOR(X)</td>
<td>返回小于或等于某个值的最大整数</td>
</tr>
<tr>
<td>LEAST(E1,E2,E3)</td>
<td>返回列表中的最小值</td>
</tr>
<tr>
<td>GREATEST(E1,E2,E3)</td>
<td>返回列表中的最大值</td>
</tr>
<tr>
<td>MOD(X,Y)</td>
<td>返回x除以y后的余数</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1的随机数</td>
</tr>
<tr>
<td>RAND(X)</td>
<td>返回0~1的随机数，并用x的值作为种子</td>
</tr>
<tr>
<td>ROUND(X)</td>
<td>返回对x进行四舍五入后的结果</td>
</tr>
</tbody></table>
<p><strong>字符串类型函数</strong></p>
<p><strong>日期时间类型函数</strong></p>
<p><strong>流程控制函数</strong></p>
<p><strong>加密解密函数</strong></p>
<hr>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>对一组数据进行汇总的函数，输入的事一组数据的集合，输出的是单个值</p>
<p><strong>常见的聚合函数</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>AVG</td>
<td>求平均值</td>
</tr>
<tr>
<td>SUM</td>
<td>求总和</td>
</tr>
<tr>
<td>MAX</td>
<td>求最大值</td>
</tr>
<tr>
<td>MIN</td>
<td>求最小值</td>
</tr>
<tr>
<td>COUNT</td>
<td>求个数</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#avg sum</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(salary),<span class="built_in">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"></span><br><span class="line">#max min</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(salary),<span class="built_in">min</span>(salary)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"></span><br><span class="line">#count 不计算<span class="keyword">null</span>值</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(employee_id)</span><br><span class="line"><span class="keyword">from</span> emp</span><br></pre></td></tr></table></figure>





<h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><p>group by声明在from之后、where之后、order by之前、limit之前</p>
<p><strong>对一个字段进行分组</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220507141158697.png" alt="image-20220507141158697"></p>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询各个部门的平均工资，最高工资</span><br><span class="line"><span class="keyword">select</span> department_id, <span class="built_in">avg</span>(salary), <span class="built_in">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br></pre></td></tr></table></figure>



<p><strong>对多个字段进行分组</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220507141507741.png" alt="image-20220507141507741"></p>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查询各个部门、job_id的平均工资</span><br><span class="line"><span class="keyword">select</span> department_id, job_id, <span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_id, job_id</span><br></pre></td></tr></table></figure>



<h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><ul>
<li>用于过滤数据，与group by结合使用</li>
<li>having中可带有聚集函数</li>
<li>声明于gruop by之后 </li>
<li>当过滤条件中没有聚合函数时，建议将过滤条件放在where中，where执行效率更高</li>
</ul>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询各个部门中最高工资比<span class="number">10000</span>高的部门信息</span><br><span class="line"><span class="keyword">select</span> department_id, <span class="built_in">max</span>(salary)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line">gruop <span class="keyword">by</span> department_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">max</span>(salary) <span class="operator">&gt;</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>sql99语法</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220507150016121.png" alt="image-20220507150016121"></p>
<hr>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL4.1开始引入。</p>
<p>SQL中子查询的使用大大增强了SELECT查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合)进行比较。</p>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#谁的工资比jjw高</span><br><span class="line"><span class="keyword">select</span> last_name, salary</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> (</span><br><span class="line">	<span class="keyword">select</span> last_name, salary</span><br><span class="line">	<span class="keyword">from</span> emp</span><br><span class="line">	<span class="keyword">where</span> last_name <span class="operator">=</span> <span class="string">&#x27;jjw&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>子查询在主查询之前完成</li>
<li>子查询结果被主查询使用</li>
<li>子查询要包含在括号内</li>
</ul>
<h4 id="不相关子查询"><a href="#不相关子查询" class="headerlink" title="不相关子查询"></a>不相关子查询</h4><p>上面的例子就是不相关子查询，子查询中每次查询都是同一个数据，与主查询不相关</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#谁的工资比jjw高</span><br><span class="line"><span class="keyword">select</span> last_name, salary</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> (</span><br><span class="line">	<span class="keyword">select</span> last_name, salary</span><br><span class="line">	<span class="keyword">from</span> emp</span><br><span class="line">	<span class="keyword">where</span> last_name <span class="operator">=</span> <span class="string">&#x27;jjw&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#查询最低工资大于<span class="number">50</span>号部门最低工资的部门id和其最低工资</span><br><span class="line"><span class="keyword">select</span> department_id, <span class="built_in">min</span>(salary)</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">min</span> (salary) <span class="operator">&gt;</span> (</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">min</span>(salary)</span><br><span class="line">	<span class="keyword">from</span> emp</span><br><span class="line">	<span class="keyword">where</span> department_id <span class="operator">=</span> <span class="number">50</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#多行子查询需要使用<span class="keyword">in</span>关键字</span><br><span class="line"><span class="keyword">select</span> employee_id, last_name </span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">min</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> emp</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h4 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h4><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每一次外部查询，子查询都要重新计算一次，<strong>这样的子查询就称之为关联子查询</strong></p>
<p>相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询</p>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id</span><br><span class="line"><span class="keyword">select</span> last_name,salary,department_id</span><br><span class="line"><span class="keyword">from</span> emp e1</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> emp e2</span><br><span class="line">    <span class="keyword">where</span> e2.department_id <span class="operator">=</span> e1.department_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h5 id="EXISTS-x2F-NOT-EXISTS"><a href="#EXISTS-x2F-NOT-EXISTS" class="headerlink" title="EXISTS &#x2F; NOT EXISTS"></a>EXISTS &#x2F; NOT EXISTS</h5><ul>
<li>关联子查询通常也会和EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</li>
<li><strong>如果在子查询中不存在满足条件的行:</strong><ul>
<li>条件返回FALSE</li>
<li>继续在子查询中查找</li>
</ul>
</li>
<li><strong>如果在子查询中存在满足条件的行:</strong><ul>
<li>不在子查询中继续查找</li>
<li>条件返回TRUE</li>
</ul>
</li>
<li>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#查询公司管理者的employee_id，last_name，job_id，department_id信息</span><br><span class="line"><span class="keyword">SELECT</span> employee id, last_name,job_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> emp e1</span><br><span class="line">#当存在 e1.employee_id <span class="operator">=</span> e2.manager_id 这条记录时就返回<span class="literal">true</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> emp e2</span><br><span class="line">    <span class="keyword">WHERE</span> e1.employee_id <span class="operator">=</span> e2.manager_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>数据定义语言，对数据库中的某些对象(例如database、table)进行管理，如create、alter和drop。DDL操作是隐性提交的，不能rollback</p>
<h3 id="创建和管理表"><a href="#创建和管理表" class="headerlink" title="创建和管理表"></a>创建和管理表</h3><p><strong>创建数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建数据库</span><br><span class="line"><span class="keyword">create</span> database 数据库名</span><br><span class="line"></span><br><span class="line">#创建并指定字符集编码</span><br><span class="line"><span class="keyword">create</span> database 数据库名 <span class="type">character</span> <span class="keyword">set</span> <span class="string">&#x27;字符集编码&#x27;</span></span><br><span class="line"></span><br><span class="line">#不存在才创建</span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> 数据库名</span><br></pre></td></tr></table></figure>



<p><strong>展示数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> database</span><br></pre></td></tr></table></figure>



<p><strong>切换数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名</span><br></pre></td></tr></table></figure>



<p><strong>查看当前数据库中保存的数据表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables</span><br></pre></td></tr></table></figure>



<p><strong>查看当前使用的数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> database() <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>



<p><strong>修改表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#添加一个字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 数据库名</span><br><span class="line"><span class="keyword">add</span> 字段名 数据类型 约束</span><br><span class="line"></span><br><span class="line">#修改一个字段：数据类型 、长度、默认值</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 数据库名</span><br><span class="line">modify 字段名 数据类型（长度） <span class="keyword">default</span> <span class="string">&#x27;默认值&#x27;</span></span><br><span class="line"></span><br><span class="line">#重命名一个字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 数据库名</span><br><span class="line">change 旧字段名 新字段名 数据类型</span><br><span class="line"></span><br><span class="line">#删除一个字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 数据库名</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">column</span> 字段名</span><br><span class="line"></span><br><span class="line">#重命名表</span><br><span class="line">rename <span class="keyword">table</span> 旧数据库名</span><br><span class="line"><span class="keyword">to</span> 新数据库名</span><br><span class="line"></span><br><span class="line">#删除表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> [if <span class="keyword">exists</span>] 数据库名</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><p><strong>修改数据库字符集编码</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> database 数据库名 <span class="type">character</span> <span class="keyword">set</span> <span class="string">&#x27;字符集编码&#x27;</span></span><br></pre></td></tr></table></figure>



<p><strong>删除数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 数据库名</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> 数据库名</span><br></pre></td></tr></table></figure>



<p><strong>基于现有的表创建新表，同时导入数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 数据库名</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"><span class="keyword">from</span> ...</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>数据操纵语言，对数据库中的数据进行一些简单操作，如insert、delete、update、select等。DML操作是可以手动控制事务的开启、提交和回滚的</p>
<p>DML操作默认是自动提交的，提交之后不能回滚，需要手动关闭自动提交才能回滚</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>将一个新学生元组</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;201215128&#x27;</span>,<span class="string">&#x27;陈东&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;IS&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>插入一条选课记录</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc(Sno,Cno) <span class="keyword">VALUES</span>(<span class="string">&#x27;201215128&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">insert</span>语句与查询语句结合使用</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>计算数据，存放到表中</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Deptage(Sdept,avg_age)</span><br><span class="line"><span class="keyword">select</span> Sdept,<span class="built_in">avg</span>(Sage)</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sdept </span><br></pre></td></tr></table></figure>



<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">update</span>语句与<span class="keyword">where</span>语句结合使用</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>将学生<span class="number">201215121</span>的年龄改为<span class="number">22</span>岁</span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> Sage<span class="operator">=</span><span class="number">22</span></span><br><span class="line"><span class="keyword">where</span> Sno<span class="operator">=</span><span class="string">&#x27;201215121&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>将所有学生的年龄增加<span class="number">1</span>岁</span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> Sage<span class="operator">=</span>Sage<span class="operator">+</span><span class="number">1</span></span><br></pre></td></tr></table></figure>



<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">delete</span>语句与<span class="keyword">where</span>语句结合使用</span><br><span class="line"><span class="keyword">delete</span> </span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sno<span class="operator">=</span><span class="string">&#x27;201215128&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除计算机系所有学生的选课记录</span><br><span class="line"><span class="keyword">delete</span> </span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span>(</span><br><span class="line">  <span class="keyword">select</span> Sno</span><br><span class="line">  <span class="keyword">from</span> student</span><br><span class="line">  <span class="keyword">where</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Mysql数据类型"><a href="#Mysql数据类型" class="headerlink" title="Mysql数据类型"></a>Mysql数据类型</h2><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>浮点数和定点数类型的特点是可以处理小数，你可以把整数看成小数的一个特例，因此，浮点数和定点数的使用场景比整数大多了</p>
<ul>
<li>float 单精度浮点数</li>
<li>double 双精度浮点数</li>
</ul>
<p>float 占用字节数少，取值范围也小；double占用字节数多，取值范围大 </p>
<blockquote>
<p>Mysql允许使用非标准语法(其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用)：FLOAT(M,D)或DOUBLE(M,D)；这里,M称为精度，D称为标度。(M,D)中 M&#x3D;整数位+小数位，D&#x3D;小数位。D&lt;&#x3D;M&lt;&#x3D;255，0&lt;&#x3D;D&lt;&#x3D;30。</p>
<p>例如，定义为FLOAT(5,2)的一个列可以显示为 -999.99~999.99 如果超过这个范围会报错。</p>
<p>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下:</p>
<ul>
<li>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值。</li>
<li>如果存储时，小数点部分若超出范围，就分以下情况:<ul>
<li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。</li>
<li>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入999.995和-999.995都会报错。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="定点数类型"><a href="#定点数类型" class="headerlink" title="定点数类型"></a>定点数类型</h3><p>在编程中，浮点数是不精准的，对于一些精度要求较高的项目，我们不能用浮点数，而是使用定点数；Mysql 中的定点数类型只有 decimal 一种类型</p>
<p>使用DECIMAL(M,D)的方式表示高精度小数。其中，M被称为精度，D被称为标度。O&lt;&#x3D;M&lt;&#x3D;65，0&lt;&#x3D;D&lt;&#x3D;30,D&lt;M。例如，定义DECIMAL (5,2）的类型，表示该列取值范围是-999.99~999.99。当DECIMAL类型不指定精度和标度时，默认为DECIMAL(M,D)</p>
<p>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样，但是有效的数据范围是由M和D决定的。<strong>DECIMAL的存储空间并不是固定的</strong>，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</p>
<h3 id="位类型"><a href="#位类型" class="headerlink" title="位类型"></a>位类型</h3><p>BIT类型中存储的时二进制值，类似于010110</p>
<p>BIT类型如果没有指定精度，默认是1位；最大能表示64位</p>
<p>使用SELECT命令查询位字段时，可以用BIN()或 HEX()函数进行读取。</p>
<h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><ul>
<li>YEAR类型通常用来表示年</li>
<li>DATE类型通常用来表示年、月、日</li>
<li>TIME 类型通常用来表示时、分、秒</li>
<li>DATETIME类型通常用来表示年、月、日、时、分、秒</li>
<li>TIMESTAMP类型通常用来表示带时区的年、月、日、时、分、秒</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220510140239332.png" alt="image-20220510140239332"></p>
<h3 id="文本字符串类型"><a href="#文本字符串类型" class="headerlink" title="文本字符串类型"></a>文本字符串类型</h3><p>MysQL中，文本字符串总体上分为CHAR、VARCHAR 、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET等类型。</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220510153242882.png" alt="image-20220510153242882"></p>
<p><em><strong>char &#x2F; varchar</strong></em></p>
<ul>
<li><p>char是固定长度的，默认为1个字符</p>
</li>
<li><p>当存储数据的长度比char类型声明的长度小的时候，则会在右侧填充空格</p>
</li>
<li><p>当检索char类型时会将字符尾部的空格去除</p>
</li>
<li><p>定义varchar类型时必须指定长度</p>
</li>
<li><p>当检索varchar类型时会保留尾部的空格</p>
</li>
</ul>
<p>区别：</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220510154807126.png" alt="image-20220510154807126"></p>
<p>对于InnoDB存储引擎而言，建议使用varchar，因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列，主要影响性能的因素是数据行使用的存储量</p>
<p><em><strong>text</strong></em></p>
<p>在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT类型。</p>
<p>在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和VARCHAR类型相同。</p>
<p>由于实际存储的长度不确定，Mysql不允许text类型作为主键</p>
<blockquote>
<p>如果频繁的使用表，不建议包含text类型，建议单独分出，因为text类型如果删除后容易导致空洞，造成文件碎片</p>
</blockquote>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220510171950903.png" alt="image-20220510171950903"></p>
<p><em><strong>enum</strong></em></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">	season enum(<span class="string">&#x27;春&#x27;</span>,<span class="string">&#x27;夏&#x27;</span>,<span class="string">&#x27;秋&#x27;</span>,<span class="string">&#x27;冬&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>添加数据时候只能从中选取一个添加，且不区分大小写</p>
<p><em><strong>set</strong></em></p>
<p>set表示一个字符串对象，可以包含0个或多个成员，上限为64</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">	s <span class="keyword">set</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test(s) <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>),(<span class="string">&#x27;a,b&#x27;</span>)</span><br></pre></td></tr></table></figure>





<h3 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h3><p><em><strong>binary &#x2F; varbinary</strong></em></p>
<blockquote>
<p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p>
<p>BINARY(M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M),表示只能存储1个字节。例如BINARY(8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充’\o’以补齐指定长度。</p>
<p>VARBINARY(M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型必须指定(M)，否则报错。</p>
</blockquote>
<p><em><strong>blob</strong></em></p>
<p>blob是一个二进制大对象，可以容纳可变数量的数据</p>
<p>MysQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如图片、音频和视频等。</p>
<p>需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到服务器的磁盘上，并将图片、音频和视频的访问路径存储到MySQL中。</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220510172024482.png" alt="image-20220510172024482"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java中存储blob类型到数据库</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(path));</span><br><span class="line"><span class="type">int</span> length=in.available();</span><br><span class="line">pre.setBinaryStream(index,in,length);</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><strong>为什么需要约束</strong></p>
<p>数据完整性是指数据的精确性和可靠性。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</p>
<p>为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>实体完整性</td>
<td>例如，同一个表中，不能存在两条完全相同无法区分的记录</td>
</tr>
<tr>
<td>域完整性</td>
<td>例如:年龄范围0-120，性别范围“男&#x2F;女”</td>
</tr>
<tr>
<td>引用完整性</td>
<td>例如:员工所在部门，在部门表中要能找到这个部门</td>
</tr>
<tr>
<td>用户自定义完整性</td>
<td>例如:用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍</td>
</tr>
</tbody></table>
<p><strong>如何添加、修改、删除约束</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">create</span> <span class="keyword">table</span> 时添加约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">	字段名 数据类型 约束</span><br><span class="line">	...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#<span class="keyword">alter</span> <span class="keyword">table</span> 时修改约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> 约束</span><br><span class="line"></span><br><span class="line">#删除约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="keyword">drop</span> 约束</span><br></pre></td></tr></table></figure>



<p><strong>约束的分类</strong></p>
<p>表级约束：定义完所有字段再添加约束</p>
<p>列级约束：定义字段的同时定义约束</p>
<p><strong>约束的作用</strong></p>
<ul>
<li><p>非空约束（NOT NULL）：限定某个字段 &#x2F; 某列的值不允许为空</p>
</li>
<li><p>唯一性约束（UNIQUE）：限制某个字段 &#x2F; 某列的值不允许重复</p>
</li>
<li><p>主键约束（PRIMARY KEY）：主键约束相当于唯一性约束+非空约束，主键不允许重复也不允许出现空值；当创建主键约束时，系统会默认在所在的字段上建立对于的主键索引，一个表中只能有一个主键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#删除主键约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">primary</span> key</span><br></pre></td></tr></table></figure>

<ul>
<li><p>auto_increment</p>
<p>作用：某个字段的值自增</p>
<ul>
<li><p>自增列必须是主键列或唯一性列</p>
</li>
<li><p>自增列的数据类型必须是整数类型</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外键约束（FOREIGN KEY）：限定某个表的某个字段的引用完整性；创建表时要先创建主表再创建从表，删除时反之；创建外键约束时会自动加上普通索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#表级约束</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_empl_dept_id <span class="keyword">FOREIGN</span> KEY (department_id) <span class="keyword">REFERENCES</span> dept1(dept_id)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>约束等级</em></p>
<p>1、cascade：父表上更新、删除记录时，同步到子表</p>
<p>2、set null：父表上更新、删除记录时，将子表中的相应字段设为null</p>
<p>3、no action：如果子表中有匹配的记录时，不允许父表对候选键进行更新、删除</p>
<p>4、set default：父表上更新、删除记录时，将子表中的相应字段设为默认值</p>
</li>
<li><p><em>设置约束等级</em></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREIGN</span> KEY(deptid) <span class="keyword">REFERENCES</span> dept(did)<span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p> 在MysQL里，外键约束是有成本的，需要消耗系统资源。对于大并发的SQL操作，有可能会不适合。增、删、更新都会进行对数据进行约束性检查，从而耗费资源。</p>
<p> 比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢。所以，MySQL允许你不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p>
</blockquote>
</li>
<li><p><em>检查约束（CHECK）</em>：检查数据是否在某个范围内</p>
</li>
<li><p><em>默认值约束（DEFAULT）</em>：</p>
</li>
</ul>
<hr>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><strong>为什么要使用视图</strong></p>
<p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。</p>
<p><strong>概述</strong></p>
<ul>
<li><p>视图建立在已有表的基础之上</p>
</li>
<li><p>视图是一种虚拟表，本身时不具有数据的，占用很少的内存空间，操作时就是对基表进行操作</p>
<img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220511161410337.png" alt="image-20220511161410337" style="zoom:50%;">
</li>
<li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p>
</li>
<li><p><strong>向视图提供数据内容的语句为SELECT语句,可以将视图理解为存储起来的 SELECT语句</strong></p>
</li>
</ul>
<p><strong>创建视图</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#精简版</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名</span><br><span class="line"><span class="keyword">as</span> 查询语句</span><br><span class="line"></span><br><span class="line">#自定义字段名匹配</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名(字段名...)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> 字段名...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#也可以存储多表查询</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名</span><br><span class="line"><span class="keyword">as</span> 多表查询语句</span><br></pre></td></tr></table></figure>



<p><strong>查看视图</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#查看视图对象</span><br><span class="line"><span class="keyword">show</span> tables</span><br><span class="line"></span><br><span class="line">#查看视图结构</span><br><span class="line"><span class="keyword">describe</span> 视图名</span><br><span class="line"></span><br><span class="line">#查看视图的属性信息</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">like</span> <span class="string">&#x27;字段名&#x27;</span></span><br><span class="line"></span><br><span class="line">#查看视图的详细定义信息</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名</span><br></pre></td></tr></table></figure>



<p><strong>视图中增删改操作都跟之前介绍的一样，这里就不再赘述</strong></p>
<p><strong>修改视图</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#使用 <span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 语句修改视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名</span><br><span class="line"><span class="keyword">as</span> 查询语句</span><br><span class="line"></span><br><span class="line">#使用<span class="keyword">alter</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名</span><br><span class="line"><span class="keyword">as</span> 查询语句</span><br></pre></td></tr></table></figure>



<p><strong>删除视图</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> 视图名</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>视图的优点</strong></p>
<ul>
<li><strong>减少数据冗余</strong></li>
</ul>
<p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p>
<ul>
<li><strong>数据安全</strong></li>
</ul>
<p>MysQL将用户对数据的访问限制在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有隔离性。视图相当于在用户和实际的数据表之间加了一层虚拟表。</p>
<p><strong>视图的缺点</strong></p>
<ul>
<li><strong>维护成本高</strong></li>
</ul>
<p>如果我们在实际数据表的基础上创建了视图，那么，如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图)，维护会变得比较复杂，可读性不好，容易变成系统的潜在隐患。因为创建视图的sQL查询可能会对字段重命名，也可能包含复杂的逻辑。这些都会增加维护的成本。</p>
</blockquote>
<hr>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p><strong>含义</strong></p>
<p>就是一组经过预先编译的SQL语句的封装；执行过程：存储过程预先存储在Mysql服务器上，需要执行的时候，客户端只需要想服务器发出调用存储过程的命令，服务端就可以把预先存储好的这一系列SQL语句全部执行</p>
<p><strong>与视图和函数相比</strong></p>
<p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的sQL，<strong>可以直接操作底层数据表</strong>，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。</p>
<p>一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。<strong>相较于函数，存储过程是没有返回值的</strong>。</p>
<p><strong>创建存储过程</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> (存储过程名 <span class="keyword">in</span>（有参）<span class="operator">|</span> <span class="keyword">out</span>（有返回值）<span class="operator">|</span> <span class="keyword">inout</span>（有参有返回值）)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	存储过程体（比如查询）</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<p><strong>存储过程的调用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> 存储过程名()</span><br></pre></td></tr></table></figure>



<p>例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#查出员工中工资最少的</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">out</span> output <span class="type">int</span>（数据类型）)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">min</span>(salary) <span class="keyword">into</span> output</span><br><span class="line">	<span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test(<span class="variable">@output</span>（直接定义一个用户变量）)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@output</span></span><br><span class="line"></span><br><span class="line">#查出jjw的工资</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test(<span class="keyword">in</span> input <span class="type">varchar</span>(<span class="number">20</span>)（数据类型）)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">select</span> salary</span><br><span class="line">	<span class="keyword">from</span> emp</span><br><span class="line">	<span class="keyword">where</span> last_name <span class="operator">=</span> input</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">##直接传参数</span><br><span class="line"><span class="keyword">call</span> test(<span class="string">&#x27;jjw&#x27;</span>（直接定义一个变量）)</span><br><span class="line">##传递一个变量</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@name</span> <span class="operator">=</span> <span class="string">&#x27;jjw&#x27;</span></span><br><span class="line"><span class="keyword">call</span> test(<span class="variable">@name</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在Mysql数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据；在Mysql数据库中，变量分为<strong>系统变量以及用户自定义变量</strong></p>
<h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>变量由系统定义，不是用户定义，属于服务器层面。启动MysQL服务，生成MySQL服务实例期间，MySQL将为MysQL服务器内存中的系统变量赋值，这些系统变量定义了当前MysQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数值。</p>
<p>系统变量分为<strong>全局系统变量</strong>（需要添加global关键字）以及<strong>会话系统变量</strong>（需要添加session关键字)，有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认会话级别。静态变量(在MySQL服务实例运行期间它们的值不能使用set动态修改）属于特殊的全局系统变量。</p>
<p><strong>查看系统变量</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables</span><br><span class="line"></span><br><span class="line">#查看所有会话变量</span><br><span class="line"><span class="keyword">show</span> session variables</span><br><span class="line"></span><br><span class="line">#查看满足条件的部分系统变量</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%标识符%&#x27;</span></span><br><span class="line"></span><br><span class="line">#查看指定系统变量</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.变量名</span><br><span class="line"></span><br><span class="line">#查看会话变量</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@session</span>.变量名</span><br><span class="line"><span class="keyword">select</span> @@变量名</span><br></pre></td></tr></table></figure>



<p><strong>修改系统变量</strong></p>
<p>方法一：修改Mysql配置文件，继而修改Mysql系统变量的值，修改完后需要重启Mysql服务</p>
<p>方法二：在Mysql服务运行期间，使用set命令重新设置系统变量的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@global</span>.变量名 <span class="operator">=</span> 变量值</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> 变量名 <span class="operator">=</span> 变量值</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@session</span>.变量名 <span class="operator">=</span> 变量值</span><br><span class="line"><span class="keyword">set</span> session 变量名 <span class="operator">=</span> 变量值</span><br></pre></td></tr></table></figure>



<h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>用户变量是用户自己定义的，作为MySQL编码规范，MySQL中的用户变量以一个“@”开头。根据作用范围不同又分为会话用户变量和局部变量。</p>
<ul>
<li>会话用户变量:作用域和会话变量一样，只对当前连接会话有效。</li>
<li>局部变量:只在BEGIN和END语句块中有效。局部变量只能在存储过程和函数中使用。</li>
</ul>
<p><strong>创建用户变量</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#定义会话用户变量</span><br><span class="line"><span class="keyword">set</span> @用户变量名 <span class="operator">=</span> 值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#定义局部变量：使用<span class="keyword">declare</span>声明；使用在begin...end中</span><br><span class="line"><span class="keyword">declare</span> 变量名 数据类型 默认值</span><br><span class="line"><span class="keyword">set</span> 变量名 <span class="operator">=</span> 值</span><br><span class="line">#例：</span><br><span class="line">DELIMITER <span class="operator">&amp;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    #声明</span><br><span class="line">    <span class="keyword">DECLARE</span> emp_name <span class="type">VARCHAR</span>(<span class="number">25</span>);</span><br><span class="line">    <span class="keyword">DECLARE</span> sal <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">0.0</span>;#赋值</span><br><span class="line">    <span class="keyword">SELECT</span> last_name,salary <span class="keyword">INTO</span> emp_name,sal</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">102</span>;#使用</span><br><span class="line">    <span class="keyword">SELECT</span> emp _name,sal;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">&amp;</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#使用用户变量</span><br><span class="line"><span class="keyword">select</span> @变量名</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是由事件来触发某个操作，这些事件包括INSERT、UPDATE、DELETE事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。</p>
<p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现</p>
<p><strong>创建触发器</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名</span><br><span class="line">before<span class="operator">|</span>after  <span class="keyword">insert</span><span class="operator">|</span><span class="keyword">update</span><span class="operator">|</span><span class="keyword">delete</span>  <span class="keyword">on</span> 表名</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">触发器执行语句块</span><br></pre></td></tr></table></figure>



<p>例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> before_insert</span><br><span class="line">before <span class="keyword">insert</span> <span class="keyword">on</span> test_trigger_log</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><p>Mysql是经典的 C&#x2F;S 架构，服务端程序使用的是 mysqld</p>
<p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是:<strong>客户端进程向服务器进程发送一段文本(SQL语句)，服务器进程处理后再向客户端进程发送一段文本(处理结果)。</strong></p>
<img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220513155005095.png" alt="image-20220513155005095" style="zoom:80%;">



<p><em><strong>第一层：连接层</strong></em></p>
<p> 系统（客户端）访问MySQL服务器前，做的第一件事就是建立TCP连接；经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证、权限获取。</p>
<p>多个系统都可以和MysQL服务器建立连接，每个系统建立的连接肯定不止一个。所以，为了解决TCP无限创建与TCP频繁创建销毁带来的资源耗尽、性能下降问题。<strong>Mysql 服务器里有专门的TCP连接池限制连接数，采用长连接模式复用TCP连接</strong>，来解决上述问题。</p>
<p>TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<p><strong>两个池：TCP连接池、线程池</strong></p>
<p><em><strong>第二层：服务层</strong></em></p>
<p>第二层架构主要完成大多数的<strong>核心服务功能</strong>，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。<strong>所有跨存储引擎的功能也在这一层实现</strong>，如过程、函数等。</p>
<p>在该层，服务器会<strong>解析查询</strong>并创建相应的内部解析树，并对其完成相应的优化∶如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p>
<p>如果是SELECT语句，服务器还会<strong>查询内部的缓存</strong>。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<p><strong>服务层包含了：解析器、查询优化器、查询缓存组件</strong></p>
<p><em><strong>第三层：引擎层</strong></em></p>
<p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的MysQL还允许开发人员设置自己的存储引擎。</p>
<p>插件式存储引擎层，<strong>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信</strong>。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<p><em><strong>第四层：存储层</strong></em></p>
<p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。</p>
<h3 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h3><p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220513162917335.png" alt="image-20220513162917335"></p>
<p>查询缓存：server如果在查询缓存中发现了这条SQL语句，就直接将结果返回给客户端，如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存的命中率太低<strong>（因为sql语句要完全一样，且Mysql的缓存系统会对涉及到的每张表进行监测，如果该表的结构或数据被修改了，该缓存就会失效）</strong>，所以在 Mysql8.0 之后就抛弃了这个功能</p>
<p>查询优化器：查询优化器分为<strong>逻辑查询优化和物理查询优化</strong></p>
<ul>
<li>物理查询优化则是通过索引和表连接方式等技术来进行优化，这里重点需要掌握索引的使用。</li>
<li>逻辑查询优化就是通过SOL等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220513165824308.png" alt="image-20220513165824308"></p>
<hr>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>为了管理方便，人们把 连接管理、查询缓存、语法解析、查询优化这些并<strong>不涉及真实数据存储的功能划分为Mysql server的功能，把真实存取数据的功能划分为存储引擎的功能</strong>。所以在Mysql server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。Mysql5.5之后默认存储引擎为innoDB</p>
<p>可以设置默认的存储引擎，也可以针对表修改存储引擎</p>
<h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><p><strong>具备外键功能的事务存储引擎</strong></p>
<ul>
<li>InnoDB是Mysql的默认事务型引擎，它被设计用来处理大量的短期事务，可以确保事务的完整提交和回滚</li>
<li>除了增加和查询之外，还需要更新、删除操作，那么应优先使用InnoDB存储引擎</li>
<li>InnoDB是为处理巨大数据量的最大性能设计的</li>
<li><strong>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</strong></li>
<li><strong>相比MyISAM，InnoDB使用的是行级锁，读效率更高；但会占用更多的磁盘空间以保存数据和索引，所以写效率更低</strong></li>
<li>应用场景：并发量高、需要读写事务的场景</li>
</ul>
<p><strong>MyISAM存储引擎</strong></p>
<ul>
<li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务、行级锁、外键。有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li>
<li>5.5之前默认的存储引擎</li>
<li>优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li>
<li>应用场景：只读或以读为主的业务</li>
</ul>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还缓存真实数据，对内存要求较高</td>
</tr>
<tr>
<td>关注点</td>
<td>性能：节省资源、消耗少、简单业务</td>
<td>事务：并发写、事务、更大资源</td>
</tr>
</tbody></table>
<hr>
<h3 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h3><p><strong>磁盘与内存交互的基本单位：页</strong></p>
<p>InnoDB将数据划分为若干个页，InnoDB中页的默认大小为16KB</p>
<p>以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。<strong>也就是说，在数据库中。不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页(Page)，数据库 I&#x2F;O 操作的最小单位是页</strong>。一个页中可以存储多个行记录。</p>
<h4 id="页结构概述"><a href="#页结构概述" class="headerlink" title="页结构概述"></a>页结构概述</h4><p>页可以不在物理结构上相连，只要通过双向链表相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里面的记录生成一个页目录</p>
<p>了解页的结构有助于我们理解B+树</p>
<hr>
<h4 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h4><p>另外在数据库中，还存在着区、段和表空间的概念。关系如下</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220517134424934.png" alt="image-20220517134424934"></p>
<p>区：是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配64个连续的页。因为InnoDB中一页的大小默认是16KB，所以一个区的大小是64*16KB&#x3D;1MB</p>
<p>段：由一个或多个区组成，区在文件系统是一个连续分配的空间，不过段中不要求区与区之间是相邻的。<strong>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在</strong>。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段</p>
<p>表空间：是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，<strong>表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间</strong>等。</p>
<hr>
<h4 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h4><p>页如果按类型划分的话，常见的有数据页（保存B+树节点)、系统页、Undo页和事务数据页等。数据页是我们最常使用的页。</p>
<p>数据页的16KB大小的存储空间被划分为七个部分，分别是</p>
<ul>
<li>文件头：描述页的信息</li>
<li>页头：页的状态信息</li>
<li>最大最小记录：最大和最小记录，这是两个虚拟的行记录</li>
<li>用户记录：存储行记录内容</li>
<li>空闲空间：页中还没有被使用的空间</li>
<li>页目录：存储用户记录的相对位置</li>
<li>和文件尾：校验页是否完整</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220517140204584.png" alt="image-20220517140204584"></p>
<p><strong>文件头包含</strong></p>
<ul>
<li>FIL_PAGE_OFFSET：相当于页号</li>
<li>FIL_PAGE_TYPE：页的类型；可能是数据页、系统页、…</li>
<li>FIL_PAGE_PREV 和 FIL_PAGE_NEXT：上一页、下一页内存地址</li>
<li>FIL_PAGE_SPACE_OR_CHKSUM：校验和；用于校验两个页是否一样</li>
<li>FIL_PAGE_LSN：页面被最后修改时对应的日志序列位置</li>
</ul>
<blockquote>
<p>校验和的作用</p>
<p>InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。</p>
<p>为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况〉，这时可以通过文件尾的校验和（checksum值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输己已经完成。</p>
</blockquote>
<p><strong>文件尾部包含</strong></p>
<ul>
<li>FIL_PAGE_SPACE_OR_CHKSUM：校验和；用于校验两个页是否一样</li>
<li>FIL_PAGE_LSN：页面被最后修改时对应的日志序列位置</li>
</ul>
<blockquote>
<p>FIL_PAGE_SPACE_OR_CHKSUM，FIL_PAGE_LSN这两个字段其实就是用来校验一个页是否完整</p>
</blockquote>
<hr>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><strong>为什么使用索引</strong></p>
<p>索引是存储引擎用于快速找到数据记录的一种数据结构，<strong>就好比一本教课书的目录部分</strong>，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MysQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录；索引的目的就是为了减少磁盘 I&#x2F;O 的次数，加快查询速率</p>
<p><strong>概述</strong></p>
<ul>
<li><strong>索引是帮助Mysql高效获取数据的数据结构</strong></li>
<li><strong>索引的本质：</strong>索引是数据结构；可以理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法</li>
<li><strong>索引是在存储引擎中实现的</strong>，因此每种存储引擎的索引不一定完全相同，所以说索引是B+树实现的 是不准确的，应该说在InnoDB存储引擎中，索引是B+树实现的</li>
</ul>
<h3 id="索引的推演"><a href="#索引的推演" class="headerlink" title="索引的推演"></a>索引的推演</h3><p><strong>单页查找</strong></p>
<p>一个数据表中可能有庞大的数据量，InnoDB中一个表中会分成多页，一个页的容量为16KB。在一个页中的每一条数据按照主键顺序排放，排放好的数据可以按照二分法进行查找，使得时间复杂度从 O(n) 变为 O(ln n)</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220515131847834.png" alt="image-20220515131847834"></p>
<p><strong>多页查找</strong></p>
<p>在庞大的数据量情况下，一页肯定是不够的，所以我们需要多页来存放数据，当然每一页并不是按照页号来排放，页号仅仅是一个具体的内存地址；当我们需要向某一页插入一条，而这一页已满的时候，最后一条数据向后移动到下一页</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220515132024636.png" alt="image-20220515132024636"></p>
<p>这样在多页中进行查找的情况下就是拆分成单页进行查找，一个页中没找到，换到下一个页</p>
<img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220515131934699.png" alt="image-20220515131934699" style="zoom:50%;">



<p><strong>建立目录项</strong></p>
<p>多页查询的弊端就是数据之前的每一页都需要进行查询，这样的效率会降低。那么我们就给每一页创建一个目录项，<strong>目录项记录页号和每一页的最小值</strong>，这样的话每次查找先在目录项中使用二分法查找到数据应该在哪一页，之后再进入这一页查找数据</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220515132209662.png" alt="image-20220515132209662"></p>
<p><strong>目录页</strong></p>
<p>目录项之间肯定也需要采用单向链表的方式存储，所以我们不妨也给目录项制成一张目录表</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220515135654543.png" alt="image-20220515135654543"></p>
<p>如此反复套娃下去就形成了B+树的结构</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220515140132423.png" alt="image-20220515140132423"></p>
<p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为叶子节点，其余用来存放目录项的节点称为非叶子节点或者内节点，其中B+树最上边的那个节点也称为根节点。</p>
<p>虽然只有几个节点但是能存放的数据 量是非常庞大的，假设一个节点能存1000条数据，那么如上图的B+树就能够存放1000*1000*1000 &#x3D; 1000000000 条数据，而且因为树的高度仅为3，所以我们仅需要经过3次 I&#x2F;O 就能找到数据</p>
<hr>
<h3 id="常见的索引"><a href="#常见的索引" class="headerlink" title="常见的索引"></a>常见的索引</h3><p>索引按照物理实现方式可分为2种</p>
<ul>
<li>聚簇索引</li>
<li>非聚簇索引（二级索引）</li>
</ul>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是一种单独的索引类型，而是一种<strong>数据存储方式</strong>（所有的用户记录都存储在叶子节点），<strong>也就是所谓的索引即数据，数据即索引</strong>；一张表中只能由一个聚簇索引</p>
<p><strong>特点</strong></p>
<ul>
<li>页内的记录是按主键大小排成一个单向链表</li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表</li>
<li>B+树的叶子节点存储的是完整的用户记录</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树种，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快</li>
<li>按照聚簇索引排列顺序，查询显式一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的 io 操作</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则会出现页分裂，严重影响性能</li>
<li>更新主键的代价很高</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键找到数据</li>
</ul>
<h4 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h4><p>如果我们想以别的列作为搜索条件怎么办？我们可以多建几可B+树</p>
<p>这个B+树与上面介绍的聚簇索引有几处不同</p>
<ul>
<li>叶子节点存储的并不是完整数据，而只是某一列和主键两个列的值</li>
<li>目录项不再是主键+页号，而是某一列+页号</li>
</ul>
<p>例：如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为4的记录为例，查找过程如下:</p>
<ol>
<li>确定目录项记录页<br>根据根页面，也就是页44，可以快速定位到目录项记录所在的页为页42(因为2 &lt; 4 &lt; 9)。</li>
<li>通过目录项记录页确定用户记录真实所在的页。<br>在页42中可以快速定位到实际存储用户记录的页，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为 2 &lt; 4 ≤ 4，所以确定实际存储用户记录的页在页34和页35中。</li>
<li>在真实存储用户记录的页中定位到具体的记录。<br>到页34和页35中定位到具体的记录。</li>
<li>但是这个B+树的叶子节点中的记录只存储了c2和c1(也就是主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找—遍完整的用户记录。</li>
</ol>
<p><strong>回表</strong></p>
<p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据c2列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查一遍，这个过程称为回表。也就是根据c2列的值查询一条完整的用户记录需要使用到2棵B+树!</p>
<blockquote>
<p>聚簇索引与非聚簇索引区别</p>
<ul>
<li>聚簇索引的叶子节点存储的就是我们的数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li>一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。</li>
<li>使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li>
</ul>
</blockquote>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>我们也可以同时以多个列作为排序规则，也就是同时为多个列建立索引，比如说我们想让B+树按照c2和c3列的大小进行排序，这包含两层含义：</p>
<ul>
<li>先把各个记录和页按照c2列进行排序</li>
<li>在记录的c2列相同的情况下，采用c3列进行排序</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220516171006349.png" alt="image-20220516171006349"></p>
<hr>
<h3 id="InnoDB的B-树索引注意事项"><a href="#InnoDB的B-树索引注意事项" class="headerlink" title="InnoDB的B+树索引注意事项"></a>InnoDB的B+树索引注意事项</h3><p><strong>根页面位置万年不动</strong></p>
<p>上述推演为了理解上的方便，是从叶子节点向上推演的，然而索引底层实现并不是这样的</p>
<p>而是先生成一个叶子节点后，如果存放的数据个数超过这个叶子节点的存储大小，则再生成两个叶子节点，然后将一开始的叶子节点上的数据复制到这两个新的叶子节点上，一开始的叶子节点变成根节点，由此往复</p>
<p><strong>非叶子节点中目录项记录的唯一性</strong></p>
<p>非叶子节点中存放的是目录项，我们必须确保目录项是唯一的，否则插入一条数据的时候不能确定再哪张表中插入，所以可以加入主键作为联合索引</p>
<p><strong>一个页面最少存储两条记录</strong></p>
<hr>
<h3 id="MyISAM中的索引-了解即可"><a href="#MyISAM中的索引-了解即可" class="headerlink" title="MyISAM中的索引(了解即可)"></a>MyISAM中的索引(了解即可)</h3><p>MyISAM的索引方案虽然也是采用B+树的结构，但却将索引和数据分开存储，叶子节点存放的是数据记录的地址</p>
<ul>
<li>将表中的记录<strong>按照记录的插入顺序单独存储在一个文件中</strong>，称之为<strong>数据文件</strong>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。</li>
<li>使用MyISAM存储引擎的表会把<strong>索引信息另外存储到一个称为索引文件的另一个文件中</strong>。MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<strong>主键值＋数据记录地址的组合</strong>。</li>
</ul>
<hr>
<h3 id="为什么使用B-树而不使用B树呢"><a href="#为什么使用B-树而不使用B树呢" class="headerlink" title="为什么使用B+树而不使用B树呢"></a>为什么使用B+树而不使用B树呢</h3><p>B树图示：</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220517104501370.png" alt="image-20220517104501370"></p>
<p>可以看出B树的非叶子节点同样也存放数据</p>
<blockquote>
<p><strong>B树非叶子节点不存放数据有什么好处呢？</strong></p>
<ul>
<li>首先，B+树查询效率更稳定。因为B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</li>
<li>其次，B+树的查询效率更高。这是因为通常B+树比B树更矮胖（阶数更大，深度更低)，查询所需要的磁盘I&#x2F;o也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。</li>
<li>不仅是对单个关键字的查询上，在查询范围上，B+树的效率也比B树高。这是因为所有关键字都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</li>
</ul>
</blockquote>
<hr>
<h3 id="索引的创建与设计原则"><a href="#索引的创建与设计原则" class="headerlink" title="索引的创建与设计原则"></a>索引的创建与设计原则</h3><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><p>Mysql的索引包括了普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等</p>
<ul>
<li>从功能逻辑上说，索引分为4种：分别是普通索引、唯一索引、主键索引、全文索引</li>
<li>按照物理实现方式来说，索引可分为2种：聚簇索引和非聚簇索引</li>
<li>按照作用的字段进行划分，可分为单列索引和联合索引</li>
</ul>
<p><strong>普通索引</strong></p>
<p>在创建普通索引时，<strong>不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其值是否唯一和非空，要由字段本身的完整性约束条件决定</strong>。建立索引以后，可以通过索引进行查询。例如，在表student的字段name上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p>
<p><strong>唯一性索引</strong></p>
<p>使用UNIQUE参数可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的但允许有空值。在一张数据表里可以有多个唯一索引。例如，在表student的字段email中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。</p>
<p><strong>主键索引</strong></p>
<p>主键索引就是一种特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是NOTNULL+UNIQUE，一张表里最多只有一个主键索引。这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储</p>
<p><strong>全文索引</strong></p>
<p>全文索引(也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p>
<hr>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>隐式：给字段添加上唯一性约束和主键约束后会自动、隐式的为字段创建唯一性索引和主键索引</p>
<p>显示：</p>
<ul>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 </span><br><span class="line">索引类型 index 索引名(作用的字段（多个字段逗号隔开）) [<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>]</span><br></pre></td></tr></table></figure>


</li>
<li><p>创建主键索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">... <span class="keyword">PRIMARY</span> KEY</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#<span class="keyword">ALTER</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (`<span class="keyword">column</span>`)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建唯一索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">...</span><br><span class="line"><span class="keyword">unique</span> index 索引名(作用的字段) [<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>]</span><br><span class="line"></span><br><span class="line">#<span class="keyword">ALTER</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (`<span class="keyword">column</span>`)</span><br><span class="line"></span><br><span class="line">#<span class="keyword">CREATE</span> <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index index_name <span class="keyword">on</span> table_name(`<span class="keyword">column</span>`)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建单列索引和联合索引（普通索引）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">...</span><br><span class="line">index 索引名(作用的字段) [<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br><span class="line">...</span><br><span class="line">index 索引名(字段<span class="number">1</span>,字段<span class="number">2.</span>..) [<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>]</span><br><span class="line"></span><br><span class="line">#<span class="keyword">ALTER</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (`<span class="keyword">column</span>`)</span><br><span class="line"></span><br><span class="line">#<span class="keyword">CREATE</span> <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">create</span> index index_name <span class="keyword">on</span> table_name(`<span class="keyword">column</span>`)</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注：当创建联合索引后，比如 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index  test_index(id,name)</span><br></pre></td></tr></table></figure>

<p> 当查询 name 字段时是不会走索引的，因为在索引上查找是按创建时字段的先后顺序的，上面创建的这个索引会先走 id 字段，如果 id 一样再走 name 字段，所以查询一个 name 字段不会走这个索引</p>
<p><strong>这就是最左匹配原则，以最左边的为起点任何连续的索引都能匹配上</strong></p>
</blockquote>
<hr>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><ul>
<li><p>alter  table</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name</span><br><span class="line"><span class="keyword">drop</span> index index_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>drop  index</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index index_name</span><br><span class="line"><span class="keyword">on</span> table_name</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。<strong>索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍</strong>。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p>
<h4 id="适合索引的情况"><a href="#适合索引的情况" class="headerlink" title="适合索引的情况"></a>适合索引的情况</h4><ul>
<li><p><strong>字段的数值具有唯一性的特点</strong></p>
</li>
<li><p><strong>频繁作为where查询条件的字段</strong></p>
</li>
</ul>
<p>某个字段在SELECT语句的WHERE条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
<ul>
<li><strong>经常 group by 和 order by 的字段</strong></li>
</ul>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用GROUP BY对数据进行分组查询，或者使用ORDER BY对数据进行排序的时候，就需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立组合索引，因为索引本身就是有序的。</p>
<p>如果 group by 和 order by 两个字段一起出现，则创建联合索引，其顺序应为先 group by 字段再 order by 字段</p>
<ul>
<li><strong>distinct字段需要创建索引</strong></li>
</ul>
<p>因为B+树上都是有序的，相同的字段都是紧挨在一起，去重更容易</p>
<ul>
<li><p><strong>多表 join 连接操作时，对用于连接的字段创建索引</strong></p>
</li>
<li><p><strong>使用列的类型较小的创建索引</strong></p>
</li>
</ul>
<p>列的类型较小的意思是类型的数据范围较少，比如varchar（10） 和 varchar（20）</p>
<p>数据类型越小，在查询时候进行的比较操作越快，且索引占用的存储空间越少</p>
<ul>
<li><p><strong>使用字符串前缀创建索引</strong></p>
</li>
<li><p><strong>散列性高的列适合作为索引</strong></p>
</li>
</ul>
<p>比如100w条数据中，性别就不适合作为索引，因为性别只有两种，散列性太低了</p>
<ul>
<li><strong>使用最频繁的字段放在联合索引的左侧</strong></li>
</ul>
<p>where id &#x3D; … and name &#x3D; … 如果创建的索引顺序是先name再id那么这个查询就用不到这个联合索引了（但是优化器可能会优化select语句，将其调换，使其能使用索引）</p>
<ul>
<li><strong>多个字段都要创建索引的情况下，联合索引优于单列索引</strong></li>
</ul>
<hr>
<h4 id="不适合索引的情况"><a href="#不适合索引的情况" class="headerlink" title="不适合索引的情况"></a>不适合索引的情况</h4><ul>
<li><strong>where中使用不到的字段不设置索引</strong></li>
</ul>
<p>如果起不到定位的字段通常是不需要创建索引的</p>
<ul>
<li><strong>数据量小的表最好不要使用索引</strong></li>
</ul>
<p>如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，是否创建索引对查询效率的影响并不大。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果</p>
<ul>
<li><p><strong>有大量重复数据的列上不要建立索引</strong></p>
</li>
<li><p><strong>避免对经常更新的表创建过多的索引</strong></p>
</li>
</ul>
<p>因为更新数据时，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率</p>
<ul>
<li><strong>不建议用无序的值作为索引</strong></li>
</ul>
<p>例如身份证、uuid这些虽然是唯一的、非空的，但是作为主键索引的话插入时很有可能经常造成页分裂</p>
<ul>
<li><strong>不要定义冗余或重复的索引</strong></li>
</ul>
<hr>
<h4 id="限制索引的数目"><a href="#限制索引的数目" class="headerlink" title="限制索引的数目"></a>限制索引的数目</h4><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过6个。原因:</p>
<ul>
<li>每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大</li>
<li>索引回影响insert、delect、update等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，造成负担</li>
<li>优化器再选择如何优化查询时，会根据同一信息，对每一个可以用到的索引进行评估，以生成出一个最好的执行计划，如果同时有多个索引都可以用于查询，会增加Mysql优化器生成执行计划的时间，降低查询性能</li>
</ul>
<hr>
<h3 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h3><p>都有哪些维度可以进行数据库调优？</p>
<ul>
<li>索引失效、没有充分利用到索引――索引建立</li>
<li>关联查询太多JOIN(设计缺陷或不得已的需求)——SQL优化</li>
<li>务器调优及各个参数设置（缓冲、线程数等）――调整my.cnf</li>
<li>数据过多—―分库分表</li>
</ul>
<h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><h4 id="外连接与内连接的查询优化"><a href="#外连接与内连接的查询优化" class="headerlink" title="外连接与内连接的查询优化"></a>外连接与内连接的查询优化</h4><h4 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h4><h4 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h4><h4 id="GROUP-BY优化"><a href="#GROUP-BY优化" class="headerlink" title="GROUP BY优化"></a>GROUP BY优化</h4><h4 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h4><hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务概述</strong></p>
<p>事务是数据库区别于文件系统的重要特征之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失</p>
<p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态</p>
<p><strong>事务处理的原则：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，<strong>要么所有的事务都被提交( commit)，那么这些修改就永久地保存下来;要么数据库管理系统将放弃所作的所有修改，整个事务回滚( rollback )到最初状态。</strong></p>
<p><strong>事务的ACID特性</strong></p>
<ul>
<li>原子性</li>
</ul>
<p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。即要么转账成功，要么转账失败，是不存在中间的状态。如果无法保证原子性会怎么样?就会出现数据不一致的情形，A账户减去100元，而B账户增加100元操作失败，系统将无故丢失100元。</p>
<ul>
<li>一致性</li>
</ul>
<p>根据定义，一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。这种状态是语义上的而不是语法上的，跟具体的业务有关。</p>
<ul>
<li>隔离性</li>
</ul>
<p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<ul>
<li>持久性</li>
</ul>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<p><strong>事务的状态</strong></p>
<ul>
<li>活动的</li>
</ul>
<p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态</p>
<ul>
<li>部分提交的</li>
</ul>
<p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态</p>
<ul>
<li>失败的</li>
</ul>
<p>当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。</p>
<ul>
<li>中止的</li>
</ul>
<p>如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</p>
<ul>
<li>提交的</li>
</ul>
<p>当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220520162654164.png" alt="image-20220520162654164"></p>
<hr>
<h3 id="事务基础知识"><a href="#事务基础知识" class="headerlink" title="事务基础知识"></a>事务基础知识</h3><h4 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h4><p>开启事务</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#方式一</span><br><span class="line"><span class="keyword">start</span> transaction [read <span class="keyword">only</span> <span class="operator">/</span> read write（默认） <span class="operator">/</span> <span class="keyword">with</span> consistent snapshot]</span><br><span class="line"></span><br><span class="line">#方式二</span><br><span class="line"><span class="keyword">begin</span></span><br></pre></td></tr></table></figure>





<h4 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h4><p>默认情况下，如果我们不显式的使用START TRANSACTION或者BEGIN语句开启一个事务，<strong>那么每一条语句都算是一个独立的事务</strong>，这种特性称之为事务的自动提交</p>
<p>关闭自动提交</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#方式一</span><br><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">#方式二</span><br><span class="line">#显式的开启事务</span><br></pre></td></tr></table></figure>





<p><strong>提交事务</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#提交事务</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>



<p><strong>回滚事务</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#回到上一次提交后的情形</span><br><span class="line"><span class="keyword">rollback</span></span><br></pre></td></tr></table></figure>



<p><strong>设置保存点</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置保存点，相当于快照</span><br><span class="line"><span class="keyword">savepoint</span> 保存点名</span><br><span class="line"></span><br><span class="line">#回滚到保存点</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> 保存点名</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="数据并发问题"><a href="#数据并发问题" class="headerlink" title="数据并发问题"></a>数据并发问题</h3><p>数据在并发情况下可能会产生如下问题</p>
<h4 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h4><p>对于两个事务A、B，如果事务A修改了另一个未提交的事务B修改过的数据就会产生<strong>脏写</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220521213501204.png" alt="image-20220521213501204"></p>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为’李四，然后Session A中的事务接着又把这条studentno列为1的记录的name列更新为’张三’。<strong>如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象就称之为脏写。这时session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。</strong>这里大家对事务的隔离级比较了解的话，会发现默认隔离级别下，上面SessionA中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样现象。</p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>对于两个事务A、B，事务A读取了已经被事务B更新但还没有被提交的字段。之后若事务B回滚，事务A读取的内容就是临时且无效的</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220521215142983.png" alt="image-20220521215142983"></p>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为’张三’，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为’张三’，而Session B中的事务稍后进行了回滚，<strong>那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。</strong></p>
<h4 id="不可重复度"><a href="#不可重复度" class="headerlink" title="不可重复度"></a>不可重复度</h4><p>对于两个事务A、B，事务A读取了一个字段，然后事务B更新了该字段。之后事务A再次读取同一个字段，值就不同了。那就意味着发生了不可重复读</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220521215645112.png" alt="image-20220521215645112"></p>
<p>我们在Session B中提交了几个隐式事务（注意是隐式事务，意味着语句结束事务就提交了)，这些事务都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为不可重复读。</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220521220740894.png" alt="image-20220521220740894"></p>
<hr>
<h3 id="SQL中的四种隔离级别"><a href="#SQL中的四种隔离级别" class="headerlink" title="SQL中的四种隔离级别"></a>SQL中的四种隔离级别</h3><p>根据上面几种并发问题严重性排序后</p>
<p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
<p>设立一些隔离级别，隔离级别越低，并发问题发生的越多，<strong>SQL中设立了4种隔离级别</strong></p>
<ul>
<li><strong>读未提交：</strong>所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读</li>
<li><strong>读已提交：</strong>一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是Mysql默认的）。可以避免脏读，但不可避免不可重复读、幻读</li>
<li><strong>可重复读：</strong>在事务存在期间，不允许其他事务执行会影响这个事务正在访问的任何行的插入、更新或删除操作。可以避免脏读、不可重复读，但不可避免幻读，这是Mysql默认的隔离级别</li>
<li><strong>可串行化：</strong>确保事务可以从一个表中读取相同的慌。在这个事务持续期间，禁止其他事务对该表执行增删改。所有并发问题都可避免，但性能十分低下</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220522111932823.png" alt="image-20220522111932823"></p>
<p><strong>查看修改隔离级别</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看隔离级别</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;transaction_isolation&#x27;</span></span><br><span class="line"></span><br><span class="line">#修改隔离级别</span><br><span class="line"><span class="keyword">set</span> [<span class="keyword">global</span><span class="operator">|</span>session] transaction isolation level 隔离级别</span><br><span class="line">#<span class="keyword">global</span> 对全局范围进行设置，对当前会话无效</span><br><span class="line">#session 对当前会话的所有后续事务有效</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="Mysql事务日志"><a href="#Mysql事务日志" class="headerlink" title="Mysql事务日志"></a>Mysql事务日志</h3><p>事务的四种特性是基于什么机制实现的呢？</p>
<ul>
<li>事务的隔离性由锁机制实现</li>
<li>事务的原子性、一致性和持久性由事务的redo日志和undo日志来保证</li>
</ul>
<p>redo和undo都可以被视为一种恢复操作，但是：</p>
<ul>
<li>redo log 是存储引擎层生成的日志，记录的是“物理级别”上的页修改操作，比如页号、偏移量写入的数据。主要是为了保证数据的可靠性</li>
<li>undo log 是存储引擎层生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了insert语句操作，那么undo log就记录一条与之相反的delete操作。主要用于事务的回滚和一致性非锁定读</li>
</ul>
<h4 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h4><p>InnoDB存储引擎是以页为单位来管理存储空间的。在真正访问页面之前，需要把在磁盘上的页缓存到内存种的缓冲池之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘，通过缓冲池来优化CPU和磁盘之间鸿沟，这样就可以保证整体的性能不会下降太快</p>
<p><strong>为什么需要redo日志</strong></p>
<p>由于刷盘操作并不是每次变更就触发，所以可能存在事务提交后，刚写完缓冲池，数据库就宕机了，那么这段数据就丢失了，如果没有redo日志将无法恢复</p>
<p>解决的思路就是将每一次操作记录下来，存放到一个文件中，下次恢复的时候根据文件中的操作重新操作一遍，并刷新到磁盘中</p>
<p>InnoDB引擎的事务采用了WAL技术，这种技术的思想就是先写日志，再写磁盘；只有当日志写入成功，才算事务提交成功。当发生宕机且数据未刷新到磁盘的时候，可以通过 redo log 来恢复</p>
<p><strong>redo的整体流程</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220522175215444.png" alt="image-20220522175215444"></p>
<ul>
<li>先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</li>
<li>生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</li>
<li>当事务commitl时，将redo log buffer中的内容刷新到 redo log file，对redo log file采用追加</li>
<li>写的方式定期将内存中修改的数据刷新到磁盘中</li>
</ul>
<blockquote>
<p>redo log 的写入并不是直接写入磁盘的，InnoDB引擎会在写 redo log 的时候先写 redo log buffer ，之后以一定的频率刷入到真正的redo log file 中。</p>
<p>但是 redo log buffer 刷盘到 redo log file 的过程并不是真正的刷到磁盘中，只是刷入到文件系统缓存中，真正的写入会交给系统自己来决定；所以存在问题，如果交给系统来同步，如果系统宕机，那么数据也会丢失</p>
<p>针对这种情况，InnoDB可以<strong>通过修改innodb_flush_log_at_trx_commit参数来控制刷盘的策略</strong></p>
<ul>
<li>0：表示每次事务提交时不进行刷盘，每隔1秒进行刷盘</li>
<li>1：表示每次事务都将进行刷盘（默认）</li>
<li>2：表示每提交只是把内容写入文件系统缓存中，由系统决定什么时候同步到磁盘文件</li>
</ul>
</blockquote>
<hr>
<h4 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h4><p>redo log 是事务持久性的保证，undo log是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个 undo log</p>
<p>事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如</p>
<ul>
<li>事务执行过程中可能会遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误</li>
<li>程序员手动进行回滚结束当前事务的执行</li>
</ul>
<p>以上情况发生后，我们需要把数据改回原先的样子，这个过程称之为回滚，这样就可以保证原子性</p>
<p><strong>undo日志的作用</strong></p>
<ul>
<li><strong>回滚数据：</strong>undo是逻辑日志，因此只是将数据库逻辑恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同</li>
<li><strong>MVCC：</strong>undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来实现。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此来实现非锁定读取</li>
</ul>
<p><strong>undo的存储结构</strong></p>
<p>InnoDB对undo log的管理采用段的方式，也就是回滚段（rollback segment），每个回滚段记录了1024个undo log segment，而在每个undo log segment段中进行undo页的申请。</p>
<hr>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等)，我们就需要保证这个数据在任何时刻最多只有一个线程在访问，保证数据的完整性和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p>
<p><strong>Mysql并发事务访问同一条记录可能产生的问题</strong></p>
<ul>
<li><p><strong>写-写问题：</strong>这种情况下会发生脏写问题，所以在多个未提交事务相继对一条记录做改动时，需要让它们<strong>排队执行</strong>，这个排队过程其实是通过锁来实现的</p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1要对这条记录做改动，就需要生成一个如下锁结构与之关联</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220523143036905.png" alt="image-20220523143036905"></p>
<p>当事务T1改动了这条记录后，就生成了一个锁结构与该记录关联，因为之前没有别的事务为这条记录加锁，所以is_waiting属性就是false，<strong>我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了</strong></p>
<p>在事务T1提交之前，另一个事务T2也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting属性值为true，表示当前事务需要等待，<strong>我们把这个场景就称之为获取锁失败，或者加锁失败</strong></p>
</li>
<li><p><strong>读-写问题：</strong>这种情况下可能会发生脏读、不可重复读、幻读；解决读-写问题有两种方案</p>
<ul>
<li><p><strong>读使用MVCC，写使用加锁</strong></p>
<p>所谓MVCC就是生成一个ReadView，通过ReadView找到合适的记录版本（历史版本有undo日志构建）。<strong>查询语句只能读到在生成ReadView之前已提交事务所做的更改</strong>。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突</p>
</li>
</ul>
<blockquote>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p>
<ul>
<li>在READ COMMITTED隔离级别下，<strong>一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象</strong></li>
<li>在REPEATABLE READ隔离级别下，<strong>一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题</strong></li>
</ul>
</blockquote>
<ul>
<li><p><strong>读写都加锁</strong></p>
<p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，这就要对读写操作都加锁</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="以数据操作类型划分"><a href="#以数据操作类型划分" class="headerlink" title="以数据操作类型划分"></a>以数据操作类型划分</h3><p>对于上述读-写的问题，Mysql需要使用MVCC或加锁的方式来解决。在使用加锁方式解决问题时，由于既要允许读-读情况不受影响，又要写-写、读-写相互阻塞，所以Mysql实现一个由两种类型的锁组成的锁系统来解决，<strong>两种锁被称为读锁、写锁，也称为共享锁和排他锁</strong></p>
<h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>读锁：针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互也是不阻塞的</p>
<h4 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h4><p>写锁：当前写操作没有完成前，它会阻断其他写锁和读锁，这样就能确保在给定时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源</p>
<table>
<thead>
<tr>
<th></th>
<th>排他锁</th>
<th>共享锁</th>
</tr>
</thead>
<tbody><tr>
<td>排他锁</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>共享锁</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p><strong>锁定读</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#给查询增加共享锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> share </span><br><span class="line"></span><br><span class="line">#给查询增加排他锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里需要注意的是 <code>for update</code> 是对于扫描到的数据都加锁，所以在使用条件查询时，需要保证当作条件的字段是有索引的，否则没有索引变成全文检索的话会对扫描到的数据都加上锁</p>
</blockquote>
<hr>
<h3 id="以数据操作的粒度划分"><a href="#以数据操作的粒度划分" class="headerlink" title="以数据操作的粒度划分"></a>以数据操作的粒度划分</h3><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但管理多是很消耗资源的事情。因此数据库系统需要在高并发响应和系统性能两方面进行平衡</p>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>该锁会锁定整张表，它是MysQL中最基本的锁策略，并不依赖于存储引擎（不管你是Myql的什么存储引擎，对于表锁的策略都是一样的)，并且表锁是开销最小的策略（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。</p>
<ul>
<li>表级共享锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#添加表级读锁</span><br><span class="line">lock tables 表名 read</span><br><span class="line"></span><br><span class="line">#解锁</span><br><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<ul>
<li>表级排他锁</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#添加表级读锁</span><br><span class="line">lock tables 表名 write</span><br><span class="line"></span><br><span class="line">#解锁</span><br><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220523205002532.png" alt="image-20220523205002532"></p>
<p><strong>总结：MyISAM在执行查询语句(SELECT)前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的读锁或者写锁的</strong></p>
<blockquote>
<p>意向锁是一种隐式的表级锁，不需要手动添加，行锁可以通过意向锁协调与表级锁并存</p>
<p>添加意向锁的意义在于，添加之后如果还有其他十五要添加表级锁的话只需要找到这个表是否被添加意向锁了之后就能判断能不能添加表级锁，如果没有意向锁，就需要一条条数据判断是否添加过行级排他锁，这样可以提升性能</p>
<img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220524104354299.png" alt="image-20220524104354299">

<p>这里的共享锁 &#x2F; 排他锁指的都是表级别的锁，意向锁不与行级锁互斥</p>
</blockquote>
<hr>
<h4 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h4><p>页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页级锁的开销介于表锁和行锁之间。</p>
<hr>
<h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p>行锁也称为记录锁。需要注意的是，Mysql服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现</strong>；行级锁也分成行级读锁、行级写锁</p>
<p><strong>优点：</strong>锁定粒度小，发生锁冲突概率低，可以实现的并发度高</p>
<p><strong>缺点：</strong>对于锁的开销比较大，加锁比较慢，容易出现死锁情况</p>
<blockquote>
<p><strong>行级共享锁 &#x2F; 排他锁使用情景：</strong></p>
<p>1、查询某一条数据且这条数据被另一个事务加了排他锁（更新会自动加上排他锁）:</p>
<ul>
<li>select加锁：等待正在更新的事务执行完毕，查询到的是最新的值</li>
<li>select不加锁：查询的是最近一次提交后数据的值，也就是历史值，这跟隔离级别有关，因为Mysql默认隔离级别为可重复读，所以查询出来的是最近一次提交后数据的值</li>
</ul>
<p>2、一个事务更新一条数据，另一个事务也更新则后来的等待</p>
</blockquote>
<hr>
<h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><p>在可重复读的隔离级别下也是能解决幻读问题的，其中加锁的解决方案存在一个问题，就是事务在第一次执行读取操作时，那些幻影记录并不存在，我们无法给这些幻影记录加上记录锁。</p>
<p>InnoDB提出了一种间隙锁，简称gap锁；若给某一条数据加上了间隙锁，则意味着不允许别的事务在这条数据前面的间隙插入新记录，比如（1、2、3、6），如果给6加了间隙锁，那么不允许别的事务在（3，6）之间插入数据</p>
<p>间隙锁示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#事务一</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>（由于数据不存在则添加间隙锁）</span><br><span class="line">#事务二</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;jjw&#x27;</span>) #插入不成功</span><br><span class="line"></span><br><span class="line">#gap锁的提出仅仅是为了防止插入幻影记录而提出的。虽然有共享gap锁和排他gap锁这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁)，并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</span><br></pre></td></tr></table></figure>



<p>由于幻读的定义是：幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。</p>
<p>所以当有一个业务是想要插入一条数据，先查询并加间隙锁，然后再插入。这期间由于加了间隙锁，所以其他事务不能在这个间隙进行插入，这样就解决了幻读问题</p>
<hr>
<h5 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h5><p>有时候我们既想锁住某条记录，又想阻止其他事物在该记录前面的间隙插入新记录，所以InnoDB就提出了一种临键锁。临键锁是在事务级别为可重复读的情况下使用的数据库锁，InnoDB默认的锁就是临键锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">10</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>（对[<span class="number">8</span>，<span class="number">10</span>]之间为间隙锁，<span class="number">10</span>为行锁）</span><br></pre></td></tr></table></figure>



<blockquote>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
</blockquote>
<hr>
<h3 id="以对待锁的态度划分"><a href="#以对待锁的态度划分" class="headerlink" title="以对待锁的态度划分"></a>以对待锁的态度划分</h3><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待数据并发的思维方式。<strong>需要注意的是，乐观锁和悲观锁并不是锁，而是锁的设计思想</strong></p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p><strong>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁</strong>（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程)。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 synchronized和ReentrantLock 等独占锁就是悲观锁思想的实现。例如 <code>select .... for update</code> 就是悲观锁的思想。</p>
<p>悲观锁不适用的场景较多，它存在一些不足，因为悲观锁大多数情况下依靠数据库的锁机制来实现，以保证程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是长事务而言，这样的开销往往无法承受，这时就需要乐观锁。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过程序来实现。<strong>在程序上，我们可以采用版本号机制或者CAS机制实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</strong></p>
<hr>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p><strong>什么是MVCC</strong></p>
<p>MVCC，多版本并发控制，MVCC就是通过数据行的多个版本管理来实现数据库的并发控制。这项技术使得在InnoDB的事务隔离级别下执行一致性读操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p>
<h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>快照读读取都是快照数据据，<strong>不加锁的简单的select都属于快照读</strong></p>
<p>之所以出现快照读的情况是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。快照读读取到的并不一定是数据的最新版本，可能是之前的历史版本</p>
<h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>当前读读取的是记录的最新版本，读取时候还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的select，或者对数据进行增删改都会进行当前读</p>
<h3 id="隐藏字段、undo-log版本链"><a href="#隐藏字段、undo-log版本链" class="headerlink" title="隐藏字段、undo log版本链"></a>隐藏字段、undo log版本链</h3><p>对于InnoDB存储引擎来说，它的聚簇索引记录中都包含两个必要的隐藏列</p>
<ul>
<li><strong>trx_id：</strong>每次一个事务对某条聚簇索引记录进行改动是，都会把该事务的事务id赋值给trx_id隐藏列</li>
<li><strong>roll_pointer：</strong>每次对某条聚簇索引记录进行改动是，都会把旧版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息</li>
</ul>
<p>通过 <code>roll_pointer</code>串成一个版本链</p>
<p><img src="https://jjw-beiqi.github.io/2022/05/04/Mysql/image-20220525140515429.png" alt="image-20220525140515429"></p>
<hr>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p><strong>什么是ReadView</strong></p>
<p>在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</p>
<p>ReadView就是某一个事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前活跃事务的ID(“活跃”指的就是，启动了但还没提交)。</p>
<p>ReadView中包含4个比较重要的内容：</p>
<ul>
<li><code>creator_trx_id</code>：创建这个ReadView的事务ID</li>
<li><code>trx_ids</code>：生成ReadView时当前系统中活跃的读写事务的事务id列表</li>
<li><code>up_limit_id</code>：活跃事务中最小的事务ID</li>
<li><code>low_limit_id</code>：表示生成ReadView时系统中应该分配给下一个事务的id值。<code>low_limit_id</code>是系统最大的事务id值，这里要注意的是系统中的事务id，需要区别于正在活跃的事务ID</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">贝奇野菜汁</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jjw-beiqi.github.io/2022/05/04/Mysql/">https://jjw-beiqi.github.io/2022/05/04/Mysql/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jjw-beiqi.github.io" target="_blank">BeiQi.</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Mysql/">Mysql</a></div><div class="post_share"><div class="social-share" data-image="/img/cover21.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/04/21/JUC/"><img class="next-cover" src="/img/cover17.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">贝奇野菜汁</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jjw-beiqi" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">评论系统已开放 ( '▽′)Ψ</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql"><span class="toc-number">1.</span> <span class="toc-text">Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">SQL的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.</span> <span class="toc-text">多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.1.</span> <span class="toc-text">自连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JOIN%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">JOIN语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">内连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">外连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.3.</span> <span class="toc-text">自然连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">单行函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">聚合函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#group-by"><span class="toc-number">1.4.1.</span> <span class="toc-text">group by</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#having"><span class="toc-number">1.4.2.</span> <span class="toc-text">having</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.6.</span> <span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">不相关子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">相关子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EXISTS-x2F-NOT-EXISTS"><span class="toc-number">1.6.0.2.1.</span> <span class="toc-text">EXISTS &#x2F; NOT EXISTS</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DDL"><span class="toc-number">1.7.</span> <span class="toc-text">DDL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">创建和管理表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.7.2.</span> <span class="toc-text">修改数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DML"><span class="toc-number">1.8.</span> <span class="toc-text">DML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.1.</span> <span class="toc-text">查询数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.2.</span> <span class="toc-text">插入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.3.</span> <span class="toc-text">修改数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.4.</span> <span class="toc-text">删除数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.</span> <span class="toc-text">Mysql数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.1.</span> <span class="toc-text">浮点类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.2.</span> <span class="toc-text">定点数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.3.</span> <span class="toc-text">位类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.4.</span> <span class="toc-text">日期类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.5.</span> <span class="toc-text">文本字符串类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.6.</span> <span class="toc-text">二进制类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.10.</span> <span class="toc-text">约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">1.11.</span> <span class="toc-text">视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.12.</span> <span class="toc-text">存储过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.13.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-number">1.13.1.</span> <span class="toc-text">系统变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="toc-number">1.13.2.</span> <span class="toc-text">用户变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.14.</span> <span class="toc-text">触发器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-number">1.15.</span> <span class="toc-text">逻辑架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.15.1.</span> <span class="toc-text">SQL执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.16.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.16.1.</span> <span class="toc-text">InnoDB存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.16.2.</span> <span class="toc-text">InnoDB数据存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.16.2.1.</span> <span class="toc-text">页结构概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.16.2.2.</span> <span class="toc-text">页的上层结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.16.2.3.</span> <span class="toc-text">页的内部结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.17.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94"><span class="toc-number">1.17.1.</span> <span class="toc-text">索引的推演</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.17.2.</span> <span class="toc-text">常见的索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.17.2.1.</span> <span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.17.2.2.</span> <span class="toc-text">非聚簇索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.17.2.3.</span> <span class="toc-text">联合索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%9A%84B-%E6%A0%91%E7%B4%A2%E5%BC%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.17.3.</span> <span class="toc-text">InnoDB的B+树索引注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95-%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF"><span class="toc-number">1.17.4.</span> <span class="toc-text">MyISAM中的索引(了解即可)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8B%E6%A0%91%E5%91%A2"><span class="toc-number">1.17.5.</span> <span class="toc-text">为什么使用B+树而不使用B树呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.17.6.</span> <span class="toc-text">索引的创建与设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.17.6.1.</span> <span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.17.6.2.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">1.17.6.3.</span> <span class="toc-text">删除索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.17.7.</span> <span class="toc-text">索引的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.17.7.1.</span> <span class="toc-text">适合索引的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.17.7.2.</span> <span class="toc-text">不适合索引的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.17.7.3.</span> <span class="toc-text">限制索引的数目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.17.8.</span> <span class="toc-text">索引优化与查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="toc-number">1.17.8.1.</span> <span class="toc-text">索引失效情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%86%85%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.17.8.2.</span> <span class="toc-text">外连接与内连接的查询优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.17.8.3.</span> <span class="toc-text">子查询优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">1.17.8.4.</span> <span class="toc-text">排序优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GROUP-BY%E4%BC%98%E5%8C%96"><span class="toc-number">1.17.8.5.</span> <span class="toc-text">GROUP BY优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.17.8.6.</span> <span class="toc-text">分页查询优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.18.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.18.1.</span> <span class="toc-text">事务基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.18.1.1.</span> <span class="toc-text">显式事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.18.1.2.</span> <span class="toc-text">隐式事务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.19.</span> <span class="toc-text">事务的隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.19.1.</span> <span class="toc-text">数据并发问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%8F%E5%86%99"><span class="toc-number">1.19.1.1.</span> <span class="toc-text">脏写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB"><span class="toc-number">1.19.1.2.</span> <span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%BA%A6"><span class="toc-number">1.19.1.3.</span> <span class="toc-text">不可重复度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB"><span class="toc-number">1.19.1.4.</span> <span class="toc-text">幻读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.19.2.</span> <span class="toc-text">SQL中的四种隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-number">1.19.3.</span> <span class="toc-text">Mysql事务日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo%E6%97%A5%E5%BF%97"><span class="toc-number">1.19.3.1.</span> <span class="toc-text">redo日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo%E6%97%A5%E5%BF%97"><span class="toc-number">1.19.3.2.</span> <span class="toc-text">undo日志</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.20.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86"><span class="toc-number">1.20.1.</span> <span class="toc-text">以数据操作类型划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">1.20.1.1.</span> <span class="toc-text">共享锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-number">1.20.1.2.</span> <span class="toc-text">排他锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%92%E5%88%86"><span class="toc-number">1.20.2.</span> <span class="toc-text">以数据操作的粒度划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">1.20.2.1.</span> <span class="toc-text">表级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%BA%A7%E9%94%81"><span class="toc-number">1.20.2.2.</span> <span class="toc-text">页级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">1.20.2.3.</span> <span class="toc-text">行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-number">1.20.2.3.1.</span> <span class="toc-text">间隙锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81"><span class="toc-number">1.20.2.3.2.</span> <span class="toc-text">临键锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%AF%B9%E5%BE%85%E9%94%81%E7%9A%84%E6%80%81%E5%BA%A6%E5%88%92%E5%88%86"><span class="toc-number">1.20.3.</span> <span class="toc-text">以对待锁的态度划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.20.3.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.20.3.2.</span> <span class="toc-text">乐观锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC"><span class="toc-number">1.21.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-number">1.21.1.</span> <span class="toc-text">快照读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">1.21.2.</span> <span class="toc-text">当前读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5%E3%80%81undo-log%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-number">1.21.3.</span> <span class="toc-text">隐藏字段、undo log版本链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadView"><span class="toc-number">1.21.4.</span> <span class="toc-text">ReadView</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/04/Mysql/" title="Mysql"><img src="/img/cover21.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql"/></a><div class="content"><a class="title" href="/2022/05/04/Mysql/" title="Mysql">Mysql</a><time datetime="2022-05-04T07:12:02.000Z" title="发表于 2022-05-04 15:12:02">2022-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/21/JUC/" title="JUC"><img src="/img/cover17.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC"/></a><div class="content"><a class="title" href="/2022/04/21/JUC/" title="JUC">JUC</a><time datetime="2022-04-21T12:17:38.000Z" title="发表于 2022-04-21 20:17:38">2022-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/10/Nginx/" title="nginx"><img src="/img/cover16.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nginx"/></a><div class="content"><a class="title" href="/2022/04/10/Nginx/" title="nginx">nginx</a><time datetime="2022-04-10T12:10:27.000Z" title="发表于 2022-04-10 20:10:27">2022-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/09/JavaScript/" title="JavaScript"><img src="/img/cover17.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript"/></a><div class="content"><a class="title" href="/2022/04/09/JavaScript/" title="JavaScript">JavaScript</a><time datetime="2022-04-09T03:03:27.000Z" title="发表于 2022-04-09 11:03:27">2022-04-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/31/JVM/" title="JVM概述"><img src="/img/cover20.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM概述"/></a><div class="content"><a class="title" href="/2022/03/31/JVM/" title="JVM概述">JVM概述</a><time datetime="2022-03-31T06:10:32.000Z" title="发表于 2022-03-31 14:10:32">2022-03-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/cover21.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 贝奇野菜汁</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'rOsN3OEnrRLe07w7YSm6vsF0-gzGzoHsz',
      appKey: 'FnGMcugtJLWckH5PYXIHNB0D',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>