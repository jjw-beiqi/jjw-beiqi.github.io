<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode</title>
    <url>/2022/03/19/LeetCode/</url>
    <content><![CDATA[<h2 id="easy-70：爬楼梯"><a href="#easy-70：爬楼梯" class="headerlink" title="easy     |     70：爬楼梯"></a>easy     |     70：爬楼梯</h2><p><strong>题目：假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</strong></p>
<p><strong>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</strong></p>
<p>思路：本题是典型的斐波那契数列题目，使用动态规划解决，这层阶梯的爬法是前两层阶梯爬法之和</p>
<p>斐波那契数列：<em>F</em>(<em>x</em>)&#x3D;<em>F</em>(<em>x</em>−1)+<em>F</em>(<em>x</em>−2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC学习笔记</title>
    <url>/2022/03/20/SpringMVC/</url>
    <content><![CDATA[<h1 id="SpringMvc"><a href="#SpringMvc" class="headerlink" title="SpringMvc"></a>SpringMvc</h1><p>SpringMvc是Spring的一个后续产品，是Spring的一个子项目</p>
<p>SpringMvc是Spring为表述层开发提供的一整套完备的解决方案</p>
<h2 id="创建SpringMvc项目"><a href="#创建SpringMvc项目" class="headerlink" title="创建SpringMvc项目"></a>创建SpringMvc项目</h2><ol>
<li><p>创建maven下的web项目</p>
<p>参考：<a href="https://blog.csdn.net/weixin_42222334/article/details/80362126">https://blog.csdn.net/weixin_42222334/article/details/80362126</a></p>
</li>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置web.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置SpringMvc的前端控制器，对浏览器发送的请求进行统一处理 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置SpringMvc配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将前端控制器DispatherServlet的初始化时间提前到服务器启动时 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      设置springmvc的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">      /所匹配的请求可以是/login或.js...</span></span><br><span class="line"><span class="comment">      但不能匹配.jsp的请求</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<br>


<hr>
<br>

<h2 id="配置springMVC-xml"><a href="#配置springMVC-xml" class="headerlink" title="配置springMVC.xml"></a>配置springMVC.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器，也可以选择其他的视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 视图解析器优先级 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>扩展：过滤器、拦截器、aop 顺序</strong></p>
<p>由于SpringMVC的前端控制器是DispatherServlet所以有必要了解一下过滤器、拦截器、aop 的执行顺序</p>
<p>filter—&gt;Interceptor—-&gt;@Aspect –&gt;Interceptor</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/20151219102326359.png" alt="img"></p>
<br>

<hr>
<br>

<h2 id="SpringMVC的请求"><a href="#SpringMVC的请求" class="headerlink" title="SpringMVC的请求"></a>SpringMVC的请求</h2><br>

<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系</p>
<ul>
<li>标识一个类：设置请求的请求路径的初始信息</li>
<li>标识一个方法：设置映射请求请求路径的具体信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="meta">@RequestMapping(value=&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">controller</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//返回视图名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//http://localhost:8080/springmvc/test/index</span></span><br></pre></td></tr></table></figure>

<p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMvc的核心配置文件，通过扫描组件会找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，通过Thymeleaf（也可以使用其他的视图解析器）对视图进行渲染，最终转发到视图所对应页面</p>
<br>

<p><strong>@RequestMapping中的value属性</strong></p>
<p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p>
<p>@RequestMapping注解的value属性必须设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&#123;&quot;index&quot;,&quot;test&quot;&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//返回视图名称</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>@RequestMapping中的method属性</strong></p>
<p>@RequestMapping中的method属性通过请求的请求方式（get&#x2F;post匹配请求映射）</p>
<p>@RequestMapping中的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;,method=RequestMethod.GET)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//返回视图名称</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>@RequestMapping的派生注解</strong></p>
<ul>
<li><p>@GetMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等同于@RequestMapping(method=RequestMethod.GET)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@PostMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等同于@RequestMapping(method=RequestMethod.POST)</span></span><br></pre></td></tr></table></figure>

<p>…</p>
</li>
</ul>
<br>

<p><strong>@RequestMapping中的params属性</strong></p>
<p>@RequestMapping中的params属性通过请求的请求参数匹配请求映射</p>
<p>@RequestMapping中的params属性是一个字符串的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;param&quot;:要求请求映射所匹配的请求必须携带param请求参数</span><br><span class="line">&quot;param&quot;:要求请求映射所匹配的请求必须不能携带param请求参数</span><br><span class="line">&quot;param=value&quot;:要求请求映射所匹配的请求必须携带param请求参数且param=value&quot;</span><br><span class="line">param!=value&quot;:要求请求映射所匹配的请求必须携带param请求参数但是param!=value</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;,param=&#123;&quot;usename&quot;,&quot;!abc&quot;&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//返回视图名称</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>SpringMVC支持ant风格的路径</strong></p>
<p>？：表示任意的单个字符</p>
<p>*：表示任意的0个或多个字符</p>
<p>**：表示任意的一层或多层目录</p>
<br>

<hr>
<br>

<h3 id="SpringMVC获取请求参数"><a href="#SpringMVC获取请求参数" class="headerlink" title="SpringMVC获取请求参数"></a>SpringMVC获取请求参数</h3><p>可以使用servletAPI获取参数，但基本不使用</p>
<p>当发送的参数名与@RequestMapping标识方法中参数名一致时，会自动匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>当有多个请求参数名一样时，如： …?hobby&#x3D;a&amp;hobby&#x3D;b</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以这么写</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(String hobby)</span>&#123; <span class="comment">//hobby=&quot;a,b&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(String[] hobby)</span>&#123; <span class="comment">//hobby=[a,b]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>@RequestParam()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当请求参数名和方法参数名不一致时，使用@RequestParam()</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;user_name&quot;)</span> String username, </span></span><br><span class="line"><span class="params">    String password)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestParam()</span>将请求参数和方法参数映射起来，属性：</span><br><span class="line">    required 是否必须带有这个请求参数</span><br><span class="line">    defaultValue 不管required属性值为<span class="literal">true</span>或<span class="literal">false</span>，当value所指定的请求参数没有传输或传输的值为“”时，则使用默认值</span><br></pre></td></tr></table></figure>

<br>

<p><strong>@RequestHeader</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(</span></span><br><span class="line"><span class="params">    String username, </span></span><br><span class="line"><span class="params">    String password,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Host&quot;)</span> String host)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestHeader()</span>会从请求头中取出对应的字段赋值给参数，属性：</span><br><span class="line">    required 是否必须带有这个请求参数</span><br><span class="line">    defaultValue 不管required属性值为<span class="literal">true</span>或<span class="literal">false</span>，当value所指定的请求参数没有传输或传输的值为“”时，则使用默认值</span><br></pre></td></tr></table></figure>

<br>

<p><strong>@CookieValue</strong></p>
<p>与前面的使用方法一样</p>
<br>

<p><strong>通过POJO获取请求参数</strong></p>
<p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="keyword">public</span> String password;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(User user)</span>&#123; </span><br><span class="line">    System.out.println(user.getUsername() + user.getPassword);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>解决中文乱码问题</strong></p>
<p>在web.xml文件中添加字符编码过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字符编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置请求编码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置响应编码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置字符编码过滤器的过滤路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>



<hr>
<br>

<h3 id="域对象共享数据"><a href="#域对象共享数据" class="headerlink" title="域对象共享数据"></a>域对象共享数据</h3><p><strong>使用servletAPI向request域对象共享数据</strong></p>
<p>可以使用servletAPI向域对象中存放数据，但基本不使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;testString&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>使用ModelAndView向request域对象共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * ModelAndView有Model和View的功能</span></span><br><span class="line"><span class="comment">        * Model主要用于向请求域中共享数据</span></span><br><span class="line"><span class="comment">        * View主要用于设置视图，实现页面跳转</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">//向请求域中共享数据</span></span><br><span class="line">    mv.addObject(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图，实现页面跳转</span></span><br><span class="line">    mv.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>使用Model向request域对象共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(Model m)</span>&#123;</span><br><span class="line">    m.addAttribute(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>使用Map向request域对象共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(Map&lt;String,Object&gt; map)</span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>使用ModelMap向request域对象共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(ModelMap mm)</span>&#123;</span><br><span class="line">    mm.addAttribute(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>向session域中共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>向application域共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="SpringMVC的视图"><a href="#SpringMVC的视图" class="headerlink" title="SpringMVC的视图"></a>SpringMVC的视图</h2><br>

<h3 id="自定义视图解析器"><a href="#自定义视图解析器" class="headerlink" title="自定义视图解析器"></a>自定义视图解析器</h3><p>当控制器方法中设置的视图名没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p>
<br>

<h3 id="转发视图"><a href="#转发视图" class="headerlink" title="转发视图"></a>转发视图</h3><p>SpringMVC中默认的转发视图是InternalResourceView</p>
<p>创建转发视图的情况：</p>
<p>当控制器方法中所设置的视图名称以 “forward:” 为前缀时，<strong>创建InternalResourceView视图</strong>，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀 “forward:” 去掉，剩余部分作为最终路径通过转发的方式实现跳转<strong>（只能跳转@RequestMapping映射过的视图）</strong></p>
<p>例如 “forward:&#x2F;“，”forward:&#x2F;employee”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="重定向视图"><a href="#重定向视图" class="headerlink" title="重定向视图"></a>重定向视图</h3><p>SpringMVC中默认的重定向视图是RedirectView</p>
<p>当控制器方法中所设置的视图名称以 “redirect:” 为前缀时，<strong>创建RedirectView视图</strong>，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀 “redirect:” 去掉，剩余部分作为最终路径通过重定向的方式实现跳转<strong>（只能跳转@RequestMapping映射过的视图）</strong></p>
<p>例如 “redirect:&#x2F;“，”redirect:&#x2F;employee”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="视图控制器-view-controller"><a href="#视图控制器-view-controller" class="headerlink" title="视图控制器 view-controller"></a>视图控制器 view-controller</h3><p><em>当控制器方法中，<strong>仅仅用来实现页面跳转（即不做任何其他的操作，只是页面跳转）</strong>，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</em></p>
<blockquote>
<p>使用场景：</p>
<p>spring文档里建议并将其做为最佳实践将所有的jsp页面放到WEB-INF下，不让直接访问，那么我们只能通过controller来访问jsp页面了，但是我们总不能为每个页面都写一个controller吧，那样太麻烦了，所以mvc:view-controller就是处理这个场景的一个shortcut（快捷方式）。</p>
</blockquote>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/image-20220313105546745-16471406629442.png" alt="image-20220313105546745"></p>
<br>

<p>配置view-controller后所有映射都会失效</p>
<p>原因：<strong>如果没有mvc:annotation-driven，那么所有的@Controller注解可能就没有解析</strong>，所有当有请求时候都没有匹配的处理请求类，就都去<strong>mvc:default-servlet-handler</strong>即default servlet处理了。</p>
<br>

<blockquote>
<p><a href="https://blog.csdn.net/qq_41984887/article/details/105045936">&lt;mvc:annotation-driven &#x2F;&gt;的作用</a></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/image-20220313105823765-16471406609571.png" alt="image-20220313105823765"></p>
</blockquote>
<br>

<h3 id="InternalResourceViewResolver控制器"><a href="#InternalResourceViewResolver控制器" class="headerlink" title="InternalResourceViewResolver控制器"></a>InternalResourceViewResolver控制器</h3><p>springMCV.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="RESTFul简介"><a href="#RESTFul简介" class="headerlink" title="RESTFul简介"></a>RESTFul简介</h2><blockquote>
<p> REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移。 它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。 他在论文中提到：”我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST指的是一组架构约束条件和原则。” 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。</p>
<p> REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。</p>
</blockquote>
<p>参考：<a href="https://www.runoob.com/w3cnote/restful-architecture.html">菜鸟教程</a></p>
<br>

<h3 id="RESTFul的实现"><a href="#RESTFul的实现" class="headerlink" title="RESTFul的实现"></a>RESTFul的实现</h3><p>具体来说就是HTTP协议里的四个表示操作方式的动词：GET、POST、PUT、DELETE</p>
<ul>
<li>GET：用于获取资源</li>
<li>POST：用于新建资源</li>
<li>PUT：用于更新资源</li>
<li>DELETE：用于删除资源</li>
</ul>
<br>

<p>REST风格提倡URL地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为URL地址的一部分，以保证整体风格的一致性</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统方式</th>
<th>REST风格</th>
</tr>
</thead>
<tbody><tr>
<td>查询</td>
<td>getUserById?id&#x3D;1</td>
<td>user&#x2F;1——&gt;GET</td>
</tr>
<tr>
<td>保存</td>
<td>saveUser</td>
<td>user——&gt;POST</td>
</tr>
<tr>
<td>删除</td>
<td>deleteUser?id&#x3D;1</td>
<td>user&#x2F;1——&gt;DELETE</td>
</tr>
<tr>
<td>更新</td>
<td>updateUser</td>
<td>user——&gt;PUT</td>
</tr>
</tbody></table>
<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/user/&#123;id&#125;&quot;, method=RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/user&quot;, method=RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveUser</span><span class="params">(String username,String password)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/user/&#123;id&#125;&quot;, method=RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/user&quot;, method=RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateUser</span><span class="params">(String username,String password)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="PUT、DELETE请求方式存在浏览器兼容问题"><a href="#PUT、DELETE请求方式存在浏览器兼容问题" class="headerlink" title="PUT、DELETE请求方式存在浏览器兼容问题"></a>PUT、DELETE请求方式存在浏览器兼容问题</h3><blockquote>
<p>浏览器确实支持PUT和DELETE，但是HTML不支持。</p>
<p>这是因为HTML 4.01和最终的W3C HTML 5.0规范都说它们的form元素应允许的唯一HTTP方法是GET和POST。</p>
<p>在HTML 5的开发过程中对此进行了很多讨论，有一次他们将它们添加到HTML 5中，然后再次删除。之所以从HTML5规范中删除其他方法，是因为HTML 4级浏览器永远无法支持它们(在制作时不属于HTML)。</p>
</blockquote>
<br>

<p>解决：在web.xml文件中配置HiddenHttpMethodFilter过滤器</p>
<p><em><strong>注：同时编码过滤器必须放在HiddenHttpMethodFilter过滤器之前</strong></em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置HiddenHttpMethodFilter过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<ul>
<li><p>PUT请求表单提交代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显式请求方式为post请求方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/user&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加一个隐藏域用于更改请求方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更改&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p>由于DELETE请求通常使用超链接、按钮形式，所以使用js代码将超链接、按钮与隐藏域绑定</p>
<p>更改DELETE请求参考：<a href="https://blog.csdn.net/zzz841318172/article/details/109614543">如何将超链接GET请求变成DELETE请求</a></p>
</li>
</ul>
<br>

<br>

<p>扩展问题：DispatcherServlet是访问不到静态资源的，当DispatcherServlet访问不到时，应该让Tomcat配置的DefaultServlet去访问静态资源，因此需要配置<strong>mvc:default-servlet-handler</strong>标签，由于配置<strong>mvc:default-servlet-handler</strong>标签后也会导致映射路径失效，所以也需要配置<strong>mvc:annotation-driven</strong>标签</p>
<blockquote>
<p>如果配置了DispatcherServlet，那么所有的请求都会被拦截,包括静态资源。</p>
<ul>
<li>‘&#x2F;‘ 将会替换掉容器的default servlet, 将会处理所有其他handler(Servlet)都不处理的访问请求.</li>
<li>如果web.xml没有配置其他特殊路径的servlet, 基本上所有的请求都交由DispatcherServlet处理.</li>
<li>将不会再访问容器中原始默认的servlet(你对静态资源的访问就是通过容器默认servlet处理的)，故而静态资源将不可访问！</li>
</ul>
</blockquote>
<br>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开放静态资源访问 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><font color="orange"><strong>刨根问底一下 为什么加入两个注解就没有问题了呢？</strong></font></p>
<blockquote>
<p>首先是两个注解都不加，此时HandlerMappings中的<strong>AnnotationHandlerMapping</strong>中<strong>存储这Controller和url的映射关系</strong>，由于我们<strong>没有编写Controller去处理js html等静态资源</strong>，所以此时的状态是动态资源可以访问，静态资源不可访问。</p>
<img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/1263112-20190406160521291-2027530586.png" alt="img" style="zoom:50%;">

<p>其次是<strong>只加上default-servlet-handler，发现处理Controller的AnnotationHandler不见了</strong>，取而代之的是SimpleURLHandlerMapping，该Handler种的handlerMap非常简单只有一个&#x2F;** <strong>即无论什么请求都直接去当前webapp下去找。这样配置静态资源肯定是可以访问的</strong>，因为它的作用和不使用SpringMVC中的DIsplacedServlet直接使用Tomcat一样。但由于AnnotationHandler的缺失，导致Controller这种基于注解配置处理请求的方法无法访问，所以这种配置下的状态是<strong>静态资源可以访问，动态资源不可以访问。</strong></p>
<img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/1263112-20190406160807464-126528350.png" alt="img" style="zoom:50%;">

<p><strong>最后当把两个注解都加上的时候，不仅有处理静态资源的SimpleUrlHandlerMapping，还多了一个优先级最高的RequestMapping</strong>，点开详情信息发现我们配置的Controller都在里面。这就是我们要的效果：</p>
<p><font color="red"><strong>对于每一个非jsp请求都会被DispatchServlet拦下，然后交给优先级最高的RequestMapping处理。RequestMapping遍历自己的Mappings，如果这个请求是一个动态请求，那么一定可以找到对应的Controller，Controller处理并返回；如果该请求是一个针对静态资源文件的，RequestMapping无能为力，他会按照优先级交给后续HandlerMapping如没啥用的BeanNameUrlHandlerMapping，以及放在最后用来兜底的SimpleUrlHandlerMapping，当SimpleUrlHandlerMapping拿到一个针对静态资源的请求后，会在&#x2F;**目录下找到静态资源并返回。</strong></font></p>
<img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/1263112-20190406161147379-857785000.png" alt="img" style="zoom: 67%;">



<p><a href="https://www.cnblogs.com/AshOfTime/p/10655014.html">转载自原创博主</a></p>
</blockquote>
<hr>
<br>

<h2 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h2>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记</title>
    <url>/2022/03/18/Spring/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="spring框架概述"><a href="#spring框架概述" class="headerlink" title="spring框架概述"></a>spring框架概述</h2><ul>
<li><p>spring是一个轻量级的开源框架</p>
</li>
<li><p>spring解决企业开发的复杂性</p>
</li>
<li><p>spring有两个核心部分<strong>IOC</strong>和<strong>Aop</strong></p>
<ul>
<li><p>IOC：控制反转，把创建对象的过程交给spring进行管理</p>
</li>
<li><p>Aop：面向切面编程，不修改源代码的情况下进行功能增强</p>
</li>
</ul>
<br></li>
</ul>
<p>spring下载地址<img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220130164829123.png" alt="image-20220130164829123"></p>
<p>spring基本5个jar包<img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220130165213984.png" alt="image-20220130165213984"></p>
<p><strong>使用步骤：</strong></p>
<ul>
<li>导入jar包</li>
<li>在src目录下创建spring使用的xml配置文件（spring config文件）</li>
<li>配置相关对象</li>
<li>启动程序</li>
</ul>
<br>

<h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><p><em>通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中</em></p>
<p>使用IOC的目的：为了降低耦合度</p>
<br>

<h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><p>xml解析、工厂模式、反射</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220130173046282.png" alt="image-20220130173046282"></p>
<br>

<hr>
<br>

<h3 id="IOC接口（BeanFactory）"><a href="#IOC接口（BeanFactory）" class="headerlink" title="IOC接口（BeanFactory）"></a>IOC接口（BeanFactory）</h3><p>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p>
<p>spring提供IOC容器实现的两种方式</p>
<ul>
<li><p>BeanFactory：IOC容器基本实现方式，是spring内部使用的接口，不建议使用</p>
<ul>
<li>BeanFactory是懒加载，一开始只读取配置文件，获取对象时才创建对象</li>
</ul>
</li>
<li><p>ApplicationContext：是BeanFactory的子接口，提供更多更强大的功能</p>
<ul>
<li><p>加载配置文件时就创建对象</p>
</li>
<li><p>有两个实现类<strong>FileSystemXmlApplicationContext</strong>（盘符路径）和<strong>ClassPathXmlApplicationContext</strong>（类路径）</p>
</li>
</ul>
</li>
</ul>
<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用配置好的对象</span></span><br><span class="line"><span class="comment">//1、加载spring配置文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;配置文件名.xml&quot;</span>)</span><br><span class="line"><span class="comment">//2、获取配置创建的对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;对象配置的id值&quot;</span>, User.class<span class="comment">/*要创建的类型*/</span>);</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h3 id="IOC操作Bean管理（基于xml）"><a href="#IOC操作Bean管理（基于xml）" class="headerlink" title="IOC操作Bean管理（基于xml）"></a>IOC操作Bean管理（基于xml）</h3><h4 id="Bean管理"><a href="#Bean管理" class="headerlink" title="Bean管理"></a>Bean管理</h4><p>Bean管理指的是两个操作</p>
<ul>
<li>spring创建对象</li>
<li>spring注入属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring创建对象--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用bean标签可以实现对象创建--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--创建对象的时候，默认执行无参构造方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在bean标签中有很多属性（常见）--&gt;</span></span><br><span class="line">id属性：给对象取一个别名（唯一标识）</span><br><span class="line">class属性：类全路径（包全路径）</span><br><span class="line">name属性：与id属性效果一致，但是name中可以添加特殊符号</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring注入属性</span></span><br><span class="line"><span class="comment">DI：依赖注入，就是注入属性，是IOC的具体实现方式--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--set注入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1、先创建类，定义属性和对应的set方法--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2、在spring配置文件中创建对象并注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--name属性就是类中属性名称 value就是要注入的值--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>&gt;</span><span class="tag">&lt;/<span class="name">null</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--属性可以是null值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--构造注入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1、先创建类，定义属性和有参构造方法--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2、在spring配置文件中创建对象并注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--name属性就是类中属性名称 value就是要注入的值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--p名称空间注入，可简化基于xml配置方式--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1、添加配置xmlns:p=&quot;http://www.springframework.org/schema/p&quot;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2、在spring配置文件中创建对象并注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.User&quot;</span> <span class="attr">p:userName</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>注入外部bean</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--注入外部bean使用ref属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.Address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">value</span>=<span class="string">&quot;heibeishifandaxue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>级联赋值</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--需要有这个属性的get方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;技术部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Dept&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;后勤部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注入集合属性</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数组类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>234<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>345<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--List类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>234<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>345<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入引用类型</span></span><br><span class="line"><span class="comment">            &lt;ref bean=&quot;&quot;&gt;&lt;/ref&gt;</span></span><br><span class="line"><span class="comment">            &lt;ref bean=&quot;&quot;&gt;&lt;/ref&gt;</span></span><br><span class="line"><span class="comment">            &lt;ref bean=&quot;&quot;&gt;&lt;/ref&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--Map类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--Set类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>234<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>345<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>提取集合类型</strong></p>
<p>1、添加util配置</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220131135613821.png" alt="image-20220131135613821"></p>
<p>2、提取集合，并注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>234<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>345<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;users&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;users&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<br>

<p>spring有两种类型bean，一种普通bean，另一种工厂bean（FactoryBean）</p>
<p>1、普通bean：在配置文件中定义bean类型就是返回类型</p>
<p>2、工厂bean：在配置文件定义bean类型可以和返回类型不一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义返回的bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserName(<span class="string">&quot;jjw&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否为单例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FactoryBean.<span class="built_in">super</span>.isSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mybean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.MyBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当使用getbean方法获得bean时，返回User--&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><p>作用域就是单实例、多实例、request、session</p>
<p>在spring里面，可以设置bean实例是单实例或者多实例</p>
<p><strong>在spring里面，默认情况是单实例</strong></p>
<br>

<p><strong>单例：</strong></p>
<p>当bean为单例模式时，加载spring配置文件时就会创建单例对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span> <span class="comment">&lt;!--单例--&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>多例：</strong></p>
<p>当bean为多例时，执行getBean方法时才创建对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span> <span class="comment">&lt;!--多例--&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>1、通过构造器创建bean实例（无参构造）</p>
<p>2、为bean的属性设置值和对其他bean的引用（调用set方法）</p>
<p>（可以添加后置处理器，添加后在第3步之前将bean实例传递给后置处理器的postProcessBeforeInitialization方法）</p>
<p>3、调用bean的初始化方法（需要自己配置）</p>
<p>（可以添加后置处理器，添加后在第3步之后将bean实例传递给后置处理器的postProcessAfterInitialization方法）</p>
<p>4、bean可以使用</p>
<p>5、当容器关闭时，调用bean的销毁方法（需要自己配置）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一步，执行无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOname</span><span class="params">(String oname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oname = oname;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二步，调用set方法设置属性值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三步，执行初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步，执行销毁方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.Orders&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="Bean自动装配"><a href="#Bean自动装配" class="headerlink" title="Bean自动装配"></a><em>Bean自动装配</em></h4><p>根据指定的装配规则（<strong>属性名称</strong>或<strong>属性类型</strong>），spring自动将匹配的属性值进行注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean标签的autowire属性可以实现自动装配</span></span><br><span class="line"><span class="comment">	autowire属性常用的两个值为</span></span><br><span class="line"><span class="comment">		byName：根据属性名注入，采用的时set注入，所以需要有set方法</span></span><br><span class="line"><span class="comment">		byType：根据属性类型注入，采用的时set注入，所以需要有set方法--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--类中的属性名要与xml中id值一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.Orders&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--类中的属性名要与xml中id值一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.Orders&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="引入外部属性文件"><a href="#引入外部属性文件" class="headerlink" title="引入外部属性文件"></a><em>引入外部属性文件</em></h4><p>1、创建外部属性文件，properties格式的文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;!--以阿里的德鲁伊数据库连接池配置为例--&gt;</span></span><br><span class="line"><span class="attr">建议加上***.***否则容易命名冲突</span></span><br><span class="line"><span class="attr">prop.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">prop.url</span>=<span class="string">jdbc:mysql://localhost:3306/userDb</span></span><br><span class="line"><span class="attr">prop.userName</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">prop.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>2、添加context上下文配置</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220131195517342.png" alt="image-20220131195517342"></p>
<p>3、将外部properties文件引入到spring配置文件中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:***.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h3 id="IOC操作Bean管理（基于注解）"><a href="#IOC操作Bean管理（基于注解）" class="headerlink" title="IOC操作Bean管理（基于注解）"></a>IOC操作Bean管理（基于注解）</h3><ul>
<li>@Component：普通的组件</li>
<li>@Service：用于业务逻辑层</li>
<li>@Controller：用于控制层</li>
<li>@Repository：用于dao层</li>
</ul>
<p>功能是一样的，都可以用来创建bean实例</p>
<br>

<h4 id="基于注解创建对象"><a href="#基于注解创建对象" class="headerlink" title="基于注解创建对象"></a>基于注解创建对象</h4><p>1、引入spring.aop.x.x.x.RELEASE.jar</p>
<p>2、开启组件扫描，添加context上下文配置（多个包之间逗号隔开）</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220131195517342-164636079790815.png" alt="image-20220131195517342"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;要扫描的包（包名），包名，...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、创建类，添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;user&quot;)</span> <span class="comment">//默认value为类名首字母小写的驼峰命名法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>开启包扫描的细节</strong></p>
<p>自定义扫描的包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">use-default-filters=&quot;false&quot;：表示现在不使用默认filter，自己配置filter</span></span><br><span class="line"><span class="comment">context:include-filter：设置要扫描的内容</span></span><br><span class="line"><span class="comment">context:exclude-filter：设置不扫描的内容</span></span><br><span class="line"><span class="comment">type=&quot;annotation&quot; 表示根据注解来扫描</span></span><br><span class="line"><span class="comment">expression=&quot;org.springframework.stereotype.Controller&quot;：表示只扫描双引号里的注解--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Component&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="基于注解实现属性注入"><a href="#基于注解实现属性注入" class="headerlink" title="基于注解实现属性注入"></a>基于注解实现属性注入</h4><p>@AutoWired：根据属性类型自动注入</p>
<p>@Qualifier：根据属性名称自动注入</p>
<p>@Resource：根据类型或者名称自动注入</p>
<p>@Value：注入普通类型属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Orders orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Qualifier需要和@AutoWired搭配使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value = &quot;orders&quot;/*id值*/)</span></span><br><span class="line">    <span class="keyword">private</span> Orders orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span> <span class="comment">//@Resource(name=&quot;orders&quot;/*id值*/)</span></span><br><span class="line">    <span class="keyword">private</span> Orders orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(value = &quot;jjw&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="基于注解注入多例"><a href="#基于注解注入多例" class="headerlink" title="基于注解注入多例"></a>基于注解注入多例</h4><p>1、在需要多例调用的类上加 <strong>@Scope(“prototype”)</strong></p>
<p>2、在进行注入时不能直接使用 <strong>@Autowired</strong> ，最简单的方法是使用工厂方式注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动注入一个工厂，使用工厂实例化需要多例的类</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ObjectFactory&lt;T&gt; objectFactory;</span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> objectFactory.getObject();</span><br></pre></td></tr></table></figure>

<br>

<h4 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a><em>完全注解开发</em></h4><p>1、创建配置类，替代xml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//作为配置类，替代配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.test&quot;)</span> <span class="comment">//开启包扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、加载配置类，通过配置类获取bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//加载配置类</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;orders&quot;</span>,Orders.class);</span><br><span class="line">        orders.setOname(<span class="string">&quot;jjw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><br>

<h3 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h3><p>什么是Aop</p>
<ul>
<li><p>面向切面编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<strong>耦合度降低</strong>，<strong>提高程序的可重用性</strong>，同时<strong>提高了开发的效率</strong></p>
</li>
<li><p>主要目的是将日志记录、性能统计、事物管理、异常处理等代码从业务逻辑代码中划分出来，从而可以在不修改源代码的情况下添加新的功能</p>
</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220201165200537.png" alt="image-20220201165200537"></p>
<br>

<h3 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h3><p>AOP底层使用了动态代理的方式，增强类中某个方法的功能</p>
<p><strong>有两种情况的动态代理</strong></p>
<p><strong>1、有接口的情况，使用JDK动态代理</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220201201233960.png" alt="image-20220201201233960"></p>
<p>创建接口实现类代理对象，增强类的方法</p>
<br>

<p><strong>实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*使用反射包下的Proxy类的newProxyInstance方法</span></span><br><span class="line"><span class="comment">*第一个参数：类加载器</span></span><br><span class="line"><span class="comment">*第二个参数：增强方法所在的类。这个类实现的接口，支持多个接口</span></span><br><span class="line"><span class="comment">*第三个参数：实现这个InvocationHandler，创建代理对象，写增强的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        <span class="type">UserDaoImpl</span> <span class="variable">userDaoImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//增强的逻辑</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//方法之前</span></span><br><span class="line">                System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//要增强的方法</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(userDaoImpl,args);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//方法之后执行</span></span><br><span class="line">                System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+method.getName());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>2、没有接口的情况，使用CGLIB动态代理</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220201203010743.png" alt="image-20220201203010743"></p>
<p>创建子类的代理对象，增强子类的方法</p>
<br>

<hr>
<br>

<h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p><strong>1、连接点</strong></p>
<p>类里面哪些方法可以被增强，这些方法称为连接点</p>
<br>

<p><strong>2、切入点</strong></p>
<p>实际被真正增强的方法，称为切入点</p>
<br>

<p><strong>3、通知</strong></p>
<ul>
<li><p>实际增强的逻辑部分称为通知</p>
</li>
<li><p>通知有多种类型</p>
<ul>
<li>前置通知</li>
<li>后置通知</li>
<li>环绕通知</li>
<li>异常通知</li>
<li>最终通知</li>
</ul>
</li>
</ul>
<br>

<p><strong>4、切面</strong></p>
<p>把通知应用到切入点的过程，称为切面</p>
<br>

<h3 id="AOP操作"><a href="#AOP操作" class="headerlink" title="AOP操作"></a>AOP操作</h3><p>参考：<a href="https://www.cnblogs.com/joy99/p/10941543.html">https://www.cnblogs.com/joy99/p/10941543.html</a></p>
<p>spring框架一般都是基于<strong>AspectJ</strong>实现AOP操作        *AspectJ不是spring的组成部分，它是一个独立的AOP框架</p>
<br>

<p><strong>引入AspectJ依赖</strong><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220202201934490.png" alt="image-20220202201934490"></p>
<p><strong>语法结构</strong><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220202202149656.png" alt="image-20220202202149656"></p>
<br>

<h4 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h4><p>1、创建<strong>User类</strong>，在类中定义方法</p>
<p>2、创建<strong>UserProxy增强类</strong></p>
<p>3、进行通知的配置</p>
<ul>
<li>在spring配置文件中开启配置扫描</li>
<li>使用注解创建<strong>User</strong>和<strong>UserProxy</strong></li>
<li>在增强类上添加注解**@Aspect**</li>
<li>在spring配置文件中开启生成代理对象</li>
</ul>
<p>4、配置不同类型的通知</p>
<ul>
<li>在增强类里面，在作为通知方法上添加通知类型注解，使用切入点表达式配置</li>
</ul>
<br>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启Aspect生成代理对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="comment">//@Before注解表示作为前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.test.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.test.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* com.test.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.test.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around1.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;around2.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//加载配置类</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>,User.class);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203142803295.png" alt="image-20220203142803295"></p>
<br>

<p><strong>抽取相同的切入点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.test.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="comment">//@Before注解表示作为前置通知</span></span><br><span class="line"><span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>有多个增强类，对同一个方法进行增强，可以设置增强类优先级，使其按顺序增强</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(3)</span> <span class="comment">//数值越小，优先级越高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h4><p>1、创建两个类，增强类和被增强类，创建方法</p>
<p>2、在spring配置文件中创建两个类对象</p>
<p>3、在spring配置文件中配置切入点</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203150952815.png" alt="image-20220203150952815"></p>
<br>

<hr>
<br>

<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p>JdbcTemplate是spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库进行操作</p>
<br>

<p><strong>引入jar包</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203161721997.png" alt="image-20220203161721997"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203161738736.png" alt="image-20220203161738736"></p>
<br>

<p><strong>数据库连接池配置</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203162110508.png" alt="image-20220203162110508"></p>
<br>

<p><strong>配置JdbcTemplate对象，注入DataSource</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203162731323.png" alt="image-20220203162731323"></p>
<br>

<p><strong>在dao层的dao实现类中注入JdbcTemplate对象</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203164024760.png" alt="image-20220203164024760"></p>
<br>

<hr>
<br>

<h3 id="JdbcTemplate操作数据库"><a href="#JdbcTemplate操作数据库" class="headerlink" title="JdbcTemplate操作数据库"></a>JdbcTemplate操作数据库</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>1、对应数据库表创建类</p>
<p>2、在dao进行数据库添加操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">    <span class="comment">//创建sql语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_book value(?,?)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用方法实现</span></span><br><span class="line">    <span class="comment">//第一个参数为sql语句，第二个参数为对应?中的数值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, book.getName() , book.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">    <span class="comment">//创建sql语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_book set book_naem=?,book_price=?, where book_id=?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用方法实现</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, book.getName() , book.getPrice() , book.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBook</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">	<span class="comment">//创建sql语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line">    <span class="comment">//调用方法实现</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, book.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><strong>返回有多少条记录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">selectCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from t_book&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql,Integer.class);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>返回一个对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Book <span class="title function_">selectById</span><span class="params">(String id)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_book where user_id = ?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BeanPropertyRowMapper会将返回的数据进行封装成对应的类,属性名需要一样</span></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class),id);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>返回一个集合</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">findAllBook</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_book&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BeanPropertyRowMapper会将返回的数据进行封装成对应的类</span></span><br><span class="line">    List&lt;Book&gt; bookList = jdbcTemplate.query(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bookList;</span><br><span class="line">&#125;xxxxxxxxxx8 1public List&lt;Book&gt; <span class="title function_">findAllBook</span><span class="params">()</span>&#123;<span class="number">2</span>    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_book&quot;</span>;<span class="number">3</span>    <span class="number">4</span>    <span class="comment">//BeanPropertyRowMapper会将返回的数据进行封装成对应的类5    List&lt;Book&gt; bookList = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class));6    7    return bookList;8&#125;public List&lt;Book&gt; findAllBook()&#123;    String sql = &quot;select * from t_book&quot;;        //BeanPropertyRowMapper会将返回的数据进行封装成对应的类    List&lt;Book&gt; bookList = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class));        return bookList;&#125;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><p><strong>批量添加</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchAdd</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_book value(?,?)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] count = jdbcTemplate.batchUpdate(sql,batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>批量修改</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdate</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_book set book_naem=?,book_price=?, where book_id=?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] count = jdbcTemplate.batchUpdate(sql,batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>批量删除</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchDelete</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] count = jdbcTemplate.batchUpdate(sql,batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务概念</strong></p>
<p>事务时数据库操作最基本单元，逻辑上一组操作，要么都成功，要么都失败</p>
<p>在spring中进行事务操作有两种方式</p>
<p>1、编程式事务管理</p>
<p>2、声明式事务管理（底层使用AOP原理）</p>
<br>

<p><strong>四大特性</strong></p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<br>

<h3 id="示例（银行转账为例）"><a href="#示例（银行转账为例）" class="headerlink" title="示例（银行转账为例）"></a>示例（银行转账为例）</h3><p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220204194207653.png" alt="image-20220204194207653"></p>
<p><strong>步骤</strong></p>
<p>1、在spring配置文件中配置事务管理器</p>
<p>2、在spring配置文件中引入名称空间tx</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220204201052249.png" alt="image-20220204201052249"></p>
<p>3、开启事务注解</p>
<p>4、在service层上添加事务注解（也可以添加到方法上面）</p>
<ul>
<li>如果把注解添加到类上面，这个类里面所有的方法都添加事务</li>
<li>如果把这个注解添加到方法上面，就只给某一个方法添加事务</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定开启哪个事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driver</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduceMoney</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">//创建sql语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_bank set money = money-? where username=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;jjw1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMoney</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">//创建sql语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_bank set money = money+? where username=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;jjw2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accountMoney</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行事务操作</span></span><br><span class="line">        userDao.reduceMoney();</span><br><span class="line">        userDao.addMoney;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="声明式事务管理参数配置"><a href="#声明式事务管理参数配置" class="headerlink" title="声明式事务管理参数配置"></a>声明式事务管理参数配置</h3><p><strong>@Transaction(参数)</strong></p>
<br>

<p>propagation：事务的传播行为</p>
<ul>
<li>多事务方法直接进行调用，这个过程中事务是如何进行管理的（一个有无事务的方法调用另外一个有无事务的方法，事务如何进行处理）</li>
</ul>
<br>

<p>spring定义了七种事务传播行为</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220204204012987.png" alt="image-20220204204012987"></p>
<br>

<p>ioslation：事务隔离级别</p>
<ul>
<li>多事务操作之间不会产生影响，不会产生脏读，不可重复读、虚读</li>
</ul>
<br>

<p>timeout：超时时间</p>
<ul>
<li>事务需要在一定的时间内进行提交，否则进行回滚</li>
<li>默认为-1（不超时），设置时间已秒为单位</li>
</ul>
<br>

<p>readOnly：是否只读</p>
<ul>
<li>只能查询操作</li>
<li>默认为false（不只读）</li>
</ul>
<br>

<p>rollbackFor：回滚</p>
<ul>
<li>设置出现哪些异常进行事务回滚</li>
</ul>
<br>

<p>noRollbackFor：不回滚</p>
<ul>
<li>设置出现哪些异常进行不事务回滚</li>
</ul>
<br>

<br>

<h4 id="完全注解方式"><a href="#完全注解方式" class="headerlink" title="完全注解方式"></a><em>完全注解方式</em></h4><p>创建配置类，使用配置类替代xml配置文件</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220204205657762.png" alt="image-20220204205657762"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220204205933089.png" alt="image-20220204205933089"></p>
<br>

<hr>
<br>

<h2 id="spring5框架新功能"><a href="#spring5框架新功能" class="headerlink" title="spring5框架新功能"></a>spring5框架新功能</h2><p><strong>整个spring5框架是基于Java8的</strong>，运行时兼容JDK9</p>
<br>

<h3 id="支持整合日志框架"><a href="#支持整合日志框架" class="headerlink" title="支持整合日志框架"></a>支持整合日志框架</h3><p>spring5框架自带了通用的日志封装，官方建议使用Log4j2</p>
<br>

<p><strong>整合Log4j2</strong></p>
<p>1、引入jar包<img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220205124649342.png" alt="image-20220205124649342"></p>
<p>2、创建log4j2.xml（名称固定）配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志级别以及优先级排序:oFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Confiquration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到1og4j2内部各种详细输出--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--先定义所有的appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出日.志信息到控制台--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyY-MM-dd HH:mm : ss .sss&#125; [t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--root:用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p>3、自定义日志内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Test.class);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//加载配置类</span></span><br><span class="line">    log.info(<span class="string">&quot;info............&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Nullable注解和函数式注册对象"><a href="#Nullable注解和函数式注册对象" class="headerlink" title="Nullable注解和函数式注册对象"></a>Nullable注解和函数式注册对象</h3><p><strong>@Nullable</strong></p>
<p>@Nullable注解可以使用在方法上面，属性上面，参数上面</p>
<p>方法：表示方法返回值可以为空，不会报空指针异常</p>
<p>属性值：表示属性值可以为空</p>
<p>参数：表示参数值可以为空</p>
<br>

<p><strong>函数式注册对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建GenericApplicationContext对象</span></span><br><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="comment">//调用context的方法对象注册</span></span><br><span class="line">context.refresh();</span><br><span class="line">context.registerBean(<span class="string">&quot;user&quot;</span>,User.class,()-&gt; <span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line"><span class="comment">//获取对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h3 id="单元测试框架（JUnit5）"><a href="#单元测试框架（JUnit5）" class="headerlink" title="单元测试框架（JUnit5）"></a>单元测试框架（JUnit5）</h3><p><strong>整合JUnit4</strong></p>
<p>1、引入依赖</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220205145509132.png" alt="image-20220205145509132"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220205151659537.png" alt="image-20220205151659537"></p>
<br>

<p>2、创建测试类，使用注解方式完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span> <span class="comment">//单元测试框架</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean.xml&quot;)</span> <span class="comment">//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Jtest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">//JUnit4下的@Test注解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>若不使用JUnit4框架的话test方法中需要加载配置文件后才能使用ioc容器中的bean，使用了@RunWith注解将会自动开启ioc容器，不需要再通过getBean()方法获得bean</strong></p>
<br>

<p><strong>整合JUnit5</strong></p>
<p>1、引入依赖</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220205152322878.png" alt="image-20220205152322878"></p>
<br>

<p>2、创建测试类，使用注解方式完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(&quot;classpath:bean.xml&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:bean.xml&quot;)</span> <span class="comment">//复合注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Jtest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized锁、Lock锁简单使用</title>
    <url>/2022/03/19/synchronized%E9%94%81%E3%80%81Lock%E9%94%81%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h1><h3 id="修饰实例方法："><a href="#修饰实例方法：" class="headerlink" title="修饰实例方法："></a>修饰实例方法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被锁的对象是类的实例对象，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SynContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynContainer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Productor</span>(container).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Consumer</span>(container).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Productor</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Productor</span><span class="params">(SynContainer container)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SynContainer = container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Productor</span><span class="params">(SynContainer container)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SynContainer = container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynContainer</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当运行这两个生产者和消费者时，锁住的是SynContainer的实例container，同一时刻只能有一个线程访问这个实例</span></span><br></pre></td></tr></table></figure>



<h3 id="修饰静态方法："><a href="#修饰静态方法：" class="headerlink" title="修饰静态方法："></a>修饰静态方法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被锁的对象是类对象</p>
<h3 id="修饰实例对象"><a href="#修饰实例对象" class="headerlink" title="修饰实例对象:"></a>修饰实例对象:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块，锁住的是该类的实例对象</p>
<h3 id="修饰class对象"><a href="#修饰class对象" class="headerlink" title="修饰class对象:"></a>修饰class对象:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (SynContainer.class)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块，锁住的是该类的类对象</p>
<h3 id="修饰任意实例对象Object"><a href="#修饰任意实例对象Object" class="headerlink" title="修饰任意实例对象Object:"></a>修饰任意实例对象Object:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">synchronize (num)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块，锁住的是配置的实例对象</p>
<p>int对象作为锁</p>
<hr>
<h1 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h1><h3 id="ReentrantLock锁"><a href="#ReentrantLock锁" class="headerlink" title="ReentrantLock锁"></a>ReentrantLock锁</h3><p>相比于synchronized锁，Lock锁是显示的，能够显示的定义同步锁来实现同步</p>
<p>ReentrantLock（可重入锁）类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reentrantLock.lock();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">reentrantLock.unlock();</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestLock1</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestLock1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(lock1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(lock1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(lock1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestLock1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reentrantLock.lock();  <span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span> (num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(num--);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();  <span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="生产者消费者问题（管程法）"><a href="#生产者消费者问题（管程法）" class="headerlink" title="生产者消费者问题（管程法）"></a>生产者消费者问题（管程法）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">SynContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynContainer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Productor</span>(container).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Productor</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Productor</span><span class="params">(SynContainer container)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span> ; i++)</span><br><span class="line">        container.push(<span class="keyword">new</span> <span class="title class_">Chicken</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(SynContainer container)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">            container.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chicken</span>&#123;</span><br><span class="line">    <span class="type">int</span> id ; <span class="comment">//产品编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chicken</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynContainer</span>&#123;</span><br><span class="line">    <span class="comment">//容器大小</span></span><br><span class="line">    Chicken[] chickens = <span class="keyword">new</span> <span class="title class_">Chicken</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//容器计数器</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者放入产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Chicken chicken)</span>&#123;</span><br><span class="line">        <span class="comment">//如果容器满了，就需要等待消费者消费</span></span><br><span class="line">        <span class="comment">//最好不要用if，应该用while，否则当有多个消费者的时候，会出现脏判断的</span></span><br><span class="line">        <span class="keyword">while</span> (count == chickens.length)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();<span class="comment">//阻塞此线程，并释放锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果容器没满，生产者放入产品</span></span><br><span class="line">        chickens[count] = chicken;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知消费者消费产品</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll(); <span class="comment">//唤醒其他等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者消费产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Chicken <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断能否消费</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待生产者生产，消费者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果可以消费</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="type">Chicken</span> <span class="variable">chicken</span> <span class="operator">=</span> chickens[count];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知生产者生产</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chicken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>synchronized、Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>singleton</title>
    <url>/2022/03/21/singleton/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
</blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<br>

<p><strong>优点：</strong></p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<br>

<p><strong>缺点：</strong></p>
<p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<br>

<p><strong>使用场景：</strong></p>
<ul>
<li>1、要求生产唯一序列号。</li>
<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建的一个对象需要消耗的资源过多，比如 I&#x2F;O 与数据库的连接等。</li>
</ul>
<br>

<hr>
<h1 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h1><br>

<h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><blockquote>
<p>描述：基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p>
</blockquote>
<p>如果后续并没有使用到，可能会造成浪费空间</p>
<p>线程安全问题与登记式是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">HUNGRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="登记式"><a href="#登记式" class="headerlink" title="登记式"></a>登记式</h2><blockquote>
<p>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>
<p>描述：它跟饿汉式不同的是：饿汉式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 <strong>Holder类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。</strong></p>
</blockquote>
<br>

<p><strong>但没有同步锁是如何保证线程安全的呢？</strong></p>
<p>jvm在加载Holder时不会连SingletonHolder一同加载（ lazy loading ），这里涉及到<strong>类的加载时机</strong></p>
<blockquote>
<ol>
<li>遇到 new 、getstatic 、putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化 。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及凋用一个类的静态方法的时候。</li>
<li>使用 java-lang 、 reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invokeMethodHandle 实例最后的解析结果 REF-getStatic 、 REF_putStatic 、 REF invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>
</ol>
</blockquote>
<br>

<p><strong>外部调用getInstance()方法后，会触发SingletonHolder的加载，任意一个线程获取该【类加载】的锁后，就能保SingletonHolder首次给new出来，只有一个线程进入该内部类。加载完成后，static成员变量是唯一的。</strong></p>
<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> <span class="title function_">Holder</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Holder <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.holder;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>当使用到的时候才去加载这个类，避免了空间的浪费</p>
<p>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy == <span class="literal">null</span>)&#123;</span><br><span class="line">            lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>上述实现存在一个明显的问题，就是在多线程的情况下不能保证只返回了一个实例，因为getInstance()方法没有加同步锁，可能会造成线程安全的问题</p>
<p>因此我们需要在getInstance()方法上加上同步锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy == <span class="literal">null</span>)&#123;</span><br><span class="line">            lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>在给getInstance()方法加上同步锁之后，这个方法变成线程安全的了，也不会有产生多个实例的情况了。</p>
<p>但是这样做的话我们发现每一次判断lazy实例是否存在的时候就要去拿到同步锁，而判断与线程安全是无关的，因此在方法上加同步锁会大大降低性能。因此我们采取<strong>双重锁校验模式</strong>，将同步代码块放在方法中，每次先判断实例是否存在，如果存在就直接返回实例；不存在再去拿同步锁进行初始化，这样可以减少线程上下文的切换，提升性能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>上述实现代码，似乎很完美的解决了线程安全问题和性能的问题，但它仍然是线程不安全的。<strong>因为初始化代码的new关键字并不是原子性操作</strong></p>
<blockquote>
<p>new的操作步骤：</p>
<ul>
<li>分配内存空间</li>
<li>执行构造方法，初始化对象</li>
<li>把这个对象指向这个空间</li>
</ul>
<p>由于不是原子性操作，可能会造成指令重排的问题，例如先将这个对象指向这个空间，再去初始化对象</p>
</blockquote>
<p>情况：一个线程A执行代码，在new操作时发生了指令重排，导致先将对象指向分配的空间，再去初始化对象；这时线程B进入发现这个对象已经指向了一个空间，<strong>它就会认为这个对象!&#x3D;null</strong>，但实际上这个对象可能还未完成初始化对象</p>
<p>所以由于存在这种情况，我们必须禁止指令重排，即<strong>加上volatile关键字</strong>，这样才算是完整的双重锁校验模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="反射机制破坏单例"><a href="#反射机制破坏单例" class="headerlink" title="反射机制破坏单例"></a>反射机制破坏单例</h3><h4 id="增加校验"><a href="#增加校验" class="headerlink" title="增加校验"></a>增加校验</h4><p>虽然解决了线程安全问题、性能和原子性的问题，但因为存在反射机制，可以人为的去破坏单例模式。所以仍然存在安全问题</p>
<p>我们可以在造构造器中判断是否存在这个实例来解决问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Lazy.class)&#123;</span><br><span class="line">            <span class="comment">//当这个实例已经存在了则不能使用反射机制创建对象</span></span><br><span class="line">            <span class="keyword">if</span> (lazy!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请勿使用反射机制破坏&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;</span><br><span class="line">                    lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="增加信号量"><a href="#增加信号量" class="headerlink" title="增加信号量"></a>增加信号量</h4><p>但这样也存在一点问题，反射机制创建的lazy对象与正常创建的lazy对象并不是一个对象，当第一次也是使用反射机制去创建lazy对象时，lazy!&#x3D;null是检测不出来是否存在这个单例的</p>
<p>我们可以使用<strong>信号量的方式</strong>，这样虽然第一次可以使用反射机制获得到单例，但也只能获取到一次，某种程度上来说这也算一个单例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Lazy.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="literal">false</span>)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                lazy=<span class="built_in">this</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请勿使用反射机制破坏&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;</span><br><span class="line">                    lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>但但但是就算做到这样仍然不能防止被反射破坏，因为既然反射能获得到私有的构造器，它也能获取到私有静态变量，这样的话可以每次反射创建对象后再将信号量设置为原来的样子。但由于私有静态变量较难被反编译，因此这种方法也存在它的可用性</p>
<blockquote>
<p><strong>总结：懒汉式实现的单例模式是不可以防止被反射破坏的</strong></p>
</blockquote>
<br>

<hr>
<br>

<h2 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h2><p>我们先来看一个枚举的单例模式的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> EnumSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="使用无参构造器反射创建"><a href="#使用无参构造器反射创建" class="headerlink" title="使用无参构造器反射创建"></a>使用无参构造器反射创建</h3><p>当我们试图使用反射机制去创建这个枚举类时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;EnumSingleton&gt; constructor= <span class="literal">null</span>;</span><br><span class="line">constructor = EnumSingleton.class.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">EnumSingleton singleton= <span class="literal">null</span>;</span><br><span class="line">singleton = constructor.newInstance();</span><br><span class="line">System.out.println(singleton);</span><br></pre></td></tr></table></figure>

<p>将会报异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodException: com.lxp.pattern.singleton.EnumSingleton.&lt;init&gt;()</span><br></pre></td></tr></table></figure>

<p>使用debug模式运行，会发现是因为EnumSingleton.class.getDeclaredConstructors()获取所有构造器，会发现并没有我们所设置的无参构造器，但是我们并没有在枚举类中设置其他的有参构造方法，这是怎么回事呢？查看编译后的源码，其继承了Enum类，所以会有（String.class,int.class）的构造器</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/21/singleton/image-20220321203503408.png" alt="image-20220321203503408"></p>
<br>

<h3 id="使用有参构造器反射创建"><a href="#使用有参构造器反射创建" class="headerlink" title="使用有参构造器反射创建"></a>使用有参构造器反射创建</h3><p>也许会有疑问，是不是因为自身的类没有无参构造方法才导致的异常？但执行下述代码后仍然会异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;EnumSingleton&gt; constructor= <span class="literal">null</span>;</span><br><span class="line">constructor = EnumSingleton.class.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">EnumSingleton singleton= <span class="literal">null</span>;</span><br><span class="line">singleton = constructor.newInstance();</span><br><span class="line">System.out.println(singleton);</span><br></pre></td></tr></table></figure>

<p>抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br></pre></td></tr></table></figure>

<p><strong>Cannot reflectively create enum objects</strong> 这个异常的意思是不能使用反射机制创建枚举对象</p>
<br>

<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>我们通过查看newInstance方法的源码发现，<strong>当对枚举类使用newInstance方法时会抛出异常</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/21/singleton/image-20220321201936962.png" alt="image-20220321201936962"></p>
<p>为了防止反射机制破坏懒汉模式，我们可以使用枚举的方式实现单例模式</p>
<blockquote>
<p>枚举是最好的单例模式，同时枚举模式也能保证线程安全</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法与二叉查找树和堆的实现</title>
    <url>/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>排序原理：</strong></p>
<p>1、比较相邻的元素，如果前一个元素比后一个元素大，就交换这两个元素的位置</p>
<p>2、对每一对元素都这样处理，最后的出来的结构就是排序完成的结果</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220116195027877.png" alt="image-20220116195027877"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//integer实现了comparable接口，提供了比较的规则</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        Bubble.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line">    <span class="comment">//对数组a中的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=a.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//比较索引j和索引j+1的值</span></span><br><span class="line">                <span class="keyword">if</span> (greater(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否大于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>冒泡排序时间复杂度分析：O（n^2）</strong></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>排序原理：</strong></p>
<p>1、每一次遍历过程中，都假定第一个索引处的元素是最小值，然后依次和其他索引处的值进行比较，直到找到本次遍历最小值</p>
<p>2、交换第一个索引处和最小值所在的索引处的值</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220117162148826-16476725408391.png" alt="image-20220117162148826"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> &#123;</span><br><span class="line">    <span class="comment">//对数组内的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=a.length-<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//定义变量，记录最小索引所在位置，默认为每一次遍历的第一个元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;a.length; j++)&#123;</span><br><span class="line">                <span class="comment">//比较minIndex，与现在索引所在的值</span></span><br><span class="line">                <span class="keyword">if</span> (greater(a[minIndex],a[j]))&#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换最小值和每次遍历的第一个值</span></span><br><span class="line">            exch(a,i,minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否大于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>选择排序时间复杂度分析：O（n^2）</strong></p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>排序原理：</strong></p>
<p>1、将所有元素<strong>分为已排序和未排序</strong></p>
<p>2、将未排序数组的第一个元素向已排序数组中插入</p>
<p>3、倒叙遍历已排序数组，找到小于或等于插入元素的元素，并将插入元素放到这个位置，其余元素向后移动一位</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220117183137041-16476725408392.png" alt="image-20220117183137041"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> &#123;</span><br><span class="line">    <span class="comment">//对数组a中的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="comment">//比较索引j处的值和索引j-1处的值</span></span><br><span class="line">                <span class="comment">//如果j-1处的值比j大则j--，小就交换</span></span><br><span class="line">                <span class="keyword">if</span> (greater(a[j-<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                    exch(a,j-<span class="number">1</span>,j);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否大于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**插入排序时间复杂度分析：O（n^2）    **</p>
<p><strong>（其本质跟冒泡排序相似）</strong></p>
<hr>
<h3 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h3><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序是插入排序的一种，又叫<strong>”缩小增量排序“</strong>，希尔排序的增量没有固定的规则</p>
<p>希尔排序的时间的时间复杂度为</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/eb39d4c67a9cabbd3a2690a2151ee6cc.svg" alt="img"></p>
<p> ，希尔排序时间复杂度的下界是n*log2n。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。但是比</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/c937d30f3cd06da1cd53133d8a3b4887.svg" alt="img"></p>
<p> 复杂度的算法快得多。</p>
<p><strong>专家们提倡，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法</strong></p>
<p><strong>排序原理：</strong></p>
<p>1、选定一个增量h，按照增量h作为数据分组的依据，对数据进行分组</p>
<p>2、对分好组的每一组数据完成插入排序</p>
<p>3、减小增长量，最小减一，重复第二步</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220117202712044.png" alt="image-20220117202712044"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> &#123;</span><br><span class="line">    <span class="comment">//对数组内的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//根据数组的长度，确定增长量</span></span><br><span class="line">        <span class="type">int</span> h=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h&lt;a.length/<span class="number">2</span>)&#123;</span><br><span class="line">            h=<span class="number">2</span>*h+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//希尔排序</span></span><br><span class="line">        <span class="keyword">while</span> (h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//找待插入的元素</span></span><br><span class="line">            <span class="comment">//从h之后的每一个元素都需要进行跟自己的组进行排序，这是i++的原因</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=h; i&lt;a.length; i++)&#123;</span><br><span class="line">                <span class="comment">//插入排序</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;=h; j-=h)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (greater(a[j-<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                        exch(a,j-<span class="number">1</span>,j);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减小增长量</span></span><br><span class="line">            h=h/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否大于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序体现的是<strong>分而治之的思想</strong></p>
<p><strong>排序原理：</strong></p>
<p>1、尽可能的将一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数为1</p>
<p>2、不断将相邻的两个子组进行合并成一个有序的大组，直到只有一个组为止</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220117214230426.png" alt="image-20220117214230426"></p>
<p>使用辅助数组，对两个子组进行排序，<strong>排序方式与合并两个有序链表的方式类似</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line">    <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] assist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组内的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//初始化辅助数组</span></span><br><span class="line">        assist = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];</span><br><span class="line">        <span class="comment">//定义一个lo变量和hi变量，分别记录数组中最小和最大的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//调用sort重载方法</span></span><br><span class="line">        sort(a,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组a中从索引lo到索引hi的元素进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="comment">//做安全性校验</span></span><br><span class="line">        <span class="keyword">if</span> (hi&lt;=lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个mid变量 将lo到hi之间的数据分成两组</span></span><br><span class="line"><span class="comment">         * sort(a,lo,mid);</span></span><br><span class="line"><span class="comment">         * sort(a,mid+1,hi);</span></span><br><span class="line"><span class="comment">         * 递归分组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别对每一组数据进行排序</span></span><br><span class="line">        sort(a,lo,mid);</span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再把两个组中的数据进行合并</span></span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将两个有序的子组合并成一个有序的大组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="comment">//定义三个指针</span></span><br><span class="line">        <span class="comment">//辅助数组的指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> lo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历，将两有序子组合并</span></span><br><span class="line">        <span class="keyword">while</span> (p1&lt;=mid &amp;&amp; p2&lt;hi)&#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[p1],a[p2]))&#123;</span><br><span class="line">                assist[i++] = a[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                assist[i++] = a[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当其中某一个子组遍历完成，而另一个子组未完成时</span></span><br><span class="line">        <span class="comment">//将剩余元素顺序放入辅助数组中</span></span><br><span class="line">        <span class="keyword">while</span> (p1&lt;=mid)&#123;</span><br><span class="line">            assist[i++] = a[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2&lt;=hi)&#123;</span><br><span class="line">            assist[i++] = a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将辅助数组中的元素拷贝到原数组的对应位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> index=lo; index&lt;=hi; index++)&#123;</span><br><span class="line">            a[index] = assist[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否小于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span></span><br><span class="line">    <span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>归并排序的时间复杂度分析：O（n logn）</strong></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>排序原理：</strong></p>
<p>1、首先设定一个分界值，通过该分界值将数组分成左右两部分</p>
<p>2、将大于或等于分界值的放到数组右边，小于分界值的放到数值左边</p>
<p>3、重复操作分界值左右两边的元素，最终就得到排序好的数组</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220118201405192.png" alt="image-20220118201405192"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line">    <span class="comment">//对数组内的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">        sort(a,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组a中从索引lo到索引hi的元素进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="comment">//安全性校验</span></span><br><span class="line">        <span class="keyword">if</span> (lo&gt;=hi)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获得分界值的索引，分界值右边比分界值大，左边比分界值小</span></span><br><span class="line"><span class="comment">         * 并已分界值两边分为两组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> partition(a,lo,hi);<span class="comment">//返回的是分界值的索引，分界值位置变换后的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使左子组有序</span></span><br><span class="line">        sort(a,lo,partition-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使右子组有序</span></span><br><span class="line">        sort(a,partition+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法的作用是使用分界值（默认为数组第一个元素）对数组lo到hi的元素进行分组</span></span><br><span class="line"><span class="comment">     * 比分界值大的放右边，比分界值小的放左边</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回分组之后分界值所在的索引（因为分界值一开始的索引为lo，所以最后分界值的位置会发生变化）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="comment">//确定分界值</span></span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">key</span> <span class="operator">=</span> a[lo];</span><br><span class="line">        <span class="comment">//定义两个指针，分别指向待切分元素的最小索引和最大索引的下个位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> lo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> hi+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//先从右往左扫描，找到一个比分界值小的元素然后停止</span></span><br><span class="line">            <span class="keyword">while</span> (less(key,a[--right]))&#123;</span><br><span class="line">                <span class="keyword">if</span> (right == lo)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先从左往右扫描，找到一个比分界值大的元素然后停止</span></span><br><span class="line">            <span class="keyword">while</span> (less(a[++left],key))&#123;</span><br><span class="line">                <span class="keyword">if</span> (left == hi)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束</span></span><br><span class="line">            <span class="keyword">if</span> (left&gt;=right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                exch(a,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换right与分界值，此处不能与left交换，因为left可能大于right，若与letf交换可能会导致，比分界值大的被交换</span></span><br><span class="line">        exch(a,lo,right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否小于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span></span><br><span class="line">    <span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序的时间复杂度分析：最优情况：O（nlogn） 最坏情况：O（n^2）</strong></p>
<p><strong>归并排序和快速排序的区别：</strong></p>
<p>归并排序将数组分成两个子数组分别排序，并将有序的子数组归并，从而将整个数组排序</p>
<p>快速排序的方式是当两个数组都有序时，整个数组就有序了</p>
<hr>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p><strong>树的定义：</strong></p>
<p>树是由n个有限结点组成一个具有层次关系的集合。它看起来像一颗倒挂的树</p>
<p><strong>树的特点：</strong></p>
<p>1、每个结点有零个或多个子结点</p>
<p>2、没有父节点的结点为根结点</p>
<p>3、每一个非根节点只有一个父结点</p>
<p>4、每个结点及其后代结点整体上可以看作是一个棵树，称为当前结点的父节点的一个子树</p>
<p><strong>结点的度：</strong></p>
<p>一个结点含有的子树的个数称为该结点的度</p>
<p><strong>叶结点：</strong></p>
<p>度为0的结点也称为叶结点</p>
<p><strong>树的度：</strong></p>
<p>树中所有结点的度的最大值</p>
<p><strong>树的深度：</strong></p>
<p>树中结点的最大层次</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树就是度不超过2的树</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220119200839620-16476728009495.png" alt="image-20220119200839620"></p>
<p><strong>满二叉树：</strong></p>
<p>一个二叉树，如果<strong>每一个层的结点树都达到最大值</strong>，则这个二叉树就是满二叉树</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220119201015460-16476728009506.png" alt="image-20220119201015460"></p>
<p><strong>完全二叉树：</strong></p>
<p>叶结点只能出现在最下层和次下层</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220119201231459-16476728009507.png" alt="image-20220119201231459"></p>
<h5 id="二叉查找树的创建"><a href="#二叉查找树的创建" class="headerlink" title="二叉查找树的创建"></a>二叉查找树的创建</h5><p><strong>插入方法put的实现思想：</strong></p>
<p>1、如果当树中没有任何一个结点，则直接把新结点作为根结点</p>
<p>2、如果当前树不为空，则从根结点开始</p>
<ul>
<li>如果新结点的key小于当前结点的key，则继续找当前结点的左子结点</li>
<li>如果新结点的key大于当前结点的key，则继续找当前结点的右子结点</li>
<li>如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220120141818232-16476728009508.png" alt="image-20220120141818232"></p>
<p><strong>查询方法get实现思想：</strong></p>
<p>从根结点开始</p>
<ul>
<li>如果要查询的key小于当前结点的key，则继续找当前结点的左子结点</li>
<li>如果要查询的key大于当前结点的key，则继续找当前结点的右子结点</li>
<li>如果要查询的key等于当前结点的key，则返回当前结点的value值</li>
</ul>
<p><strong>删除方法delete实现思想：</strong></p>
<ul>
<li><p>找到被删除结点</p>
</li>
<li><p>找到被删除结点右子树的最小结点minNode</p>
</li>
<li><p>删除右子树中的最小结点</p>
</li>
<li><p>让被删除结点的左子树成为最小结点minNode的左子树，让被删除结点的右子树成为最小结点minNode的右子树</p>
</li>
<li><p>让被删除结点的父结点指向最小结点minNode</p>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;,Value&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root; <span class="comment">//记录根结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N; <span class="comment">//记录树中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向树中插入一个键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key, Value value)</span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给指定树x上，添加一个键值对，并返回添加后的新树</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">put</span><span class="params">(Node x, Key key, Value value)</span>&#123;</span><br><span class="line">        <span class="comment">//如果x子树为null</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key,value,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果x子树不为null</span></span><br><span class="line">        <span class="comment">//比较x结点的键和key的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo((Key) x.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &gt; x.key，继续找右子树</span></span><br><span class="line">            x.right = put(x.right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &lt; x.key，继续找左子树</span></span><br><span class="line">            x.left = put(x.left,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//key = x.key，替换x的value</span></span><br><span class="line">            x.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据key，从树中找出对应的值</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从指定的树x中，找出key对应的值</span></span><br><span class="line">    <span class="keyword">private</span> Value <span class="title function_">get</span><span class="params">(Node x, Key key)</span>&#123;</span><br><span class="line">        <span class="comment">//如果x子树为null</span></span><br><span class="line">        <span class="comment">//包含了找不到key值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果x子树不为null</span></span><br><span class="line">        <span class="comment">//比较x结点的键和key的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo((Key) x.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &gt; x.key，继续找右子树</span></span><br><span class="line">            <span class="keyword">return</span> get(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &lt; x.key，继续找左子树</span></span><br><span class="line">            <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//key = x.key，返回x的value</span></span><br><span class="line">            <span class="keyword">return</span> (Value) x.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据key，删除树中对应的键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定树x上的键为key的键值对，并返回删除后的新树</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(Node x, Key key)</span>&#123;</span><br><span class="line">        <span class="comment">//如果x子树为null</span></span><br><span class="line">        <span class="comment">//包含了找不到key值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果x子树不为null</span></span><br><span class="line">        <span class="comment">//比较x结点的键和key的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo((Key) x.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &gt; x.key，继续找右子树</span></span><br><span class="line">            x.right = delete(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &lt; x.key，继续找左子树</span></span><br><span class="line">            x.left = delete(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//key = x.key，执行删除操作</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到右子树中最小的结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (minNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到并删除右子树中最小的结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (n.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (n.left.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                    n.left = <span class="literal">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//变换n结点</span></span><br><span class="line">                    n = n.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//让x结点的左子树成为minNode的左子树</span></span><br><span class="line">            minNode.left = x.left;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//让x结点的右子树成为minNode的右子树</span></span><br><span class="line">            minNode.right = x.right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//让x结点的父结点指向minNode</span></span><br><span class="line">            x = minNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//元素个数减一</span></span><br><span class="line">            N--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取树中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="二叉查找树中最小的键"><a href="#二叉查找树中最小的键" class="headerlink" title="二叉查找树中最小的键"></a>二叉查找树中最小的键</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回二叉查找树中最小的键</span></span><br><span class="line"><span class="keyword">public</span> Key <span class="title function_">min</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Key) min(root).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">min</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> min(x.left);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="二叉查找树中最大的键"><a href="#二叉查找树中最大的键" class="headerlink" title="二叉查找树中最大的键"></a>二叉查找树中最大的键</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回二叉查找树中最大的键</span></span><br><span class="line"><span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Key) min(root).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">max</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> max(x.right);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h5><p>很多情况下，我们需要遍历树，由于树状结构和线性结构不一样，它没有办法从头开始依次向后遍历，所以存在如何遍历，也就是按照什么样的<strong>搜索路径</strong>进行遍历的问题</p>
<p>我们可以把二叉树的<strong>低级遍历方式</strong>分为以下三种方式：</p>
<p><strong>1、先序遍历：</strong></p>
<p>先访问根结点，再访问左子树，最后访问右子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用先序遍历，获取整个树中的所有键</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Key&gt; <span class="title function_">preErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    preErgodic(root,keys);</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preErgodic</span><span class="params">(Node x, List&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将x.key放入keys</span></span><br><span class="line">    keys.add((Key) x.key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断左右子树是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="literal">null</span>)&#123;</span><br><span class="line">        preErgodic(x.left,keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        preErgodic(x.right,keys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>2、中序遍历：</strong></p>
<p>先访问左子树，再访问根结点，最后访问右子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用中序遍历，获取整个树中的所有键</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Key&gt; <span class="title function_">midErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    midErgodic(root,keys);</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">midErgodic</span><span class="params">(Node x, List&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断左右子树是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="literal">null</span>)&#123;</span><br><span class="line">        midErgodic(x.left,keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将x.key放入keys</span></span><br><span class="line">    keys.add((Key) x.key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        midErgodic(x.right,keys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3、后序遍历：</strong></p>
<p>先访问左子树，再访问右子树，最后访问根结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用后序遍历，获取整个树中的所有键</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Key&gt; <span class="title function_">afterErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    afterErgodic(root,keys);</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">afterErgodic</span><span class="params">(Node x, List&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断左右子树是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="literal">null</span>)&#123;</span><br><span class="line">        afterErgodic(x.left,keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        afterErgodic(x.right,keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将x.key放入keys</span></span><br><span class="line">    keys.add((Key) x.key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>高级遍历方式：层序遍历</strong> </p>
<p><strong>实现步骤：</strong></p>
<ul>
<li><p>创建队列，存储每一层的结点</p>
</li>
<li><p>使用循环从队列弹出一个结点</p>
<ul>
<li><p>获取当前结点的key</p>
</li>
<li><p>如果当前结点的左子结点不为空，则把左子结点放入到队列中</p>
</li>
<li><p>如果当前结点的右子结点不为空，则把右子结点放入到队列中</p>
</li>
</ul>
</li>
</ul>
<p><strong>此处使用ArrayList来代替队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Key&gt; <span class="title function_">layerErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认往队列中放入根结点</span></span><br><span class="line">        nodes.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodes.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//从队列中弹出结点，把key放入keys中</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            keys.add((Key) node.key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断当前结点是否有左子结点，有则放入nodes中</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                nodes.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断当前结点是否有右子结点，有则放入nodes中</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                nodes.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keys;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="二叉树的最大深度问题"><a href="#二叉树的最大深度问题" class="headerlink" title="二叉树的最大深度问题"></a>二叉树的最大深度问题</h5><p>给定一颗树，计算树的最大深度（树的根结点到最远叶子结点的最长路径上的结点数）</p>
<p><strong>实现步骤：</strong></p>
<ul>
<li>如果根结点为空，则最大深度为0</li>
<li>计算左子树的最大深度</li>
<li>计算右子树的最大深度</li>
<li>当前树的最大深度 &#x3D; 左子树的最大深度和右子树的最大深度中的较大者 + 1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算指定的树的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//x的最大深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左子树的最大深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//右子树的最大深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算左子树最大深度</span></span><br><span class="line">        <span class="keyword">if</span> (x.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            maxL = maxDepth(x.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算右子树最大深度</span></span><br><span class="line">        <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            maxR = maxDepth(x.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较左右子树最大深度，取较大值+1</span></span><br><span class="line">        max = maxL&gt;maxR?maxL+<span class="number">1</span>:maxR+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<hr>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><p>堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一颗完全二叉树的数组对象</p>
<p><strong>堆的特性：</strong></p>
<p>1、它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层不满，则要求左满右不满</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220123162158170-16464424736501.png" alt="image-20220123162158170"></p>
<p>2、它通常是用数组来实现</p>
<p>具体方法就是将二叉树的结点按照层级顺序放入数组中</p>
<p><strong>如果一个结点为位置为k，则它的父结点则为【k&#x2F;2】，而它的两个子结点的位置则分别为【2k】和【2k+1】</strong></p>
<p>3、每个结点都大于等于它的两个子结点。虽然这样规定，但是子结点的位置顺序并没有规定</p>
<hr>
<h4 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h4><p><strong>insert插入方法的实现</strong></p>
<p>由于堆的定义是父结点大于两个子结点，且堆是由数组实现，所以在我们插入一个比父结点大的元素时就需要从插入元素的位置不断跟其父结点比较，如果父结点比子结点小则交换位置</p>
<p><strong>delMax删除最大元素方法的实现</strong></p>
<p>由于堆的定义，其根结点就是最大值，所以将其删除后将会导致堆的顺序变化，从而导致堆不符合定义；所以这时我们可以暂时把堆中最后一个元素拿出，并放到索引1处，然后使用下沉算法使堆有序</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items; <span class="comment">//用来存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N; <span class="comment">//记录堆中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建容量为capacity的Heap对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.items = (T[])<span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆中i索引和j索引处的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除堆中最大的元素，并返回这个最大元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换索引1处的元素和最大索引处的元素</span></span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除最大索引元素</span></span><br><span class="line">        items[N] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素个数减一</span></span><br><span class="line">        N--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让堆有序</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往堆中插入一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="comment">//索引0不使用</span></span><br><span class="line">        items[++N] = t;</span><br><span class="line">        <span class="comment">//使用上浮算法，使堆有序</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//不断比较当前结点和父结点的大小，如果父结点比子结点小，则交换位置</span></span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前结点和父结点的值</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k=k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//不断对比当前k结点和其子结点的较大值，如果当前结点小于子节点较大值，则交换位置</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)&#123;</span><br><span class="line">            <span class="comment">//获取当前结点的较大结点</span></span><br><span class="line">            <span class="type">int</span> max; <span class="comment">//记录较大结点所在的索引</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*k+<span class="number">1</span> &lt; N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span>*k,<span class="number">2</span>*k+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*k;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//比较当前结点和较大子结点的值</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换值</span></span><br><span class="line">            exch(k,max);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//变换k值</span></span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>实现步骤：</strong></p>
<p>1、构造堆</p>
<p>2、得到堆顶元素</p>
<p>3、交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置</p>
<p>4、对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶</p>
<p>5、重复2~4步骤，直到堆中剩余一个元素为止</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="comment">//对source数组中的数据从小到大排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] source)</span>&#123;</span><br><span class="line">        <span class="comment">//构建堆</span></span><br><span class="line">        Comparable[] heap = <span class="keyword">new</span> <span class="title class_">Comparable</span>[source.length+<span class="number">1</span>];</span><br><span class="line">        createHeap(source,heap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个变量，记录未排序的元素中最大的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> heap.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过循环，交换1索引处的元素和排序的元素中最大索引处的值</span></span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//交换元素</span></span><br><span class="line">            exch(heap,<span class="number">1</span>,N);</span><br><span class="line">            <span class="comment">//排序交换后最大元素所在的索引让其不再参加堆的下沉调整</span></span><br><span class="line">            N--;</span><br><span class="line">            <span class="comment">//需要对索引1处的元素进行堆的下沉调整</span></span><br><span class="line">            sink(heap,<span class="number">1</span>,N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把heap中数据复制到原数组source</span></span><br><span class="line">        System.arraycopy(heap,<span class="number">1</span>,source,<span class="number">0</span>,source.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据原数组source，构造出heap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createHeap</span><span class="params">(Comparable[] source, Comparable[] heap)</span>&#123;</span><br><span class="line">        <span class="comment">//把source中的元素拷贝到heap中，heap中的元素就形成一个无序的堆</span></span><br><span class="line">        System.arraycopy(source,<span class="number">0</span>,heap,<span class="number">1</span>,source.length);</span><br><span class="line">        <span class="comment">//对堆中的元素做下沉调整（从长度的一半处开始，往索引1处扫描）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (heap.length)/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            sink(heap,i,heap.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断heap堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i].compareTo(heap[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换heap中i索引和j索引处的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在heap中，对target处的元素做下沉，范围是0~range</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(Comparable[] heap, <span class="type">int</span> target, <span class="type">int</span> range)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*target&lt;=range)&#123;</span><br><span class="line">            <span class="comment">//1、找出当前结点的较大子结点</span></span><br><span class="line">            <span class="type">int</span> max;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span>*target+<span class="number">1</span>&lt;range)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(heap,<span class="number">2</span>*target,<span class="number">2</span>*target+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*target+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*target;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、比较当前结点的值和较大子结点的值</span></span><br><span class="line">            <span class="keyword">if</span> (!less(heap,target,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(heap,target,max);</span><br><span class="line">            target = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
