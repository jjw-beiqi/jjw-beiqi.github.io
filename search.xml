<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>/2022/03/24/ConcurrentHashMap/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2022/03/23/JMM/</url>
    <content><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java线程内存模型跟cpu缓存模型类似，是基于cpu缓存模型来建立的，Java线程内存模型是标准化的，屏蔽掉了底层不同计算机的区别</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/23/JMM/image-20220323101927305.png" alt="image-20220323101927305"></p>
<h2 id="Java原子操作详解"><a href="#Java原子操作详解" class="headerlink" title="Java原子操作详解"></a>Java原子操作详解</h2><ul>
<li>read(读取):从主内存读取数据</li>
<li>load（载入):将主内存读取到的数据写入工作内存</li>
<li>use(使用):从工作内存读取数据来计算</li>
<li>assign(赋值):将计算好的值重新赋值到工作内存中</li>
<li>store(存储):将工作内存数据写入主内存</li>
<li>write(写入):将store过去的变量值赋值给主内存中的变量</li>
<li>lock(锁定):将主内存变量加锁,标识为线程独占状态</li>
<li>unlock(解锁):将主内存变量解锁,解锁后其他线程可以锁定该变量</li>
</ul>
<p>情景：</p>
<p>线程一：拿到initFlag后，执行 <strong>while(!initFlag)</strong> 语句</p>
<p>线程二：拿到initFlag后，对其进行取反</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/23/JMM/image-20220323102645963.png" alt="image-20220323102645963"></p>
<p>结果：线程一死循环，线程二修改了共享变量的值</p>
<hr>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>解决上面的问题可以通过对共享变量加volatile关键字解决</p>
<h3 id="volatile概述"><a href="#volatile概述" class="headerlink" title="volatile概述"></a>volatile概述</h3><p>一个线程对volatile关键字修饰的共享变量副本进行修改后，会立马将修改后的值写入主内存中，其他的线程通过<strong>cpu总线嗅探机制</strong>监听到这个共享变量的值被修改过后，就会将自己线程工作内存中的共享变量副本失效掉，之后再使用的话就去主内存中取最新的值</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/23/JMM/image-20220323111142388.png" alt="image-20220323111142388"></p>
<hr>
<h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>底层实现主要是通过汇编lock前缀指令，它会锁定这块内存区域的缓存，并回写到主内存</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/23/JMM/image-20220323110053121.png" alt="image-20220323110053121"></p>
<p>Lock在具体的执行上，<strong>它先对总线和缓存加锁</strong>，然后<strong>执行后面的指令</strong>，在<strong>Lock锁住总线</strong>的时候，其他CPU的读写请求都会<strong>被阻塞</strong>，<strong>直到锁释放</strong>。最后<strong>释放锁后</strong>会把高速缓存中的脏数据全部<strong>刷新回主内存</strong>，且这个<strong>写回内存的操作</strong>会使在其他CPU里<strong>缓存了该地址的数据无效</strong>。</p>
<blockquote>
<h4 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h4><p>缓存是分段（line）的，一个段对应一块存储空间，我们称之为缓存行，它是CPU缓存中可分配的最小存储单元，大小32字节、64字节、128字节不等，这与CPU架构有关，通常来说是64字节。当CPU看到一条读取内存的指令时，它会把内存地址传递给一级数据缓存，一级数据缓存会检查它是否有这个内存地址对应的缓存段，如果没有就把整个缓存段从内存（或更高一级的缓存）中加载进来。</p>
</blockquote>
<blockquote>
<p>一个问题：如果存在两个线程都修改了共享变量，都要向主内存中写入的情况如何?</p>
</blockquote>
<hr>
<h3 id="volatile不能保证原子性"><a href="#volatile不能保证原子性" class="headerlink" title="volatile不能保证原子性"></a>volatile不能保证原子性</h3><p>情景：    </p>
<p>new出若干个线程，对volatile修饰的共享变量执行自增操作，结果并不能得到期望的值</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/23/JMM/image-20220323112531259.png" alt="image-20220323112531259"></p>
<p>原因：自增操作不是原子性的（先<strong>读取</strong>，再<strong>修改</strong>，最后<strong>写回工作内存</strong>）</p>
<p>A、B两个线程同时自增i。由于volatile可见性，因此步骤1两条线程一定拿到的是最新的i，也就是相同的i，但是从第2步开始就有问题了，有可能出现的场景是线程A自增了i并回写，但是线程B此时已经拿到了i，不会再去拿线程A回写的i，因此对原值进行了一次自增并回写，这就导致了线程非安全，也就是多线程技术器结果不对</p>
<p>如果线程A对i进行自增了以后cpu缓存不是应该通知其他缓存，并且重新load i么？</p>
<p>拿的前提是读，问题是，线程A对i进行了自增，线程B已经拿到了i并不存在需要再次读取i的场景，当然是不会重新load i这个值的。</p>
<p>ps：也就是线程B的缓存行内容的确会失效。但是此时线<strong>程B中i的值已经运行在加法指令中，不存在需要再次从缓存行读取i的场景。</strong></p>
<hr>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>查看如下代码，猜测a、b的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> y;</span><br><span class="line">                x = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> x;</span><br><span class="line">                y = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会觉得有三种结果</p>
<ul>
<li>a&#x3D;1，b&#x3D;0</li>
<li>a&#x3D;0，b&#x3D;1</li>
<li>a&#x3D;0，b&#x3D;0</li>
</ul>
<p>但其实还有一种结果：a&#x3D;1，b&#x3D;1；这是为什么呢？</p>
<p>这是因为cpu为了优化代码的执行速度可能会进行指令重排的操作，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>这两条代码并没有产生依赖，他们的顺序并不影响代码执行，则可能重排成如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b = <span class="number">2</span>;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这就是指令重排</p>
<p>而上述代码也可能存在指令重排，重排成如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程一</span></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程二</span></span><br><span class="line">y = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> x;</span><br></pre></td></tr></table></figure>

<p>这是导致 a&#x3D;1，b&#x3D;1 的原因</p>
<blockquote>
<p><strong>什么样的指令可以重排序？</strong></p>
<p>对cpu来说，基本上任何指令都可以实现重排序，因为这样可以提高性能，除了一些lock或禁止重排序的指令外。</p>
<p>对jvm来说，jvm规范中提到了happens-before原则，也就是不在下面8条原则中的指令都可以重排序：</p>
<ul>
<li>程序次序原则：在一个线程内，代码按照编写时的次序执行（jvm会对指令重排序，但是会保证最终一致性）。</li>
<li>锁定原则：如果一个锁是锁定状态，要先unlock后才能lock。</li>
<li>volatile变量规则：对变量的写操作要先于对变量的读操作。</li>
<li>传递规则：A先于B，B先于C，那么A先于C。</li>
<li>线程启动规则：线程的start()方法先于run()方法运行。</li>
<li>线程中断规则：线程收到了中断信号，那么之前一定有interrupt()。</li>
<li>线程终结规则：线程的任务执行单元要发生在线程死亡之前。</li>
<li>对象的终结规则：线程的初始化先于finalize()方法之前。</li>
</ul>
</blockquote>
<p><strong>解决：增加volatile关键字</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>被volatile修饰的变量在编译成字节码文件时会多个lock指令，该指令在执行过程中会生成相应的<strong>内存屏障</strong>，以此来解决可见性跟重排序的问题。</p>
<p>内存屏障的作用：</p>
<ul>
<li>在有内存屏障的地方，会禁止指令重排序，即屏障下面的代码不能跟屏障上面的代码交换执行顺序。</li>
<li>在有内存屏障的地方，线程修改完共享变量以后会马上把该变量从本地内存写回到主内存，<strong>并且让其他线程本地内存中该变量副本失效（使用MESI协议）</strong></li>
</ul>
<blockquote>
<p><strong>内存屏障</strong>是CPU指令。如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。</p>
<p>下面是基于保守策略的JMM内存屏障插入策略：</p>
<p>在每个volatile写操作的前面插入一个StoreStore屏障。</p>
<p>在每个volatile写操作的后面插入一个StoreLoad屏障。</p>
<p>在每个volatile读操作的前面插入一个LoadLoad屏障。</p>
<p>在每个volatile读操作的后面插入一个LoadStore屏障。</p>
</blockquote>
<p><img src="https://jjw-beiqi.github.io/2022/03/23/JMM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d0YWFhYQ==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>HideBlog</category>
      </categories>
      <tags>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>GCRoots</title>
    <url>/2022/03/26/GCRoots/</url>
    <content><![CDATA[<h2 id="面试题引子"><a href="#面试题引子" class="headerlink" title="面试题引子"></a>面试题引子</h2><p>一面：GC Roots如何确定？哪些对象可以作为GC Roots？</p>
<h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>简单说就是内存中已经不再被使用到的空间就是垃圾</p>
<h2 id="判断对象是否可以被回收之引用计数法"><a href="#判断对象是否可以被回收之引用计数法" class="headerlink" title="判断对象是否可以被回收之引用计数法"></a>判断对象是否可以被回收之引用计数法</h2><p>Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器，每当有一个地方引用它，计数器值加1，每当有一个引用失效时，计数器值减1。</p>
<p>任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。</p>
<p>那为什么主流的Java虚拟机里面都没有选用这种算法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
<p><img src="https://img-blog.csdnimg.cn/20190530212448903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkxMDY5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="判断对象是否可以被回收之枚举根节点可达性分析"><a href="#判断对象是否可以被回收之枚举根节点可达性分析" class="headerlink" title="判断对象是否可以被回收之枚举根节点可达性分析"></a>判断对象是否可以被回收之枚举根节点可达性分析</h2><p>为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。所谓”GCroots，或者说tracingGC的“根集合”就是一组必须活跃的引用。</p>
<p>基本思路就是通过一系列名为”GCRoots”的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GCRoots没有任何引用链相连时，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的就自然被判定为死亡。</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/26/GCRoots/20190530212914540.png" alt="在这里插入图片描述"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/26/GCRoots/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkxMDY5NA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<h2 id="Java中可以作为GC-Roots的对象"><a href="#Java中可以作为GC-Roots的对象" class="headerlink" title="Java中可以作为GC Roots的对象"></a>Java中可以作为GC Roots的对象</h2><ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的native方法）中引用的对象</li>
</ul>
<p>转载自:<a href="https://blog.csdn.net/weixin_41910694/article/details/90706652">https://blog.csdn.net/weixin_41910694/article/details/90706652</a></p>
]]></content>
      <tags>
        <tag>GCRoots</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate学习笔记</title>
    <url>/2022/03/29/Hibernate/</url>
    <content><![CDATA[<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><p>1、引入依赖：<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220225140049060.png" alt="image-20220225140049060"></p>
<p>2、创建Hibernate配置文件</p>
<p><strong>对于java项目必须放在根目录下</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hibernate.cfg.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span> <span class="string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 配置dateSource --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.driver_class&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.url&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/for_test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 是否展示sql语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;com/bean/Customer.xml&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3、创建HibernateUtil工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HibernateUtil</span></span><br><span class="line"><span class="keyword">package</span> com.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.MetadataSources;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistry;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HibernateUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">StandardServiceRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardServiceRegistryBuilder</span>().configure().build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sessionFactory = <span class="keyword">new</span> <span class="title class_">MetadataSources</span>(registry).buildMetadata().buildSessionFactory();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            StandardServiceRegistryBuilder.destroy(registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title function_">openSession</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        sessionFactory.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实体类映射文件 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">hibernate-mapping</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.bean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name:对应类名  table:对应表名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Customer&quot;</span> <span class="attr">table</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- name:指定类中定义的属性名  column:指定表中主键名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- id和property元素位置不能颠倒 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">package</span> com.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.bean.Customer;</span><br><span class="line"><span class="keyword">import</span> com.util.HibernateUtil;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HibernateTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="number">3</span>,<span class="string">&quot;jjw2&quot;</span>);</span><br><span class="line">        saveCustomer(customer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveCustomer</span><span class="params">(Customer c)</span>&#123;</span><br><span class="line">        <span class="comment">//获取数据库会话</span></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> HibernateUtil.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tran</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入数据</span></span><br><span class="line">        session.save(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        tran.commit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="单实体映射"><a href="#单实体映射" class="headerlink" title="单实体映射"></a>单实体映射</h2><h3 id="对象-关系映射文件"><a href="#对象-关系映射文件" class="headerlink" title="对象-关系映射文件"></a>对象-关系映射文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.bean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span>&gt;</span><span class="tag">&lt;/<span class="name">class</span>&gt;</span> 用于指定类和表之间的映射</span><br><span class="line"><span class="comment">&lt;!-- name 设定类名 </span></span><br><span class="line"><span class="comment">	 table 设定表名，默认以类名作为表名 </span></span><br><span class="line"><span class="comment">	 包含一个&lt;id&gt;以及多个&lt;property&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span> 设定持久化类的 OID（对象标识符） 和表的主键的映射关系。</span><br><span class="line"><span class="comment">&lt;!-- name 指定类的属性</span></span><br><span class="line"><span class="comment">	 column 指定字段的名称</span></span><br><span class="line"><span class="comment">	 generator 元素指定OID （设置自增之类的）--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> 设定类的其它属性和表的字段的映射关系。</span><br><span class="line"><span class="comment">&lt;!-- name 对应类的属性名</span></span><br><span class="line"><span class="comment">	 type 指定属性的类型</span></span><br><span class="line"><span class="comment">	 column 指定表字段的名称</span></span><br><span class="line"><span class="comment">	 not-null 指定属性是否允许为空 --&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="单实体的属性映射"><a href="#单实体的属性映射" class="headerlink" title="单实体的属性映射"></a>单实体的属性映射</h3><p><strong>property的属性</strong></p>
<p>在对象-关系映射文件中<property>元素的 access 属性用于指定Hibernate访问持久化类属性的方式</property></p>
<ul>
<li>property : 默认值，通过getter（增删改）和setter（查）方法访问属性值；</li>
<li>field : 通过Java反射机制直接访问属性值。</li>
</ul>
<p><strong>场景：当持久化类属性与数据库字段不对称时，可以利用access属性调用对应的getter、setter方法</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220227194456144.png" alt="image-20220227194456144"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> firstName + <span class="string">&quot;&quot;</span> +lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">	String[] strName = userName.split(<span class="string">&quot;&quot;</span>);<span class="built_in">this</span>.firstName = strName[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">this</span>.lastName = strName[<span class="number">1</span>];</span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//映射文件中映射的是通过 getUserName 方法名中的 Username 字段查找到这个set方法的，而不是通过 username 属性！！！</span></span><br></pre></td></tr></table></figure>



<p><strong>场景：User 需要订单总额属性，但数据库表中没有这个字段。可在<property>元素的 formula 属性设置查询语句（formula属性仅在查询操作中起作用）</property></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;totalPrice&quot;</span>                  </span></span><br><span class="line"><span class="tag">          <span class="attr">formula</span>=<span class="string">&quot;(select sum(o.price) from </span></span></span><br><span class="line"><span class="string"><span class="tag">                   orders as o where o.userId=id)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>控制持久化类的insert和update</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220227200456769.png" alt="image-20220227200456769"></p>
<p>这些属性用于控制insert和update，例如update&#x3D;”false”时，不更新这个字段 ，dynamic-update&#x3D;”true”时，当执行更新操作时，如果设置的属性为null则不改变之前的值，<strong>但是使用dynamic-update&#x3D;”true”的前提是先获取一次这个数据到缓存中，才能用新的数据对比缓存中的数据，进而修改不需要改变的数据</strong></p>
<h3 id="单实体的对象标识符映射"><a href="#单实体的对象标识符映射" class="headerlink" title="单实体的对象标识符映射"></a>单实体的对象标识符映射</h3><p>Hibernate 采用对象标识符（OID）区分对象。</p>
<ul>
<li><p>OID 是关系数据库中主键（通常是代理主键）在 Java 对象模型中的等价物；</p>
</li>
<li><p>Hibernate 采用 OID 来维持java对象和数据库表中对应关系。</p>
</li>
</ul>
<p>Hibernate 自带了很多种标识符生成器</p>
<ul>
<li>increment  采用 Hibernate 数值递增的方式；</li>
<li>identity 采用数据库提供的自增长方式；</li>
<li>assigned 主键由应用逻辑产生；</li>
<li>sequence 采用数据库提供的序列方式；</li>
<li>hilo 通过hi&#x2F;lo算法   &#x2F;&#x2F; Hibernate 5.0 以后不支持；</li>
<li>seqhilo 通过hi&#x2F;lo算法；</li>
<li>native 自动选择合适的标识符生成器；</li>
<li>uuid.hex 通过uuid算法。</li>
</ul>
<h3 id="使用注解映射单实体"><a href="#使用注解映射单实体" class="headerlink" title="使用注解映射单实体"></a>使用注解映射单实体</h3><ul>
<li><p>@Entity：声明一个实体</p>
</li>
<li><p>@Table(name&#x3D;”table_name”)：为实体类指定对应的数据库表。</p>
</li>
<li><p>@Id：声明实体类的OID属性。</p>
</li>
<li><p>@GeneratedValue(generator&#x3D;”increment_generator”)：声明OID的生成策略。（JPA通用注解）</p>
</li>
<li><p>@GenericGenerator(name&#x3D;”increment_generator”, strategy&#x3D;”increment”)：使用Hibernate提供的生成策略</p>
</li>
<li><p>@Column(name&#x3D;”columnName”) ：将属性映射到列。</p>
<ul>
<li><p><strong>这个类只标明了他是一个注解类，并且主键是自增长的，然而其他的一些属性并没有配置注解，那么他一样会在数据库的表中存在，因为这些属性默认就有@Column注解。因此如果没有添加注解，则hibernate会自动在属性前面添加@Column注解。</strong></p>
</li>
<li><p>name&#x3D;”columnName”    字段名称；</p>
</li>
<li><p>unique&#x3D;false            是否在该字段上设置唯一约束；</p>
</li>
<li><p>nullable&#x3D;true            字段是否能为空；</p>
</li>
<li><p>insertable&#x3D;true        控制 insert语句；</p>
</li>
<li><p>updatable&#x3D;true        控制 update语句；</p>
</li>
<li><p>length&#x3D;255            指定字段长度。</p>
</li>
</ul>
</li>
<li><p>@Access(AccessType.PROPERTY)：</p>
<ul>
<li>通过 getter 和 setter 方法访问实体类的属性；</li>
<li>需要在 getter 方法上定义字段的属性</li>
</ul>
</li>
<li><p>@Access(AccessType.FIELD)：</p>
<ul>
<li>直接访问实体类的属性，可以不定义 getter 和 setter 方法；</li>
<li>需要在变量上定义字段的属性。</li>
</ul>
</li>
<li><p>@Formula：将属性映射到SQL语句。</p>
</li>
<li><p>@DynamicInsert：动态生成 INSERT 语句。</p>
</li>
<li><p>@DynamicUpdate：动态生成 UPDATE 语句。</p>
</li>
</ul>
<p>注意：</p>
<p>对于属性字段和表的字段关系对应的注解属性的位置，一般我们采用以下两种方式</p>
<p><strong>第一种：</strong>是把注解@Column(name &#x3D;”xx”)放在field上</p>
<p><strong>第二种：</strong>是把注解@Column(name&#x3D; “xx”)放在get方法上</p>
<p><strong>但是第一种方式这样做实际上破坏了java面向对象的封装性</strong>，原因是一般我们写javaBean，成员变量通常定义为private，目的就是不让别人来直接访问的私有属性，而我们把注解放在私有成员的变量上，就是默认hibernate可以直接访问我们的私有的成员变量，所以我们定义属性为private，就实际没有多大意义，至于hibernate为什么能访问，hibernate采用java的反射机制完全可以访问私有成员变量！<strong>所以应该放在get方法上，第二种方式这个时候就显得更加合理。</strong></p>
<hr>
<h2 id="Hibernate继承关系映射"><a href="#Hibernate继承关系映射" class="headerlink" title="Hibernate继承关系映射"></a>Hibernate继承关系映射</h2><p><strong>场景：现要为某公司开发一个员工信息管理系统，已经了解到该公司的员工中有按小时计薪和按月计薪两种方式，这种情况下系统中该如何维护员工的基本信息呢？</strong></p>
<p>三种不同的解决方案：</p>
<p>一方案：</p>
<ul>
<li>关系数据模型不支持域模型中的继承关系和多态。</li>
<li>每个子类所对应的表中同时存在从父类继承的属性和自己特有的属性。</li>
<li>如果父类不是抽象类并且也需要被持久化，还需要为父类创建对应的表。</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220228185931662.png" alt="image-20220228185931662"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220228192235782.png" alt="image-20220228192235782"></p>
<p><strong>映射文件形式</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HourlyEmployee.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;HourlyEmployee&quot;</span> <span class="attr">table</span>=<span class="string">&quot;HOURLYEMPLOYEE&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span> <span class="comment">&lt;!-- 父类属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;increment&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rate&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SalariedEmployee.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;SalariedEmployee&quot;</span> <span class="attr">table</span>=<span class="string">&quot;SALARIEDEMPLOYEE&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span> <span class="comment">&lt;!-- 父类属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;increment&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;salary&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p><strong>注解形式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span> </span><br><span class="line"><span class="meta">@Table(name=&quot;HourlyEmployee&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HourlyEmployee</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String rate;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span> </span><br><span class="line"><span class="meta">@Table(name=&quot;SalariedEmployee&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalariedEmployee</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String salary;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Employee基类</p>
<p>1.标注为@MappedSuperclass的类将不是一个完整的实体类，他将不会映射到数据库表，但是他的属性都将映射到其子类的数据库字段中。</p>
<p>2.标注为@MappedSuperclass的类不能再标注@Entity或@Table注解，也无需实现序列化接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span> <span class="comment">//表明这是一个父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">	<span class="meta">@Id</span> </span><br><span class="line">    <span class="meta">@GeneratedValue</span>   </span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.id = id; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方案二：</p>
<ul>
<li>关系数据模型支持继承关系和多态。</li>
<li>在表中加入额外的字段区分子类的类型，表中包含父类和所有子类的属性对应的字段。</li>
<li>支持多态查询，就是从数据库中检索父类对象时，同时包含所有子类的对象。</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220228192309890.png" alt="image-20220228192309890"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220228192257132.png" alt="image-20220228192257132"></p>
<p>在数据库表中会有这样的一个字段用来区别记录的属性，如：在客户表中有一个字段表示客户级别，当这个记录为A时是一级客户，为B时是二级客户；然后，在程序中手动控制flag的值，<strong>但是这样当每个级的客户有不同的属性时Customer类将包含所有级别的属性</strong>，这样不是很好。</p>
<p>hibernate提供一个Discriminator映射的方法，<strong>就是把一个表映射成不同的类，有不同的属性</strong>。</p>
<p><strong>xml文件方式</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Employee.xml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果 Employees 本身也需要被持久化，可以在&lt;class&gt;元素中设置 discriminator-value 属性的值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Employee&quot;</span> <span class="attr">table</span>=<span class="string">&quot;EMPLOYEE&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;increment&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">column</span>=<span class="string">&quot;EMPLOYEETYPE&quot;</span> /&gt;</span>  <span class="comment">&lt;!-- 公共属性的映射，用来标明不同的子类，必须紧跟id元素 --&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- discriminator-value 属性：子类中区分类型字段的取值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subclass</span> <span class="attr">name</span>=<span class="string">&quot;HourlyEmployees&quot;</span> <span class="attr">discriminator-value</span>=<span class="string">&quot;HE&quot;</span>&gt;</span> <span class="comment">&lt;!-- HourlyEmployees特有属性的映射</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rate&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">subclass</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- discriminator-value 属性：子类中区分类型字段的取值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subclass</span> <span class="attr">name</span>=<span class="string">&quot;SalariedEmployees&quot;</span> <span class="attr">discriminator-value</span>=<span class="string">&quot;SE&quot;</span>&gt;</span> <span class="comment">&lt;!-- SalariedEmployees特有属性的映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;salary&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">subclass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>注解形式</strong></p>
<p>Employee基类</p>
<p>指定继承关系的生成策略</p>
<p>@Inheritance(strategy&#x3D;InheritanceType.SINGLE_TABLE)</p>
<p>指定区分子类类型的字段。</p>
<p> @DiscriminatorColumn(name&#x3D;”EMPLOYEETYPE”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;employee&quot;)</span></span><br><span class="line"><span class="comment">//继承关系的生成策略</span></span><br><span class="line"><span class="meta">@Inheritance(strategy=InheritanceType.SINGLE_TABLE)</span></span><br><span class="line"><span class="comment">//映射额外字段</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn(name=&quot;employee_type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span><span class="comment">//自增</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>各个子类使用注解：</p>
<p>指定各个子类区分字段的值。</p>
<p>@DiscriminatorValue(value &#x3D; “”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorValue(value=&quot;HE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HourlyEmployee</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> rate;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>方案三：</p>
<ul>
<li>在关系数据模型中，用外键参照关系来表示继承关系，子类对应的表中存在外键参照父类对应表的主键。</li>
<li>继承关系中的每个类及接口都对应一个表。</li>
<li>支持多态查询。</li>
</ul>
<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220301194313368-16472375976007.png" alt="image-20220301194313368" style="zoom:50%;">

<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220301194405032.png" alt="image-20220301194405032" style="zoom:50%;">



<p><strong>xml文件形式</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Employee&quot;</span> <span class="attr">table</span>=<span class="string">&quot;EMPLOYEE&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;increment&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joined-subclass</span> <span class="attr">name</span>=<span class="string">&quot;HourlyEmployee&quot;</span> <span class="attr">table</span>=<span class="string">&quot;HOURLYEMPLOYEE&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name 属性：子类类名；</span></span><br><span class="line"><span class="comment">		table 属性：子类对应的数据库表；</span></span><br><span class="line"><span class="comment">		&lt;key&gt; 子元素：指定子类对应表的主键列；</span></span><br><span class="line"><span class="comment">		&lt;property&gt; 子元素：映射子类的属性。</span></span><br><span class="line"><span class="comment"> 	--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;EMPLOYEEID&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 代表一个外键 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rate&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joined-subclass</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">joined-subclass</span> <span class="attr">name</span>=<span class="string">&quot;SalariedEmployee&quot;</span> <span class="attr">table</span>=<span class="string">&quot;SALARIEDEMPLOYEE&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;EMPLOYEEID&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 代表一个外键 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;salary&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joined-subclass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p><strong>注解形式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//映射基类</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;employee&quot;)</span></span><br><span class="line"><span class="comment">//继承关系的生成策略</span></span><br><span class="line"><span class="meta">@Inheritance(strategy=InheritanceType.JOINED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span><span class="comment">//自增</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;hourly_employee&quot;)</span></span><br><span class="line"><span class="comment">//映射主键字段（既是主键又是外键）</span></span><br><span class="line"><span class="meta">@PrimaryKeyJoinColumn(name=&quot;employee_id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HourlyEmployee</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Hibernate一对一关联映射"><a href="#Hibernate一对一关联映射" class="headerlink" title="Hibernate一对一关联映射"></a>Hibernate一对一关联映射</h2><p>参考：<a href="https://www.cnblogs.com/whgk/p/6128395.html">https://www.cnblogs.com/whgk/p/6128395.html</a></p>
<h3 id="一对一关系映射"><a href="#一对一关系映射" class="headerlink" title="一对一关系映射"></a>一对一关系映射</h3><ul>
<li><p>定义</p>
<p>如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1:1 。</p>
</li>
<li><p>实例<br>一个班级只有一个正班长。<br>一个正班长只在一个班中任职</p>
</li>
</ul>
<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220301200035389-16472376083238.png" alt="image-20220301200035389" style="zoom:50%;">



<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String idNumber;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Hibernate提供两种映射一对一关联关系的方式：</strong></p>
<ul>
<li>主键关联映射</li>
</ul>
<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220301200225127.png" alt="image-20220301200225127" style="zoom:50%;">



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!---------- Person -----------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.hibernate.entity&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- name指定类名  table指定表名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">table</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 必须的，映射id属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;person_id&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 生成策略 foreign:主键也是外键--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;foreign&quot;</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 参数指定参照的主键字段，表明参照哪个类的主键 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;property&quot;</span>&gt;</span>user<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 映射其他属性 字段名和属性名不一致是不能省略column--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;property name=&quot;userName&quot; column=&quot;user_name&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- access=&quot;field&quot;不访问属性的getter、setter方法 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- not-null=&quot;true&quot;表示不能为空 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;idNumber&quot;</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- user属性的映射：Person与User之间的一对一关联关系</span></span><br><span class="line"><span class="comment">		constrained=&quot;true&quot;表示表中存在约束关系，？主键映射外键 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;User&quot;</span> <span class="attr">constrained</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!---------- User -----------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.hibernate.entity&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- name指定类名  table指定表名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 必须的，映射id属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 生成策略 identity:使用底层数据库的自动递增 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 映射其他属性 字段名和属性名不一致是不能省略column--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;property name=&quot;userName&quot; column=&quot;user_name&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- access=&quot;field&quot;不访问属性的getter、setter方法 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> &gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">&quot;user_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- not-null=&quot;true&quot;表示不能为空 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- person属性的映射：User与Person之间的一对一关联关系 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 关联映射中cascade属性：级联操作：在操作用户对象的同时，操作关联的Person对象</span></span><br><span class="line"><span class="comment">		                   none：所有操作都不级联</span></span><br><span class="line"><span class="comment">		                   save-update:插入、更新级联</span></span><br><span class="line"><span class="comment">		                   delete:删除级联</span></span><br><span class="line"><span class="comment">		                   all:所有操作级联 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">cascade</span>=<span class="string">&quot;all&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-one</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询出已经存在的用户</span></span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> session.get(User.class, id);</span><br><span class="line"><span class="comment">//给用户绑定实名信息</span></span><br><span class="line">u.setPerson(p); 	<span class="comment">//给user绑定person</span></span><br><span class="line">p.setUser(u);		<span class="comment">//person在插入时就能依照user这个外键进行插入了</span></span><br><span class="line">session.save(p);</span><br></pre></td></tr></table></figure>



<p><strong>级联操作（保存为例）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;8888888&quot;</span>);</span><br><span class="line">      <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      p.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">      p.setIdNumber(<span class="string">&quot;1111111&quot;</span>);</span><br><span class="line">      <span class="comment">// 建立关联关系</span></span><br><span class="line">      u.setPerson(p);</span><br><span class="line">      p.setUser(u);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Session对象</span></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> HibernateUtil.openSession();</span><br><span class="line"><span class="comment">// 开启数据库事务</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">tran</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">session.save(u); <span class="comment">//同时会保存person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交数据库事务</span></span><br><span class="line">tran.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭Session</span></span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure>



<ul>
<li>唯一外键关联映射<ul>
<li>外键必须设定 unique 约束</li>
</ul>
</li>
</ul>
<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220305162102873-16464684654571.png" alt="image-20220305162102873" style="zoom:50%;">



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!---------- Person -----------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.hibernate.entity&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- name指定类名  table指定表名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">table</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 必须的，映射id属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;person_id&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 生成策略 foreign:主键也是外键--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;foreign&quot;</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 参数指定参照的主键字段 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;property&quot;</span>&gt;</span>user<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 映射其他属性 字段名和属性名不一致是不能省略column--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;property name=&quot;userName&quot; column=&quot;user_name&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- access=&quot;field&quot;不访问属性的getter、setter方法 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- not-null=&quot;true&quot;表示不能为空 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;idNumber&quot;</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- user属性的映射：Person与User之间的一对一关联关系</span></span><br><span class="line"><span class="comment">		property-ref=&quot;person&quot;表示建立双向一对一 ，表示user里的person就是当前这个person--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;User&quot;</span> <span class="attr">property-ref</span>=<span class="string">&quot;person&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!---------- User -----------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.hibernate.entity&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- name指定类名  table指定表名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 必须的，映射id属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 生成策略 identity:使用底层数据库的自动递增 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 映射其他属性 字段名和属性名不一致是不能省略column--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;property name=&quot;userName&quot; column=&quot;user_name&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- access=&quot;field&quot;不访问属性的getter、setter方法 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> &gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">&quot;user_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- not-null=&quot;true&quot;表示不能为空 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- person属性的映射：User与Person之间的一对一关联关系 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 唯一外键关联是多对一关联的一种特殊情况：在外键字段上加唯一约束 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 关联映射中column属性指定外键字段</span></span><br><span class="line"><span class="comment">		cascade属性：级联操作：在操作用户对象的同时，操作关联的Person对象</span></span><br><span class="line"><span class="comment">		                   none：所有操作都不级联</span></span><br><span class="line"><span class="comment">		                   save-update:插入、更新级联</span></span><br><span class="line"><span class="comment">		                   delete:删除级联</span></span><br><span class="line"><span class="comment">		                   all:所有操作级联 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示这个person与user有一对一关系，person的主键是user的外键 --&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">one-to-one</span> <span class="attr">name</span>=<span class="string">&quot;person&quot;</span> <span class="attr">column</span>=<span class="string">&quot;per_id&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">unique</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>级联操作（保存为例）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User u, Person p)</span> &#123;</span><br><span class="line">	<span class="comment">// 获取Session对象</span></span><br><span class="line">	<span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> HibernateUtil.openSession();</span><br><span class="line">	<span class="comment">// 开启数据库事务</span></span><br><span class="line">	<span class="type">Transaction</span> <span class="variable">tran</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立关联关系</span></span><br><span class="line">	u.setPerson(p);</span><br><span class="line">	p.setUser(u);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 保存</span></span><br><span class="line">	session.save(u);</span><br><span class="line">	session.save(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提交数据库事务</span></span><br><span class="line">	tran.commit();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭Session</span></span><br><span class="line">	session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>使用注解映射主键关联的一对一</strong></p>
<ul>
<li>主键关联映射</li>
</ul>
<p>@OneToOne(cascade&#x3D;CascadeType.ALL) &#x2F;&#x2F;指定一对一关系，并设置级联属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> Person person;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//targetEntity可以省略</span></span><br><span class="line">	<span class="comment">//CascadeType.PERSIST级联保存</span></span><br><span class="line">	<span class="comment">//CascadeType.MERGE更新</span></span><br><span class="line">	<span class="comment">//CascadeType.REMOVE删除</span></span><br><span class="line">	<span class="comment">//cascade=CascadeType.ALL所有操作</span></span><br><span class="line">	<span class="meta">@OneToOne(targetEntity=Person.class, cascade=CascadeType.REMOVE)</span></span><br><span class="line">	<span class="meta">@PrimaryKeyJoinColumn(name=&quot;person_id&quot;)</span><span class="comment">//person表中既是主键又是外键的字段</span></span><br><span class="line">	<span class="keyword">public</span> Person <span class="title function_">getPerson</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> person;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPerson</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.person = person;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//与数据库表不对应时必须加上</span></span><br><span class="line">    <span class="meta">@Column(name=&quot;user_name&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> userName;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;person&quot;)</span><span class="comment">//如果表名与实体类类名一致该注解可省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String idNumber;</span><br><span class="line">	<span class="keyword">private</span> User user;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">    <span class="comment">//在JPA通用注解中使用我们在Hibernate中自定的Hibernate生成策略</span></span><br><span class="line">	<span class="meta">@GeneratedValue(generator=&quot;my_gen&quot;)</span></span><br><span class="line">    <span class="comment">//name 起别名 </span></span><br><span class="line">    <span class="comment">//strategy Hibernate中的生成策略</span></span><br><span class="line">	<span class="meta">@GenericGenerator(name=&quot;my_gen&quot;, strategy=&quot;foreign&quot;,</span></span><br><span class="line"><span class="meta">     /* 设置参数 */                 </span></span><br><span class="line"><span class="meta">	 parameters= &#123;@Parameter(value=&quot;user&quot;,name=&quot;property&quot;)&#125;)</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//mappedBy=&quot;person&quot;表示关联关系已经在User类的person属性上进行了映射</span></span><br><span class="line">    <span class="comment">//不需要再用@PrimaryKeyJoinColumn注解进行映射</span></span><br><span class="line">    <span class="comment">//相对应的，如果在person类中使用了@PrimaryKeyJoinColumn，在user类中也不需要</span></span><br><span class="line">	<span class="meta">@OneToOne(mappedBy=&quot;person&quot;,targetEntity=User.class)</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>唯一外键关联映射</li>
</ul>
<p>@OneToOne(cascade&#x3D;CascadeType.ALL)</p>
<p>@JoinColumn(name&#x3D;”PERSONID”)：指明USER表中的外键列名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> Person person;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@OneToOne</span></span><br><span class="line">	<span class="meta">@JoinColumn(name=&quot;per_id&quot;)</span><span class="comment">//映射外键字段</span></span><br><span class="line">	<span class="keyword">public</span> Person <span class="title function_">getPerson</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> person;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Column(name=&quot;user_name&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> userName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;person&quot;)</span><span class="comment">//如果表名与实体类类名一致该注解可省略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String idNumber;</span><br><span class="line">	<span class="keyword">private</span> User user;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@OneToOne(mappedBy=&quot;person&quot;)</span><span class="comment">//不需要重复映射外键字段</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="组合关系映射"><a href="#组合关系映射" class="headerlink" title="组合关系映射"></a>组合关系映射</h3><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220305202114172.png" alt="image-20220305202114172" style="zoom:50%;">            

<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220305202439841.png" alt="image-20220305202439841" style="zoom:50%;">



<p><strong>xml映射文件方式</strong></p>
<p>Address类不能持久化</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.hibernate.entity&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 组合关系中的整体类的映射 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Contact&quot;</span> <span class="attr">table</span>=<span class="string">&quot;contact&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;phoneNum&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 映射组合关系 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;homeAddress&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Address&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 映射部分类中定义的属性 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;province&quot;</span> <span class="attr">column</span>=<span class="string">&quot;home_pro&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span> <span class="attr">column</span>=<span class="string">&quot;home_city&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;workAddress&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Address&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 映射部分类中定义的属性 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;province&quot;</span> <span class="attr">column</span>=<span class="string">&quot;work_pro&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span> <span class="attr">column</span>=<span class="string">&quot;work_city&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">Address</span> <span class="variable">home</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">		home.setProvince(<span class="string">&quot;河北省&quot;</span>);</span><br><span class="line">		home.setCity(<span class="string">&quot;邯郸市&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Address</span> <span class="variable">work</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">		work.setProvince(<span class="string">&quot;河北省&quot;</span>);</span><br><span class="line">		work.setCity(<span class="string">&quot;石家庄市&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Contact</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>();</span><br><span class="line">		c.setPhoneNum(<span class="string">&quot;15000001222&quot;</span>);</span><br><span class="line">		c.setHomeAddress(home);</span><br><span class="line">		c.setWorkAddress(work);</span><br><span class="line">		</span><br><span class="line">		saveContact(c);</span><br><span class="line">		</span><br><span class="line">		HibernateUtil.closeSessionFactory();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveContact</span><span class="params">(Contact c)</span> &#123;</span><br><span class="line">		<span class="comment">// 获取Session对象</span></span><br><span class="line">		<span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> HibernateUtil.openSession();</span><br><span class="line">		<span class="comment">// 开启数据库事务</span></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">tran</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 保存</span></span><br><span class="line">		session.save(c);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 提交数据库事务</span></span><br><span class="line">		tran.commit();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关闭Session</span></span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>注解方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embedded</span></span><br><span class="line"><span class="meta">@AttributeOverrides(value=&#123;</span></span><br><span class="line"><span class="meta">    @AttributeOverride(</span></span><br><span class="line"><span class="meta">        name = &quot;province&quot;, </span></span><br><span class="line"><span class="meta">        column = @Column(name=“HOMEPROVINCE&quot;)),</span></span><br><span class="line"><span class="meta">    @AttributeOverride(</span></span><br><span class="line"><span class="meta">        name = &quot;city&quot;,</span></span><br><span class="line"><span class="meta">        column = @Column(name=“HOMECITY&quot;)),</span></span><br><span class="line"><span class="meta">    ......</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Contact</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Hibernate一对多关联映射"><a href="#Hibernate一对多关联映射" class="headerlink" title="Hibernate一对多关联映射"></a>Hibernate一对多关联映射</h2><ul>
<li><strong>单向一对多</strong></li>
</ul>
<p><strong>xml映射文件</strong></p>
<p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Set</span> <span class="variable">orderSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Order&gt;();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id; </span><br><span class="line">    <span class="keyword">private</span> Double price; <span class="comment">// 价格</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!------- user --------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.hibernate.entity&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- name指定类名  table指定表名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 必须的，映射id属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 生成策略 identity:使用底层数据库的自动递增 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- not-null=&quot;true&quot;表示不能为空 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">not-null</span>=<span class="string">&quot;true&quot;</span> <span class="attr">length</span>=<span class="string">&quot;11&quot;</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 使用set元素映射Set类型的属性;无序，不可重复 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">cascade</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 映射外键字段 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span> <span class="comment">&lt;!-- 订单表的外键字段 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">&quot;Order&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 使用list元素映射list类型的属性；有序，可重复 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;list name=&quot;orders&quot; &gt;</span></span><br><span class="line"><span class="comment">			映射外键字段</span></span><br><span class="line"><span class="comment">			&lt;key column=&quot;user_id&quot;&gt;&lt;/key&gt; 订单表的外键字段 </span></span><br><span class="line"><span class="comment">           	 映射保存订单顺序的额外字段 </span></span><br><span class="line"><span class="comment">             &lt;index column=&quot;order_index&quot;/&gt;</span></span><br><span class="line"><span class="comment">			&lt;one-to-many class=&quot;Order&quot;/&gt;</span></span><br><span class="line"><span class="comment">		&lt;/list&gt; --&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 使用map元素映射list类型的属性；无序，不可重复,key/value存储 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;map name=&quot;orders&quot; &gt;</span></span><br><span class="line"><span class="comment">			映射外键字段</span></span><br><span class="line"><span class="comment">			&lt;key column=&quot;user_id&quot;&gt;&lt;/key&gt; 订单表的外键字段 </span></span><br><span class="line"><span class="comment">           	 映射保存订单key的额外字段，type=&quot;string&quot;不能省略</span></span><br><span class="line"><span class="comment">             &lt;index column=&quot;order_key&quot; type=&quot;string&quot;/&gt;</span></span><br><span class="line"><span class="comment">			&lt;one-to-many class=&quot;Order&quot;/&gt;</span></span><br><span class="line"><span class="comment">		&lt;/map&gt; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!------- order --------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.hibernate.entity&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Order&quot;</span> <span class="attr">table</span>=<span class="string">&quot;orders&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orderNum&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Order</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">		o.setOrderNum(<span class="string">&quot;QW121212121212121&quot;</span>);</span><br><span class="line">		o.setPrice(<span class="number">100.0</span>);</span><br><span class="line">		</span><br><span class="line">		saveOrder(<span class="number">111</span>, o);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		HibernateUtil.closeSessionFactory();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 已经注册的用户添加订单</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveOrder</span><span class="params">(Integer userId,Order o)</span> &#123;</span><br><span class="line">		<span class="comment">// 获取Session对象</span></span><br><span class="line">		<span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> HibernateUtil.openSession();</span><br><span class="line">		<span class="comment">// 开启数据库事务</span></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">tran</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//查询用户</span></span><br><span class="line">		<span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> session.get(User.class, userId);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//给用户添加订单</span></span><br><span class="line"></span><br><span class="line">		u.getOrders().add(o);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 保存</span></span><br><span class="line">		session.save(o);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 提交数据库事务</span></span><br><span class="line">		tran.commit();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关闭Session</span></span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<ul>
<li>双向一对多</li>
</ul>
<p><strong>xml文件形式</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!------- order --------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.hibernate.entity&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;Order&quot;</span> <span class="attr">table</span>=<span class="string">&quot;orders&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orderNum&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;User&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">         </span><br></pre></td></tr></table></figure>



<p><strong>注解形式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;orders&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String orderNum;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">	<span class="keyword">private</span> User user;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//映射多对一关联</span></span><br><span class="line">	<span class="meta">@ManyToOne(targetEntity=User.class)</span></span><br><span class="line">	<span class="comment">//映射外键字段</span></span><br><span class="line">	<span class="meta">@JoinColumn(name=&quot;user_id&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Order&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span></span><br><span class="line">	<span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//映射一对多关系:targetEntity需要添加</span></span><br><span class="line">	<span class="comment">//mappedBy=&quot;user&quot;表示外键已经映射在Order类定义的user属性</span></span><br><span class="line">	<span class="comment">//作为User一方，不再去维护关联关系：不关注外键字段的赋值</span></span><br><span class="line">	<span class="meta">@OneToMany(targetEntity=Order.class,</span></span><br><span class="line"><span class="meta">			cascade=CascadeType.REMOVE,</span></span><br><span class="line"><span class="meta">			mappedBy=&quot;user&quot; /*表示在另一头的user属性中已经映射了*/)</span> </span><br><span class="line"><span class="comment">//	@JoinColumn(name=&quot;user_id&quot;)//映射外键字段</span></span><br><span class="line">	<span class="keyword">public</span> Set&lt;Order&gt; <span class="title function_">getOrders</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> orders;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrders</span><span class="params">(Set&lt;Order&gt; orders)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.orders = orders;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Order</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">		o.setOrderNum(<span class="string">&quot;QW121212121212121&quot;</span>);</span><br><span class="line">		o.setPrice(<span class="number">100.0</span>);</span><br><span class="line">		</span><br><span class="line">		saveOrder(<span class="number">111</span>, o);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		HibernateUtil.closeSessionFactory();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 已经注册的用户添加订单</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveOrder</span><span class="params">(Integer userId,Order o)</span> &#123;</span><br><span class="line">		<span class="comment">// 获取Session对象</span></span><br><span class="line">		<span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> HibernateUtil.openSession();</span><br><span class="line">		<span class="comment">// 开启数据库事务</span></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">tran</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//查询用户</span></span><br><span class="line">		<span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> session.get(User.class, userId);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//给用户添加订单</span></span><br><span class="line">         u.getOrders().add(o); </span><br><span class="line">		o.setUser(u);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 保存</span></span><br><span class="line">		session.save(o);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 提交数据库事务</span></span><br><span class="line">		tran.commit();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关闭Session</span></span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Hibernate多对多关联映射"><a href="#Hibernate多对多关联映射" class="headerlink" title="Hibernate多对多关联映射"></a>Hibernate多对多关联映射</h2><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220309210655839.png" alt="image-20220309210655839" style="zoom:50%;">

<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220309210718991.png" alt="image-20220309210718991" style="zoom:50%;">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String studentNo;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Course&gt; courseSet </span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Course&gt;();</span><br><span class="line">    ......</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 课程名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> credit;  <span class="comment">// 学分</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; studentSet</span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Student&gt;();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>xml文件形式</strong></p>
<p>inverse 是 Hibernate 中双向关联关系中的基本概念，用来设置关系由哪一方来维护</p>
<ul>
<li>inverse&#x3D;true 表示被控方，&#x3D;false 表示主控方</li>
<li>在多对多关系中需要设置哪一方为被控方，即设置inverse&#x3D;true </li>
<li>只能在双向一对多，多对多中使用</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Student.hbm.xml --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- table映射的是外键表 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;courseSet&quot;</span> <span class="attr">table</span>=<span class="string">&quot;student_course&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">inverse</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 顺序不能改变 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;student_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">&quot;Course&quot;</span> <span class="attr">column</span>=<span class="string">&quot;course_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Course.hbm.xml --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- table映射的是外键表 --&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- inverse=&quot;true&quot;表示放弃了关联关系的维护 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">&quot;studentSet&quot;</span> <span class="attr">table</span>=<span class="string">&quot;student_course&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">inverse</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 顺序不能改变 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">&quot;course_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">many-to-many</span> <span class="attr">class</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">column</span>=<span class="string">&quot;student_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>注解形式</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220310205831875.png" alt="image-20220310205831875"></p>
<h2 id="Hibernate操作持久化对象"><a href="#Hibernate操作持久化对象" class="headerlink" title="Hibernate操作持久化对象"></a>Hibernate操作持久化对象</h2><p><strong>session缓存</strong></p>
<p>缓存介于应用程序和永久性存储源之间，其作用是降低应用程序直接读写永久性存储源的频率，从而提高应用的运行效率。</p>
<p>缓存内的数据是永久性存储源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件同步缓存和永久性存储源的数据。</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220311082156384.png" alt="image-20220311082156384"></p>
<p>当 Session 执行查询方法时，先从 Session 缓存中读取据，如果缓存中有则直接读取，如果缓存中没有，从数据库中查询并加载到 Session 缓存中，再从缓存中读取。</p>
<p>当 Session 执行 save()、update() 方法时，将对象持久化到数据库中并将对象加载到 Session 缓存中。</p>
<p><strong>session清理缓存</strong></p>
<p><strong>Session在某一时间点按照缓存中对象的属性变化来同步更新数据库的这一过程被称为 Session 清理缓存。</strong></p>
<p>缓存清理的时间点：</p>
<ul>
<li>当调用 transaction.commit() 方法时，会先清理缓存，再向数据库提交事务；</li>
<li>当显式调用 Session.flush() 方法时，会清理缓存；</li>
<li>当调用 Session 的查询（不包括 load() 和 get() )方法时，如果缓存中对象的属性有变化则清理缓存。</li>
</ul>
<p><strong>Session清理缓存的模式</strong></p>
<p>setHibernateFlushMode() 用于设定 Session 清理缓存的模式。</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220311084043414.png" alt="image-20220311084043414"></p>
<p><strong>Hibernate实体对象生命周期</strong></p>
<ul>
<li>Transient(临时状态) ： 刚刚被 new 关键字创建，还没有被持久化，不在Session的缓存中。</li>
<li>Persistent(持久化状态) ： 已经被持久化，并加入到 Session 缓存中。</li>
<li>Detached(游离状态) ： 已经被持久化，但不再处于 Session 缓存中（给id赋值了）。</li>
<li>Removed(删除状态) ： Session 已经计划将其从数据库删除，并且不再处于 Session 缓存中。</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220311085824284.png" alt="image-20220311085824284"></p>
<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220311092226118.png" alt="image-20220311092226118" style="zoom: 50%;">

<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220311092241541.png" alt="image-20220311092241541" style="zoom: 50%;">

<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220311092339814.png" alt="image-20220311092339814" style="zoom:50%;">

<img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220311092405770.png" alt="image-20220311092405770" style="zoom:50%;">



<hr>
<h2 id="Hibernate检索方式"><a href="#Hibernate检索方式" class="headerlink" title="Hibernate检索方式"></a>Hibernate检索方式</h2><p><strong>HQL检索方式</strong></p>
<ul>
<li>HQL语句中关键字大小写无关，但习惯将关键字小写。</li>
<li>from 关键字后面是类名不是数据库表名，类名需区分大小写。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testHQL</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> HibernateUtil.openSession();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1.查询所有记录的所有字段</span></span><br><span class="line">		<span class="comment">//String hql = &quot;from User&quot;;  //== select * from user</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u from User u&quot;</span>; <span class="comment">//== select * from user,不能使用* 要用别名</span></span><br><span class="line">		Query&lt;User&gt; query = session.createQuery(hql);</span><br><span class="line">		List&lt;User&gt; users = query.list();</span><br><span class="line">		System.out.println(users);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 2.查询所有记录的某个字段(list返回值中集合的元素类型同字段类型一致)</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u.userName from User u&quot;</span>;</span><br><span class="line">		<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">		List&lt;String&gt; users = query.list();</span><br><span class="line">		System.out.println(users);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 3.查询所有记录的多个字段(默认list方法返回集合中元素是Object数组，可手动调用构造方法)</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u.userName, u.password from User u&quot;</span>;</span><br><span class="line">		<span class="comment">//String hql = &quot;select new User(u.userName, u.password) from User u&quot;; 如果想要每次将结果封装起来而不是成为一个数组的话 需要自己构造一个（需要有相应构造器）</span></span><br><span class="line">		<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">		List&lt;User&gt; users = query.list();</span><br><span class="line"> </span><br><span class="line">		List&lt;Object[]&gt; users = query.list();</span><br><span class="line">		<span class="keyword">for</span>(Object[] o : users) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;用户名：&quot;</span> + o[<span class="number">0</span>]);</span><br><span class="line">			System.out.println(<span class="string">&quot;密码：&quot;</span> + o[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 4.where子句加查询条件</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u from User u where u.userName=&#x27;张三&#x27;&quot;</span>;</span><br><span class="line">		<span class="comment">//String hql = &quot;select u from User as u where u.userName like &#x27;%张%&#x27;&quot;;</span></span><br><span class="line">		Query&lt;User&gt; query = session.createQuery(hql);</span><br><span class="line">		List&lt;User&gt; users = query.list();</span><br><span class="line">		System.out.println(users);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 5.查询结果中只包含一条记录</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u from User u where u.id=104&quot;</span>;</span><br><span class="line">		Query&lt;User&gt; query = session.createQuery(hql);</span><br><span class="line">		<span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> query.uniqueResult();</span><br><span class="line">		System.out.println(u);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 6.使用order by 实现排序</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u from User u order by u.userName, u.id desc&quot;</span>;</span><br><span class="line">		Query&lt;User&gt; query = session.createQuery(hql);</span><br><span class="line">		List&lt;User&gt; users = query.list();</span><br><span class="line">		System.out.println(users);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 7.使用group by实现分组+having条件（某个用户名同名的用户个数）</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u.userName, count(u) from User u group by u.userName having u.userName != &#x27;张三&#x27;&quot;</span>;</span><br><span class="line">		<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">		List&lt;Object[]&gt; users = query.list();</span><br><span class="line">		<span class="keyword">for</span>(Object[] o : users) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;用户名：&quot;</span> + o[<span class="number">0</span>]);</span><br><span class="line">			System.out.println(<span class="string">&quot;个数：&quot;</span> + o[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 8.参数的绑定</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u from User u where u.userName=?&quot;</span>;</span><br><span class="line">		<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//绑定参数,通过位置</span></span><br><span class="line">		query.setParameter(<span class="number">0</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		List&lt;User&gt; users = query.list();</span><br><span class="line">		System.out.println(users);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//命名参数</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u from User u where u.userName=:name&quot;</span>;</span><br><span class="line">		<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">		<span class="comment">//绑定参数,通过参数名称</span></span><br><span class="line">		query.setParameter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		List&lt;User&gt; users = query.list();</span><br><span class="line">		System.out.println(users);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 参数名称同对象的属性名称一致</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u from User u where u.userName=:userName&quot;</span>;</span><br><span class="line">		<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">		<span class="comment">//绑定参数</span></span><br><span class="line">		<span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">		u.setUserName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		query.setProperties(u);</span><br><span class="line">		List&lt;User&gt; users = query.list();</span><br><span class="line">		System.out.println(users);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 绑定参数，使用Map对象</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u from User u where u.userName=:userName&quot;</span>;</span><br><span class="line">		<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">		Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">// map的key值同参数的名称一致</span></span><br><span class="line">		map.put(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		query.setProperties(map);</span><br><span class="line">		List&lt;User&gt; users = query.list();</span><br><span class="line">		System.out.println(users);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//子查询</span></span><br><span class="line"><span class="comment">//		SQL:SELECT * FROM user u WHERE (SELECT COUNT(o.id) FROM orders o WHERE o.user_id = u.id) &gt; 0</span></span><br><span class="line"><span class="comment">//		String hql = &quot;select u from User u where (select count(o) from Order o where o.user = u) &gt; 0&quot;;</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;select u from User u where (select count(o) from u.orders o) &gt; 0&quot;</span>;</span><br><span class="line">		<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line">		List&lt;User&gt; users = query.list();</span><br><span class="line">		System.out.println(users);</span><br><span class="line">		</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hqlUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 获取Session对象</span></span><br><span class="line">		<span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> HibernateUtil.openSession();</span><br><span class="line">		<span class="comment">// 开启数据库事务</span></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">tran</span> <span class="operator">=</span> session.beginTransaction();</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		String hql = &quot;update User u set u.password=:pass where u.userName=:name&quot;;</span></span><br><span class="line"><span class="comment">//		Query&lt;User&gt; query = session.createQuery(hql);</span></span><br><span class="line"><span class="comment">//		query.setParameter(&quot;pass&quot;, &quot;000000&quot;);</span></span><br><span class="line"><span class="comment">//		query.setParameter(&quot;name&quot;, &quot;张三&quot;);</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;delete from User u where u.userName=?&quot;</span>;</span><br><span class="line">		Query&lt;User&gt; query = session.createQuery(hql);</span><br><span class="line">		query.setParameter(<span class="number">0</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> query.executeUpdate();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;影响的条数：&quot;</span> + row);</span><br><span class="line">		</span><br><span class="line">		tran.commit();</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>HQL子查询说明以下几点：</p>
<ul>
<li><p>子查询分为相关子查询和无关子查询；</p>
<ul>
<li>相关子查询：子查询语句引用了外层查询语句定义的别名。</li>
<li>无关子查询：子查询语句没有引用外层查询语句定义的别名。</li>
</ul>
</li>
<li><p>HQL子查询功能依赖于底层数据库对子查询的支持；</p>
</li>
<li><p>HQL子查询返回的是多条记录，使用以下关键字量化。</p>
<ul>
<li>all、any、some、in、exists。</li>
</ul>
</li>
<li><p>如果HQL子查询的是集合，HQL提供了一组操作集合的函数。</p>
<ul>
<li>size()，获得集合中元素的个数；</li>
<li>maxIndex()，对于建立索引的集合，获得最大索引值；</li>
<li>minIndex()，对于建立索引的集合，获得最小索引值；</li>
<li>elements()，获得集合中所有元素。</li>
</ul>
</li>
<li><p>做批量查询时，如果数据量很大就需要分页功能，HQL提供了用于分页查询的方法：</p>
<ul>
<li><p>setFirstResult(int firstResult)<br>设定从哪个对象开始检索。</p>
</li>
<li><p>setMaxResults (int maxResult)<br>设定一次检索对象的数目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query&lt;User&gt; query = session.createQuery(<span class="string">&quot;from User&quot;</span>);</span><br><span class="line">query.setFirstResult((pageNum-<span class="number">1</span>) * maxCount);</span><br><span class="line">query.setMaxResult(maxCount);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>引用查询指在映射文件中定义查询语句。</p>
<ul>
<li><p>在O&#x2F;R映射xml文件中，用与<class>元素同级的<query name="XXX">元素定义一个HQL查询语句</query></class></p>
</li>
<li><p>&#96;&#96;&#96;xml<br><query name="findUser">from User</query></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 程序中通过session.getNamedQuery(&quot;XXX&quot;)调用对应的HQL。</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  Query query = session.createNamedQuery(&quot;findUser&quot;,User.class);</span><br><span class="line">  List userList = query.list();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>QBC检索方式</strong></p>
<p>Query  By Criteria(QBC) 可以看作是传统SQL的对象化表示。它主要由Criteria接口，Criterion接口，Restrictions类组成。</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220315111739151.png" alt="image-20220315111739151"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220315111756016.png" alt="image-20220315111756016"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如：检索姓名为张三的所有用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建查询容器</span></span><br><span class="line">Criteria criteria=session.createCriteria(User.class);</span><br><span class="line"><span class="comment">//创建查询条件</span></span><br><span class="line">Criterion c1= Restrictions.eq(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//将查询条件添加到查询容器中</span></span><br><span class="line">criteria.add(c1);</span><br><span class="line"><span class="type">List</span> <span class="variable">result</span> <span class="operator">=</span> criteria.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**步骤：</span></span><br><span class="line"><span class="comment">调用 Session 的 createCriteria() 创建 Criteria 实例；</span></span><br><span class="line"><span class="comment">通过 Restrictions 设定查询条件；</span></span><br><span class="line"><span class="comment">调用 Criteria 实例的 list() 方法执行查询。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<p><strong>本地SQL检索方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from  user&quot;</span>;</span><br><span class="line"><span class="type">NativeQuery</span> <span class="variable">query</span> <span class="operator">=</span> session.createNativeQuery(sql, User.class);</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**步骤：</span></span><br><span class="line"><span class="comment">调用session.createNativeQuery()创建NativeQuery实例，并指定查询的实体类型；</span></span><br><span class="line"><span class="comment">调用NativeQuery实例的list() 方法执行查询(如果查询单个对象，调用uniqueResult())</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<hr>
<h2 id="Hibernate检索策略"><a href="#Hibernate检索策略" class="headerlink" title="Hibernate检索策略"></a>Hibernate检索策略</h2><p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220317145359965.png" alt="image-20220317145359965"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220317150313456.png" alt="image-20220317150313456"></p>
<p><strong>类级别检索策略：</strong></p>
<p><strong>立即检索：立即加载检索方法指定的对象。</strong></p>
<p>加载多于需要的对象白白浪费内存空间</p>
<p>select 语句数量多，频繁访问数据库，影响系统性能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">映射配置文件中<span class="tag">&lt;<span class="name">class</span>&gt;</span>元素的 lazy 属性设置为 false。</span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;USER&quot;</span> <span class="attr">lazy</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>延迟检索：延迟加载检索方法指定的对象。</strong></p>
<p>避免多加载应用程序不需要访问的数据对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">映射配置文件中<span class="tag">&lt;<span class="name">class</span>&gt;</span>元素的 lazy 属性设置为 true。</span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;USER&quot;</span> <span class="attr">lazy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注：访问id属性时不会触发查询，因为是以id为条件进行查询的，查询之前就已经将id赋值给返回的类了 --&gt;</span></span><br></pre></td></tr></table></figure>





<p><strong>关联级别检索策略：</strong></p>
<p>在映射文件中用 <set>元素 来配置 一对多 和 多对多 关联关系。</set></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220317152311703.png" alt="image-20220317152311703"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">一对多和多对多</span><br><span class="line">修改User 一对多关联的Order对象的检索策略，User.hbm.xml 中<span class="tag">&lt;<span class="name">set</span>&gt;</span>元素 lazy 和 outer-join 属性</span><br><span class="line">    </span><br><span class="line">多对一</span><br><span class="line">修改Order 多对一关联的 User 对象检索策略，Order.hbm.xml 中 <span class="tag">&lt;<span class="name">many-to-one</span>&gt;</span>元素 outer-join 属性和 User.hbm.xml 中<span class="tag">&lt;<span class="name">class</span>&gt;</span>元素的 lazy 属性。</span><br></pre></td></tr></table></figure>



<p><strong>迫切左外连接检索：利用SQL外连接查询功能加载检索方法指定对象。</strong></p>
<p>减少执行select语句的数量，减少数据库访问，提高系统性能。</p>
<hr>
<h2 id="Hibernate二级缓存机制"><a href="#Hibernate二级缓存机制" class="headerlink" title="Hibernate二级缓存机制"></a>Hibernate二级缓存机制</h2><p>SessionFactory有一个<strong>内置缓存</strong>（实现机制跟Session缓存类似）和一个可以配置的缓存插件被称为<strong>外置缓存</strong></p>
<ul>
<li><p>Session缓存是内置的不能被卸载的，被称为Hibernate的一级缓存</p>
</li>
<li><p>SessionFactory的外置缓存被称为Hibernate的二级缓存</p>
</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220317154654073.png" alt="image-20220317154654073"></p>
<p>Session缓存是事务范围的缓存。</p>
<p>SessionFactory缓存是进程范围或者集群范围的缓存。</p>
<p>进程范围和集群范围的缓存可能被进程内的多个事务并发访问，因此需要采取必要的并发访问策略。</p>
<p>持久化层的二级缓存，在查询时先在事务缓存中查找，如果没有查询到相应数据，再到进程范围或集群范围缓存中查找，如果还没找到再数据库中查找。</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220317155140250.png" alt="image-20220317155140250"></p>
<hr>
<h2 id="Hibernate二级缓存配置"><a href="#Hibernate二级缓存配置" class="headerlink" title="Hibernate二级缓存配置"></a>Hibernate二级缓存配置</h2><p>Hibernate的第二级缓存是可配置的缓存插件，允许选用以下类型的缓存插件，表中给出了各个缓存插件支持的并发访问策略。</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/29/Hibernate/image-20220317155525782.png" alt="image-20220317155525782"></p>
<p>选择EHCache缓存插件的配置步骤如下</p>
<p>1、在Hibernate.cfg.xml配置文件中配置 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- cache.use_second_level_cache设为true，打开二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cache.use_second_level_cache&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- cache.region.factory_class配置缓存插件提供商 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cache.region.factory_class&quot;</span>&gt;</span>org.hibernate.cache.ehcache.EhCacheRegionFactory<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、设置实体映射配置文件中<class>或<set>元素的<cache>子元素的usage属性</cache></set></class></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">usage</span>=<span class="string">&quot;read-write&quot;</span>/&gt;</span></span><br><span class="line">    ……</span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">transactional：一般缓存插件没有此策略（除jboss-cache）</span><br><span class="line">nonstrict-read-write：不严格的读写（如：帖子的回帖量）</span><br><span class="line">read-write：严格的读写（如：银行系统数据） </span><br><span class="line">read-only ： 只读策略（对象不能修改，修改会报异常），效率最高</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HideBlog</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM概述</title>
    <url>/2022/03/31/JVM/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JVM是Java平台无关的保障，虚拟机上是平台无关的，虚拟机下是平台相关的</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220226194411060.png" alt="image-20220226194411060"></p>
<p><strong>各种虚拟机</strong></p>
<ul>
<li><p>虚拟机始祖：Sun Classic</p>
<p>1996年，Sun发布JDK 1.0， Java语言首次拥有了商用的正式运行环境， 这个JDK中所带的虚拟机就是Classic VM。这款虚拟机只能使用纯解释器方式来执行Java代码。</p>
</li>
<li><p>Exact VM</p>
<p>JDK1.2时， 在Solaris平台上发布Exact VM的虚拟机， 它的编译执行系统已经具备现代高性能虚拟机雏形。（外挂编译器）</p>
</li>
<li><p>使用最广泛的JVM：HotSpot VM</p>
<p>JDK1.3成为默认虚拟机， JDK6、JDK8等均为默认虚拟机。<br>HotSpot虚拟机的热点代码探测，通过执行计数器找出最有编译价值的代码， 再通知即时编译器以方法为单位进行编译</p>
</li>
<li><p>Open-JDK</p>
<p>2006年， JDK的各个部分在GPLv2协议下开放了源码， 形成了Open-JDK项目， 其中当然也包括HotSpot虚拟机</p>
</li>
<li><p>BEA JRockit</p>
<p>专门为服务器硬件和服务端应用场景高度优化的虚拟机。<br>2008年BEA被Oracle收购，JDK8在HotSpot的基础上植入了部分JRockit的优秀特性。</p>
</li>
<li><p>IBM J9</p>
<p>IBM J9虚拟机的职责分离与模块化做得比HotSpot更优秀。<br>2016年起IBM逐渐将J9开源，并捐赠给Eclipse基金会管理，随后重新命名为OpenJ9。</p>
</li>
</ul>
<h2 id="虚拟机规范"><a href="#虚拟机规范" class="headerlink" title="虚拟机规范"></a>虚拟机规范</h2><p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220226194247568.png" alt="image-20220226194247568"></p>
<p><strong>运行时数据区</strong></p>
<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p>
<p>这些区域有各自的用途， 各自的创建和销毁的时间。有的区域随着虚拟机进程的启动而一直存在， 有的区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<p><strong>类文件结构</strong></p>
<p>平台无关性，语言无关性。</p>
<p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据。</p>
<p><strong>类加载子系统</strong></p>
<p>Java虚拟机把描述类的数据从Class文件加载到内存， 并对数据进行校验、 转换解析和初始化， 最终形成可以被虚拟机直接使用的Java类型， 这个过程被称作虚拟机的类加载。</p>
<p><strong>执行引擎</strong></p>
<p>执行引擎是Java虚拟机核心的组成部分之一。</p>
<p>虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
<p>所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220226200035856.png" alt="image-20220226200035856"></p>
<h3 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h3><ul>
<li><p>PC寄存器（程序计数器）可看作是当前线程所执行的字节码的行号指示器。</p>
</li>
<li><p>在JVM的概念模型里，<strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码指令</strong>，分支、 循环、 跳转、 异常处理等都依赖于它完成。<strong>每个线程有一个独立的程序计数器，线程之间互不影响。（线程独享）</strong></p>
</li>
<li><p>运行时数据区中唯一不会出现OOM（Out Of Memory）的区域，没有垃圾回收。</p>
</li>
</ul>
<p>使用 javap -v xxx.class 指令可以将文件解析成指令集</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220226201006497.png" alt="image-20220226201006497"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220226201409491.png" alt="image-20220226201409491"></p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ul>
<li><p>Java虚拟机栈描述的是<strong>Java方法</strong>执行的线程内存模型</p>
</li>
<li><p><strong>每个方法被执行的时候， Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</strong></p>
</li>
<li><p>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
</li>
<li><p><strong>Java虚拟机栈不存在垃圾回收，但是会有OOM。</strong></p>
</li>
<li><p>Java虚拟机规范允许 Java 虚拟机堆栈具有固定大小或根据计算需要动态扩展和收缩。</p>
<ul>
<li>如果是可动态扩展，当无法申请到足够内存时会出现OOM。</li>
<li>如果是固定大小，当线程请求的栈容量超过固定值，则出现StackOverflowError。</li>
</ul>
</li>
</ul>
<p>-Xss设置栈内存的大小，设置的栈的大小决定了函数调用的最大深度。</p>
<p>未调优之前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JvmTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;count:&quot;</span> + count++);</span><br><span class="line">        add(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>控制台OOM错误</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220226202751227.png" alt="image-20220226202751227"></p>
<p>调优：</p>
<p>参考：<a href="https://blog.csdn.net/qq_32907195/article/details/106852973">https://blog.csdn.net/qq_32907195/article/details/106852973</a></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220226204802620.png" alt="image-20220226204802620"></p>
<p>再次运行后</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220226204831804.png" alt="image-20220226204831804"></p>
<h4 id="栈帧内部结构"><a href="#栈帧内部结构" class="headerlink" title="栈帧内部结构"></a>栈帧内部结构</h4><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法调用和方法执行背后的数据结构。</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220226205233079.png" alt="image-20220226205233079"></p>
<ul>
<li><p><strong>局部变量</strong></p>
<p>局部变量是一个数组，在编译时其长度就被定义好。主要用于存储方法参数、定义在方法内的局部变量。</p>
<p>局部变量的数据类型可以包括：基本数据类型、引用数据类型和返回值地址。</p>
</li>
<li><p><strong>操作数栈也常被称为操作栈，后入先出（Last In First Out，LIFO）。</strong></p>
<p>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。操作数栈中，32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度。</p>
<p>操作数栈并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问。</p>
</li>
<li><p><strong>动态链接</strong></p>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，以支持方法代码的动态链接。</p>
<p><strong>在Java源文件被编译成字节码文件时，所有的变量、方法引用都作为符号引用，保存在class文件的常量池中</strong></p>
<p>描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的。动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</p>
</li>
<li><p><strong>返回地址</strong></p>
<p>执行引擎遇到一个方法返回的字节码指令（例如：ireturn）， 此时可能会有返回值传递给上层调用的方法。</p>
<p>一个方法因有未处理的异常而退出，称之为异常调用完成。一个方法因异常而退出， 是不会给它的上层调用者提供任何返回值的。</p>
</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stacks）与Java虚拟机栈作用是非常相似的，只不过他是为虚拟机使用本地（Native）方法而服务。</p>
<p><strong>《 Java虚拟机规范》对本地方法栈中方法使用的语言、 使用方式与数据结构并没有任何强制规定</strong>，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。 </p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220302091312530.png" alt="image-20220302091312530"></p>
<blockquote>
<p>jdk7以前，方法区的实现是永久代，jdk8开始方法区的实现使用元空间取代了永久代。</p>
<p>元空间和永久代最大的区别是：元空间不在虚拟机设置的内存中，而是使用本地内存</p>
</blockquote>
<ol>
<li><p><strong>方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong></p>
</li>
<li><p>方法区在JVM启动的时候被创建，<strong>它的实际的物理内存空间都是可以不连续的。</strong></p>
</li>
<li><p>JDK8之后，<strong>元空间即是对方法区的具体实现</strong>。存储了以下内容：</p>
</li>
</ol>
<ul>
<li><p>类型信息</p>
<ul>
<li>比如类Class，接口Interface，枚举Enum，注解annotation等类型的完整名称（包名.类名）。</li>
<li>类型的修饰符，比如public、abstract、final等。</li>
<li>直接父类的完整名称。</li>
<li>直接接口的有序列表。</li>
</ul>
</li>
<li><p>属性（域）信息</p>
<ul>
<li>属性（域）名称、属性（域）类型。</li>
<li>属性（域）修饰符，public、private、protected、final、static、transient、volattile的一个子集。</li>
<li>属性（域）的声明顺序</li>
</ul>
</li>
<li><p>方法信息</p>
<ul>
<li>方法名称、方法参数、方法的返回值类型或void。</li>
<li>方法的修饰符，public，private，protected，static，final，synchronized，native，abstract的一个子集。</li>
<li>方法的字节码bytecodes，操作数栈，局部变量表及大小。</li>
<li>异常表（abstract和native方法除外），每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引。</li>
<li>方法的声明顺序。</li>
</ul>
</li>
<li><p><strong>运行时常量池</strong></p>
<blockquote>
<p>（1）方法区，内部包含了运行时常量池</p>
<p>（2）字节码文件，内部包含了常量池</p>
</blockquote>
<p>参考：<a href="https://blog.csdn.net/qq_42181724/article/details/115035236">https://blog.csdn.net/qq_42181724/article/details/115035236</a></p>
<ul>
<li><strong>字节码文件中的常量池，包括各种字面量（数值、字符串值）和对类型、属性（域）、方法的符号引用。</strong></li>
<li><strong>将字节码文件加载后，其中的常量池就会被加载到方法区，就是运行时常量池。而运行时常量池中的符号引用在运行期就被解析为了真实地址（动态链接）</strong></li>
<li><strong>JVM为每个已加载的类型(类，接口)维护一个常量池，池中的数据项像数组一样，可以直接通过索引访问</strong><ul>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池</li>
</ul>
</li>
<li><strong>JDK1.8之后：无永久代，字符串常量池、静态变量保存在堆中。类型信息、属性（域）信息、方法信息、常量保存在本地内存的元空间（元空间代替了永久代，元空间位于本地内存中，而永久代位于虚拟机内存中，解决了OOM问题）</strong></li>
</ul>
</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220302095501273.png" alt="image-20220302095501273"></p>
<img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220330173156446.png" alt="image-20220330173156446" style="zoom: 67%;">

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul>
<li>堆是Java内存管理的核心区域，所有线程共享Java堆，“几乎”所有的对象实例都在这里分配内存。</li>
<li>默认情况下，<strong>堆的初始内存大小是物理内存的1&#x2F;64，堆的最大内存大小是物理内存的1&#x2F;4。</strong></li>
<li>一个JVM实例只存在一个堆，JVM启动时堆即被创建，其空间大小也就确定，当然内存大小是可调节的。</li>
<li>堆在物理上可以是不连续的，但在逻辑上应该被视为连续的。</li>
<li><strong>堆也是垃圾回收的重点区域</strong></li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220302101646499.png" alt="image-20220302101646499"></p>
<p>默认情况下，堆的初始内存大小是物理内存的1&#x2F;64，堆的最大内存大小是物理内存的1&#x2F;4。</p>
<p>-Xms(-XX:InitialHeapSize)：堆(新生代+老年代)的初始内存。</p>
<p>-Xmx(-XX:MaxHeapSize)：堆(新生代+老年代)的最大内存。</p>
<p>-XX:NewSize和-Xmn(-XX:MaxNewSize)：新生代的初始内存和新生代的最大内存。</p>
<p>-XX:SurvivorRatio：新生代中1个Eden区与1个Survivor区的大小比值。</p>
<p>-XX:NewRatio：指定老年代&#x2F;新生代的堆内存比例。</p>
<p><strong>虚拟机栈、方法区、堆的关系如下</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p1b2Rhb3lvbmc=,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<hr>
<h2 id="类加载机制和垃圾回收"><a href="#类加载机制和垃圾回收" class="headerlink" title="类加载机制和垃圾回收"></a>类加载机制和垃圾回收</h2><h3 id="类文件的结构"><a href="#类文件的结构" class="headerlink" title="类文件的结构"></a>类文件的结构</h3><ul>
<li><p>平台无关性，语言无关性。</p>
</li>
<li><p>Class文件是一组以8位为一个字节，作为基础单位的二进制流，各数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符。</p>
</li>
<li><p>根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。</p>
<ul>
<li>无符号数：<ul>
<li>它属于基本数据类型。</li>
<li>它以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数。</li>
<li>它可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</li>
</ul>
</li>
<li>表：<ul>
<li>它是由多个无符号数或者其他表作为数据项构成的复合数据类型。</li>
<li>它习惯性地以“_info”结尾。</li>
<li>它用于描述有层次关系的复合结构的数据，整个Class文件本质上可被视作一张表。</li>
</ul>
</li>
</ul>
</li>
<li><p>结构</p>
<ul>
<li>魔数：每个Class文件的头4个字节成为魔数。其唯一的作用：确定该文件是否为一个能被虚拟机接受的Class文件。</li>
<li>版本号：第5、6字节为次版本号，第7、8字节为主版本号。</li>
<li>常量池：常量池中常量的数量不是固定的，所以会有一个常量池容量的计数器；常量池中主要存放两大类常量：字面量和符号引用</li>
<li>访问标志：用于识别一些类或者接口层次的访问信息</li>
<li>类索引：用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。除java.lang.Object类外，所有类的父类索引均不为0。</li>
<li>接口索引：集合就用来描述这个类实现了哪些接口</li>
</ul>
</li>
</ul>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>一个Java类型从被加载到虚拟机内存，直到卸载出内存，就是它的整个生命周期。这一过程包括：</p>
<ul>
<li><p>加载（Loading）</p>
</li>
<li><p>验证（Verification）</p>
</li>
<li><p>准备（Preparation）</p>
</li>
<li><p>解析（Resolution）</p>
</li>
<li><p>初始化（Initialization）</p>
</li>
<li><p>使用（Using）</p>
</li>
<li><p>卸载（Unloading）</p>
</li>
<li><p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220303194628380.png" alt="image-20220303194628380"></p>
</li>
</ul>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象， <strong>作为方法区这个类的各种数据的访问入口。</strong></li>
</ul>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220303200246710.png" alt="image-20220303200246710"></p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220303200259954.png" alt="image-20220303200259954"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将类、接口、字段和方法的符号引用转为直接引用；也就是得到类、字段、方法等在内存中的指针或者偏移量。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>获取到Class对象初始化锁的线程才能只能初始化，其他线程都要阻塞等待。主要工作：</p>
<ul>
<li>给类变量（静态变量）赋定义的值</li>
<li>执行静态代码块（静态代码块只能访问定义在静态代码块之前的静态变量，定义在静态代码块之后的静态变量，可以赋值，但是不能访问）</li>
</ul>
<blockquote>
<p>对于加载，java 虚拟机规范中没有进行强制约束，交给虚拟机的具体实现来自由把握。但对于初始化阶段，虚拟机规范则是严格规定了<strong>有且只有5种</strong> 情况必须立即进行“初始化”（而加载、验证、准备自然在此之前开始）</p>
<ol>
<li>遇到 new 、getstatic 、putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化 。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及凋用一个类的静态方法的时候。</li>
<li>使用 java-lang 、 reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invokeMethodHandle 实例最后的解析结果 REF-getStatic 、 REF_putStatic 、 REF invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>
</ol>
<p>对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5个场景中的行为称为对一个类进行<strong>主动引用</strong>，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。</p>
</blockquote>
<p>由于Java 虚拟机规范中没有进行强制约束所以可以将类的初始化时机看作是类的加载时机    ？</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><strong>类加载器负责加载所有的Class，在标准Java程序中，JVM会创建三种类加载器：</strong></p>
<ul>
<li><p><strong>Bootstrap ClassLoader</strong></p>
<ul>
<li><p>用于加载Java核心类库，比如存放在JRE的lib目录下jar包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。</p>
</li>
<li><p>出于安全考虑，只加载包名为java\javax\sun等开头的类。</p>
</li>
<li><p>加载扩展类加载器和应用类加载器，并指定成为他们的上层加载器。</p>
</li>
<li><p>使用C&#x2F;C++语言实现，嵌套在JVM内部。</p>
</li>
<li><p>不继承于java.lang.ClassLoader，没有父加载器。</p>
</li>
</ul>
</li>
<li><p><strong>Extension ClassLoader</strong></p>
<ul>
<li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从jre&#x2F;lib&#x2F;ext子目录下加载类库。</p>
</li>
<li><p>使用Java语言实现，派生于ClassLoader，由sun.misc.Launcher$ExtClassLoader实现。</p>
</li>
<li><p>上层加载器是启动加载器。</p>
</li>
</ul>
</li>
<li><p><strong>App ClassLoader</strong></p>
<ul>
<li>负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。</li>
<li>使用Java语言实现，派生于ClassLoader，由sun.misc.Launcher$AppClassLoader实现。</li>
<li>上层加载器是扩展加载器。</li>
<li>该加载器是程序中默认的类加载器。</li>
</ul>
</li>
</ul>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>参考：<a href="https://www.jianshu.com/p/1e4011617650">https://www.jianshu.com/p/1e4011617650</a></p>
<p>双亲委派机制：简单来说是子加载器让父加载器去加载，若父加载器加载不到才回到子加载器，让子加载器加载</p>
<p><strong>作用：</strong></p>
<p>1、防止重复加载同一个<code>.class</code>。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。</p>
<p> 2、保证核心<code>.class</code>不能被篡改。通过委托方式，不会去篡改核心<code>.class</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="判断对象死亡的方法"><a href="#判断对象死亡的方法" class="headerlink" title="判断对象死亡的方法"></a>判断对象死亡的方法</h4><p><strong>引用计数法</strong></p>
<ul>
<li>基本思路：对每个对象保存一个整型的引用计数器属性，用于记录被对象引用的情况，<strong>被引用了就+1，引用失效就-1,0表示不可能再被使用，可进行回收。</strong></li>
<li>优点：实现简单；垃圾对象便于判断、标识。</li>
<li>缺点：需要额外的空间存储计数器；更新计数器的数值，增加了时间的开销；<strong>无法处理循环引用。</strong></li>
</ul>
<p><strong>可达性分析法</strong></p>
<ul>
<li>基本思路：是以根对象（GCRoots）为起始点，按照从上到下的方式搜索被根对象集合所连接的目标对象是否可达。只有能够被根对象集合直接或者间接连接的对象才是存活的对象；反之则是不可达的，可以标记为垃圾对象。</li>
<li>优点：解决了循环引用的问题。</li>
<li>缺点：分析结果必须要在一个能保障一致性的快照中进行，否则准确性就无法保证。比如在多线程程序下某线程更新对象的引用，有可能造成误报或者漏报。</li>
</ul>
<p>GCRoots包括</p>
<ul>
<li>虚拟机栈中引用的对象。</li>
<li>本地方法栈内JNI引用的对象。</li>
<li>方法区中静态属性引用的对象、常量引用的对象。</li>
<li>所有被同步锁synchronized持有的对象。</li>
</ul>
<h4 id="Finalization机制"><a href="#Finalization机制" class="headerlink" title="Finalization机制"></a>Finalization机制</h4><p>Java语言提供了finalization机制来允许开发人员在对象被销毁之前的自定义处理逻辑。</p>
<ul>
<li>当垃圾回收器发现没有引用指向一个对象，即垃圾回收此对象之前，总会先调用这个对象的finalize（）方法。</li>
<li>finalize（）方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放，通常在这个方法中进行一些资源释放和清理的工作</strong>。</li>
<li>finalize（）方法只能被调用一次</li>
</ul>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><p><strong>标记清除算法</strong></p>
<ul>
<li>步骤：1.标记需要回收的对象，2.将标记的对象统一回收。</li>
<li>常用于老年代，因为老年代中大部分对象不会被清理。</li>
<li>优点：算法简单，只需要维护一个空闲列表。</li>
<li>缺点：<ul>
<li>执行效率不稳定，该算法效率会随着对象的数量增长而降低。</li>
<li>内存碎片化问题。</li>
<li>需要停止整个应用程序，用户体验差。</li>
</ul>
</li>
</ul>
<img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220306081559256.png" alt="image-20220306081559256" style="zoom:50%;">



<p><strong>标记压缩算法</strong></p>
<ul>
<li>步骤：1.标记需要回收的对象，2.将存活的对象向内存空间的一端移动，3.直接清理掉边界以外的内存。</li>
<li>常用于老年代。</li>
<li>优点：没有碎片化问题。</li>
<li>缺点：如果存活对象较多，复制时开销较大。</li>
</ul>
<img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220306082117533.png" alt="image-20220306082117533" style="zoom:50%;">



<p><strong>复制算法</strong></p>
<ul>
<li>步骤：1.按照容量分为二个大小相等的内存区域（例如：A和B区域），2.当A区域回收时，将依然存活的对象复制到B区域，3.将A区域内存清理。</li>
<li>常用于新生代，因为新生代区域中对象只有极少数存活。</li>
<li>优点：实现简单、没有碎片化问题。</li>
<li>缺点：空间浪费较大；如果存活对象较多，复制时开销较大，效率低。</li>
</ul>
<img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220306083047988.png" alt="image-20220306083047988" style="zoom:50%;">







<h2 id="对象和执行引擎"><a href="#对象和执行引擎" class="headerlink" title="对象和执行引擎"></a>对象和执行引擎</h2><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><ul>
<li>new关键字。</li>
<li>Class.newInstance()。</li>
<li>Constructor.newInstance()。</li>
<li>Clone方法。</li>
<li>反序列化。</li>
</ul>
<p><strong>反射机制创建对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">class</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.Student&quot;</span>);</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> (Student)calss.newInstance();</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> class.getDeclaredConstructor(String.class);</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student)constructor.newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>clone方法创建对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> object <span class="title function_">clone</span> <span class="params">()</span> <span class="keyword">throws</span> CloneNotsupportedException &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">super</span>.clone ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getCompuer()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student)student1.clone();<span class="comment">//单个对象不存在浅拷贝、深拷贝问题</span></span><br><span class="line">            System.out.println(stuent1 == student2); <span class="comment">//false</span></span><br><span class="line">            System.out.println(stuent1.getComputer() == student2.getComputer()); <span class="comment">//ture 浅拷贝是针对于拷贝对象里的引用对象</span></span><br><span class="line">            <span class="comment">//深拷贝需要改造Student中的clone方法</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h3><ol>
<li><p>判断对象对应的类是否被加载、链接、初始化。</p>
<ul>
<li>当执行new指令时，首先检查能否在常量池中定位到类的符号引用，并且检查这个符号引用代表的类是否被加载解析初始化过。</li>
<li>如果没有，则采用双亲委派模式，查找类加载器+包名+类名的class文件，再加载。</li>
</ul>
</li>
<li><p>为对象分配内存。</p>
<ul>
<li><p>虚拟机实现的Java对象包括三个部分：对象头、实例字段和对齐填充字段。</p>
</li>
<li><p>注意：实例字段包括自身定义的，和从父类继承下来的（即使父类的实例字段被子类覆盖或者被private修饰，都照样为其分配内存）。</p>
</li>
<li><p>分配方式：</p>
<ol>
<li><p>指针碰撞</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1bl9sZA==,size_16,color_FFFFFF,t_70-16465283847112.png" alt="img"></p>
</li>
<li><p>空闲列表</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1bl9sZA==,size_16,color_FFFFFF,t_70.png" alt="img"></p>
</li>
</ol>
</li>
<li><p>分配内存时处理线程并发安全的问题：</p>
<ol>
<li>对分配内存空间的动作进行同步处理，实际上虚拟机采用CAS和失败重试的方式保证更新操作的原子性</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，哪个线程要分配内存，就在该线程的TLAB<em>（<strong>Thread Local Allocation Buffer即本地线程分配缓冲</strong>）</em>上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。有些类似于ConcurrentHashMap的实现原理</li>
</ol>
</li>
</ul>
</li>
<li><p>初始化分配的空间<br>虚拟机将分配到的内存空间（不包括对象头）初始化为零值。</p>
</li>
<li><p>设置对象的对象头</p>
<p>例如这个对象是那个类的实例、对象的GC分代年龄等等信息。</p>
</li>
<li><p>执行<init>方法。</init></p>
<ul>
<li>从虚拟机角度看，之前的4步已经完成了对象的创建。</li>
<li><strong>但从程序角度看，对象创建才刚开始，对象各属性还都是零值，还未执行构造方法<init>。</init></strong></li>
<li>new指令之后执行<init>方法，开始进行对象的初始化。该方法由编译器命名，由虚拟机的invokespecial指令调用，不能通过程序编码实现</init></li>
</ul>
</li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象被创建好后，在堆中的布局分为三部分：对象头、实例数据和填充。</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220307100255092.png" alt="image-20220307100255092"></p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>对象被创建后，是为了被使用。我们则是通过操作数栈中的reference（引用类型）来找到对象的位置。</p>
<p>JVM对于reference引用有2种主流的实现方式：</p>
<ul>
<li><p>句柄访问</p>
<ul>
<li>优点：reference中存放的是稳定句柄地址，在对象被移动（例如垃圾回收)时只改变句柄中实例数据指针，reference本身不用改变。</li>
<li>缺点：多了一道访问流程，故速度较慢。</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220308194100100.png" alt="image-20220308194100100"></p>
</li>
<li><p>直接指针访问</p>
<ul>
<li>优点：速度快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，所以积少成多也是一项可观的执行成本。</li>
<li>HotSpot主要是用指针，进行对象访问。</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/31/JVM/image-20220308194125872.png" alt="image-20220308194125872"></p>
</li>
</ul>
<h2 id="JVM执行引擎"><a href="#JVM执行引擎" class="headerlink" title="JVM执行引擎"></a>JVM执行引擎</h2><ul>
<li><p>执行引擎是Java虚拟机的核心组成部分之一</p>
</li>
<li><p>执行引擎的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令。</p>
</li>
</ul>
<p><strong>执行引擎概述</strong></p>
<ul>
<li><p>解释器</p>
<ul>
<li>当JVM启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>字节码解释器，早期的解释器，效率低下。</li>
<li>模板解释器，目前普遍使用</li>
</ul>
</li>
<li><p>JIT（Just In Time即时编译器）</p>
<ul>
<li>JVM将字节码直接编译成和本地机器平台相关的机器码</li>
</ul>
</li>
</ul>
<p><strong>热点探测技术</strong></p>
<ul>
<li>是否需要启动JIT编译器共存，则需要根据代码被调用执行的频率而定。那些需要被编译为本地代码的字节码，也被称之为“热点代码”。</li>
<li>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”。</li>
<li>目前HotSpot VM采用的是基于计数器的热点探测。</li>
<li>HotSpot VM将会为每一个方法都建立2个不同类型的计数器：<ul>
<li>方法调用计数器（Invocation Counter），用于统计方法的调用次数。</li>
<li>回边计数器（BackEdge Counter），用于统计循环体执行的循环次数。</li>
</ul>
</li>
</ul>
<p><strong>HotSpotVM设置执行方式</strong></p>
<ul>
<li><p>缺省情况下HotSpotVM是采用解释器与即时编译器并存的架构。但也可以通过参数设置：</p>
<ul>
<li><p>-Xint：完全采用解释器模式执行程序。</p>
</li>
<li><p>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</p>
</li>
<li><p>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/2022/03/19/LeetCode/</url>
    <content><![CDATA[<h2 id="easy-70：爬楼梯"><a href="#easy-70：爬楼梯" class="headerlink" title="easy     |     70：爬楼梯"></a>easy     |     70：爬楼梯</h2><p><strong>题目：假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</strong></p>
<p><strong>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</strong></p>
<p>思路：本题是典型的斐波那契数列题目，使用动态规划解决，这层阶梯的爬法是前两层阶梯爬法之和</p>
<p>斐波那契数列：<em>F</em>(<em>x</em>)&#x3D;<em>F</em>(<em>x</em>−1)+<em>F</em>(<em>x</em>−2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/03/24/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux入门"><a href="#Linux入门" class="headerlink" title="Linux入门"></a>Linux入门</h2><p><strong>Linux介绍</strong></p>
<p>Linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可</p>
<p>Linux的主要发行版：ubuntu、redhat、centos、suse</p>
<hr>
<h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>Linux的文件系统时采用层级式的树状目录结构，在此结构中的<strong>最上层是根目录 “ &#x2F; ”</strong>，然后在此目录下再创建其他的目录</p>
<p><strong>在Linux世界里，一切皆文件</strong></p>
<p>&#x2F;bin：存放常用的指令</p>
<p>&#x2F;dev：设备管理器</p>
<p>&#x2F;etc：所有的系统管理所需要的配置文件和子目录</p>
<p>&#x2F;home：存放普通用户的主目录，在Linux中每一个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</p>
<p>&#x2F;lib：系统开机所需要最基本的动态连接共享库</p>
<p>&#x2F;media：Linux系统会自动识别一些设备，如U盘、光驱等，当识别后，Linux会把识别的设备挂载到这个目录下</p>
<p>&#x2F;opt：这是给主机额外安装软件所摆放的目录，如安装MySQL数据库就可放到该目录下</p>
<p>&#x2F;root：超级用户的用户主目录</p>
<p>&#x2F;boot：存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件</p>
<p>&#x2F;sbin：存放超级用户的指令</p>
<p>&#x2F;sys：系统</p>
<p>&#x2F;tmp：临时文件夹</p>
<p>&#x2F;usr：用户很多应用程序和文件都放在这个目录下</p>
<p>&#x2F;usr&#x2F;local：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码方式安装的程序</p>
<p>&#x2F;var：这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件</p>
<hr>
<h2 id="远程登录Linux系统"><a href="#远程登录Linux系统" class="headerlink" title="远程登录Linux系统"></a>远程登录Linux系统</h2><p>XShell（远程登录到Linux的软件）</p>
<p>XFtp（上传和下载文件的软件）</p>
<p>特别说明：如果希望安装好 XShell5 就可以远程访问 Linux系统的话，需要 Linux 启用了 SSHD 服务，该服务会监听22号端口</p>
<h3 id="XShell远程操作"><a href="#XShell远程操作" class="headerlink" title="XShell远程操作"></a>XShell远程操作</h3><p>1、XShell创建会话</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220314142911201-16472393535309.png" alt="image-20220314142911201"></p>
<p>2、Linux开启SSHD服务</p>
<p>ssh服务安装命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>启动ssh服务命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ssh start</span><br></pre></td></tr></table></figure>

<p>查看服务是否正确启动命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -e | grep ssh</span><br></pre></td></tr></table></figure>



<p>3、连接后即可远程操作</p>
<h3 id="XFtp远程传输文件"><a href="#XFtp远程传输文件" class="headerlink" title="XFtp远程传输文件"></a>XFtp远程传输文件</h3><p>创建会话</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220314151907888.png" alt="image-20220314151907888"></p>
<p>解决XFtp乱码</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220314152131762.png" alt="image-20220314152131762"></p>
<hr>
<h2 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h2><p><strong>介绍</strong></p>
<p>vim具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富</p>
<h3 id="vim三种模式"><a href="#vim三种模式" class="headerlink" title="vim三种模式"></a>vim三种模式</h3><p><strong>正常模式</strong></p>
<p>以vim打开一个档案就直接进入正常模式，在正常模式下可以使用快捷键</p>
<p><strong>插入模式</strong></p>
<p>可以输入内容，正常模式下按 i 可以进入插入模式</p>
<p><strong>命令行模式</strong></p>
<p>可以使用相关指令，完成读取、存盘、替换、离开vim、显示行号等</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220314161121394-164724559315210.png" alt="image-20220314161121394"></p>
<h3 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h3><p>yy：复制当前行，5yy表示复制当前行的下面5行，以此类推</p>
<p>p：粘贴</p>
<p>dd：删除当前行，5dd表示删除当前行的下面5行，以此类推</p>
<p>&#x2F;关键字：在文件中查找指定的关键字，按 n 切换下一个关键字</p>
<p>：set nu &#x2F; ：set nonu：开启或关闭行号</p>
<p>G：到文件的末行</p>
<p>gg：到文件的首行</p>
<p>u：撤销一个动作</p>
<p>shift+g：将光标移动到指定行号</p>
<p>​        第一步：打开行号 ：set nu</p>
<p>​        第二步：输入行号</p>
<p>​        第三部：按下shift+g</p>
<hr>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><h3 id="关机-amp-重启命令"><a href="#关机-amp-重启命令" class="headerlink" title="关机&amp;重启命令"></a>关机&amp;重启命令</h3><p>shutdown：</p>
<ul>
<li><p>shutdown -h now：立即关机</p>
</li>
<li><p>shutdown -h 1：一分钟之后关机</p>
</li>
<li><p>shutdown -r now：立即重启计算机</p>
</li>
</ul>
<p>halt：立即关机</p>
<p>reboot：立即重启</p>
<p>sync：将内存的数据同步到磁盘</p>
<h3 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h3><p>su：切换用户</p>
<p>logout：注销用户，图形界面无效</p>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220314202357172.png" alt="image-20220314202357172"></p>
<p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p>
<p><strong>Linux的用户至少要属于一个用户组</strong></p>
<p><strong>添加用户</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号]</span><br><span class="line"></span><br><span class="line">// 若没有指定哪个组，则会创建一个跟用户名同名的组，并放入</span><br><span class="line">例：useradd -d 指定家目录 用户名 // 指定用户的家目录 </span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-c&lt;备注&gt; 　		加上备注文字。备注文字会保存在passwd的备注栏位中。</span><br><span class="line">-d&lt;登入目录&gt; 　		指定用户登入时的起始目录。</span><br><span class="line">-D 　			变更预设值．</span><br><span class="line">-e&lt;有效期限&gt; 　		指定帐号的有效期限。</span><br><span class="line">-f&lt;缓冲天数&gt; 　		指定在密码过期后多少天即关闭该帐号。</span><br><span class="line">-g&lt;群组&gt; 　		指定用户所属的群组。</span><br><span class="line">-G&lt;群组&gt; 　		指定用户所属的附加群组。</span><br><span class="line">-m 　			自动建立用户的登入目录。</span><br><span class="line">-M 　			不要自动建立用户的登入目录。</span><br><span class="line">-n 　			取消建立以用户名称为名的群组．</span><br><span class="line">-r 　			建立系统帐号。</span><br><span class="line">-s&lt;shell&gt;　 　	指定用户登入后所使用的shell。</span><br><span class="line">-u&lt;uid&gt; 　		指定用户ID。</span><br></pre></td></tr></table></figure>



<p><strong>给用户指定密码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd [-k] [-l] [-u [-f]] [-d] [-S] 用户名</span><br><span class="line"></span><br><span class="line">必要参数：</span><br><span class="line">-d 		删除密码</span><br><span class="line">-f 		强迫用户下次登录时必须修改口令</span><br><span class="line">-w 		口令要到期提前警告的天数</span><br><span class="line">-k 		更新只能发送在过期之后</span><br><span class="line">-l 		停止账号使用</span><br><span class="line">-S 		显示密码信息</span><br><span class="line">-u 		启用已被停止的账户</span><br><span class="line">-x 		指定口令最长存活期</span><br><span class="line">-g		修改群组密码</span><br><span class="line">		指定口令最短存活期</span><br><span class="line">-i 		口令过期后多少天停用账户</span><br></pre></td></tr></table></figure>



<p><strong>删除用户</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel [-r] 用户名</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-r 		删除用户登入目录以及目录中所有文件。</span><br></pre></td></tr></table></figure>



<p><strong>查询用户信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> 用户名</span><br></pre></td></tr></table></figure>

<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220314211326880-16472636084721.png" alt="image-20220314211326880"></p>
<p><strong>切换用户</strong></p>
<p>在操作Linux过程中，如果当前用户的权限不够时，可以通过 su 指令来切换到高权限用户，比如root用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su 用户名</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">从权限高的用户切换到权限低的用户，不需要输入密码，反之需要</span><br><span class="line">需要返回到原来的用户时，使用<span class="built_in">exit</span>指令</span><br></pre></td></tr></table></figure>





<h3 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h3><p>类似于角色，系统可以对有共性的多个用户进行统一的管理</p>
<p><strong>新增一个组</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd [-g gid [-o]] [-r] [-f] 组名</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-g：指定新建工作组的 <span class="built_in">id</span>；</span><br><span class="line">-r：创建系统工作组，系统工作组的组ID小于 500；</span><br><span class="line">-K：覆盖配置文件 <span class="string">&quot;/ect/login.defs&quot;</span>；</span><br><span class="line">-o：允许添加组 ID 号不唯一的工作组。</span><br><span class="line">-f,--force: 如果指定的组已经存在，此选项将失明了仅以成功状态退出。当与 -g 一起使用，并且指定的GID_MIN已经存在时，选择另一个唯一的GID（即-g关闭）。</span><br></pre></td></tr></table></figure>



<p><strong>删除一个组</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure>



<p><strong>修改用户账号的设定</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-l &lt;帐号名称&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;] 用户名</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-c&lt;备注&gt; 　		修改用户帐号的备注文字。</span><br><span class="line">-d登入目录&gt; 　		修改用户登入时的目录。</span><br><span class="line">-e&lt;有效期限&gt; 　		修改帐号的有效期限。</span><br><span class="line">-f&lt;缓冲天数&gt; 　		修改在密码过期后多少天即关闭该帐号。</span><br><span class="line">-g&lt;群组&gt; 　		修改用户所属的群组。</span><br><span class="line">-G&lt;群组&gt; 　		修改用户所属的附加群组。</span><br><span class="line">-l&lt;帐号名称&gt; 　		修改用户帐号名称。</span><br><span class="line">-L 　			锁定用户密码，使密码无效。</span><br><span class="line">-s&lt;shell&gt; 　		修改用户登入后所使用的shell。</span><br><span class="line">-u&lt;uid&gt; 　		修改用户ID。</span><br><span class="line">-U 　			解除密码锁定。</span><br></pre></td></tr></table></figure>



<p><strong>用户和组的相关文件</strong></p>
<p>&#x2F;etc&#x2F;passwd 文件</p>
<ul>
<li>用户的配置文件，记录用户的各种信息</li>
<li>格式：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录shell</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220315083637847-16473045993691.png" alt="image-20220315083637847"></p>
<p>&#x2F;etc&#x2F;shadow 文件</p>
<ul>
<li>口令（密码）的配置文件</li>
<li>格式：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</li>
</ul>
<p>&#x2F;etc&#x2F;group 文件</p>
<ul>
<li>组的配置文件，记录Linux包含的组的信息</li>
<li>格式：组名：口令：组标识号：组内用户列表</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220315084024768.png" alt="image-20220315084024768"></p>
<h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><p><strong>man获得帮助信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man [命令或配置文件] 功能：获得帮助信息</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">例如查看<span class="built_in">ls</span>命令的帮助信息</span><br><span class="line">man <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>



<p><strong>help指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> 命令</span><br></pre></td></tr></table></figure>

<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220315145533581.png" alt="image-20220315145533581"></p>
<p><strong>help与man的区别</strong></p>
<ol>
<li><p>help命令用于显示shell内部的帮助信息。help命令只能显示shell内部的命令帮助信息。而对于外部命令的帮助信息只能使用man或者info命令查看。</p>
</li>
<li><p>man命令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息。</p>
</li>
</ol>
<p>一般看信息都用查看man文档，而help只是一个简单的描述，方便，但man文档中都包含了。help 是内部命令的帮助,比如cd ，man 是外部命令的帮助，比如ls。</p>
<h3 id="文件目录类指令"><a href="#文件目录类指令" class="headerlink" title="文件目录类指令"></a>文件目录类指令</h3><p><strong>pwd指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span> 显示当前工作目录的绝对路径</span><br></pre></td></tr></table></figure>



<p><strong>ls指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">ls</span> [-alrtAFR] [name...] 查看当前目录的所有内容信息</span><br><span class="line"> </span><br><span class="line"> 参数 :</span><br><span class="line">-a 		显示所有文件及目录 (. 开头的隐藏文件也会列出)</span><br><span class="line">-l		除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</span><br><span class="line">-r 		将文件以相反次序显示(原定依英文字母次序)</span><br><span class="line">-t 		将文件依建立时间之先后次序列出</span><br><span class="line">-A 		同 -a ，但不列出 <span class="string">&quot;.&quot;</span> (目前目录) 及 <span class="string">&quot;..&quot;</span> (父目录)</span><br><span class="line">-F 		在列出的文件名称后加一符号；例如可执行档则加 <span class="string">&quot;*&quot;</span>, 目录则加 <span class="string">&quot;/&quot;</span></span><br><span class="line">-R 		若目录下有文件，则以下之文件亦皆依序列出</span><br></pre></td></tr></table></figure>



<p><strong>cd指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> [dirName]</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="built_in">cd</span> /usr/bin		 跳到 /usr/bin/ </span><br><span class="line"><span class="built_in">cd</span> ~			跳到自己的 home 目录</span><br><span class="line"><span class="built_in">cd</span> ..		跳到目前目录的上层</span><br></pre></td></tr></table></figure>



<p><strong>mkdir指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [-p] dirName</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="built_in">mkdir</span> /home/dog</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-p 		确保目录名称存在，不存在的就建一个。</span><br></pre></td></tr></table></figure>



<p><strong>rmdir指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> [-p] dirName 删除非空文件</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="built_in">rmdir</span> /home/dog</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-p 		是当子目录被删除后使它也成为空目录的话，则顺便一并删除。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注：<span class="built_in">rmdir</span>删除的是空目录，如果目录下有内容时无法删除，如需要删除非空目录，使用：</span><br><span class="line">    <span class="built_in">rm</span> -rf 需删除的目录</span><br></pre></td></tr></table></figure>



<p><strong>touch指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> dirName 创建一个空文件</span><br></pre></td></tr></table></figure>



<p><strong>cp指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> [options] <span class="built_in">source</span>（原文件） directory（目标目录） 拷贝文件到指定目录</span><br><span class="line"></span><br><span class="line">注：\<span class="built_in">cp</span> -r <span class="built_in">test</span>/ target/  如果<span class="built_in">test</span>在target目录中存在则强制覆盖</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-a：		此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</span><br><span class="line">-d：		复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。</span><br><span class="line">-f：		覆盖已经存在的目标文件而不给出提示。</span><br><span class="line">-i：		与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。</span><br><span class="line">-p：		除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</span><br><span class="line">-r：		若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</span><br><span class="line">-l：		不复制文件，只是生成链接文件。</span><br></pre></td></tr></table></figure>



<p><strong>rm指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> [options] 文件名/目录名 	移除文件或目录</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-i 		删除前逐一询问确认。</span><br><span class="line">-f 		即使原档案属性设为唯读，亦直接删除，无需逐一确认。</span><br><span class="line">-r 		递归将目录及以下之档案亦逐一删除。</span><br></pre></td></tr></table></figure>



<p><strong>mv指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> oldName newName	重命名文件（把当前目录下的文件移动到当前目录下，相当于覆盖）</span><br><span class="line"><span class="built_in">mv</span> <span class="built_in">source</span> /target	移动文件</span><br></pre></td></tr></table></figure>



<p><strong>cat指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> [-AbeEnstTuv] 文件名		查看文件内容，只能浏览文件，而不能修改文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-n：		由 1 开始对所有输出的行数编号。</span><br><span class="line">-b：		和 -n 相似，只不过对于空白行不编号。</span><br><span class="line">-s：		当遇到有连续两行以上的空白行，就代换为一行的空白行。</span><br><span class="line">-v：		使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</span><br><span class="line">-E：		在每行结束处显示 $。</span><br><span class="line">-T：		将 TAB 字符显示为 ^I。</span><br><span class="line">-A：		等价于 -vET。</span><br><span class="line">-e：		等价于<span class="string">&quot;-vE&quot;</span>选项；</span><br><span class="line">-t：		等价于<span class="string">&quot;-vT&quot;</span>选项；</span><br></pre></td></tr></table></figure>



<p><strong>more指令</strong></p>
<p>more指令是一个基于 vi 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220315204411492.png" alt="image-20220315204411492"></p>
<img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220315214357749.png" alt="image-20220315214357749" style="zoom:50%;">



<p><strong>less指令</strong></p>
<p>less指令用分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。<strong>less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件有较高的效率</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less [参数] 文件 </span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-b 		&lt;缓冲区大小&gt; 设置缓冲区的大小</span><br><span class="line">-e 		当文件显示结束后，自动离开</span><br><span class="line">-f 		强迫打开特殊文件，例如外围设备代号、目录和二进制文件</span><br><span class="line">-g 		只标志最后搜索的关键词</span><br><span class="line">-i 		忽略搜索时的大小写</span><br><span class="line">-m 		显示类似more命令的百分比</span><br><span class="line">-N 		显示每行的行号</span><br><span class="line">-o 		&lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class="line">-Q 		不使用警告音</span><br><span class="line">-s 		显示连续空行为一行</span><br><span class="line">-S 		行过长时间将超出部分舍弃</span><br><span class="line">-x 		&lt;数字&gt; 将<span class="string">&quot;tab&quot;</span>键显示为规定的数字空格</span><br><span class="line">/字符串：向下搜索<span class="string">&quot;字符串&quot;</span>的功能</span><br><span class="line">?字符串：向上搜索<span class="string">&quot;字符串&quot;</span>的功能</span><br><span class="line">-n		重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">-N		反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">-b 		向上翻一页</span><br><span class="line">-d 		向后翻半页</span><br><span class="line">-h 		显示帮助界面</span><br><span class="line">-Q 		退出less 命令</span><br><span class="line">-u 		向前滚动半页</span><br><span class="line">-y 		向前滚动一行</span><br><span class="line">空格键 	滚动一页</span><br><span class="line">回车键 	滚动一行</span><br><span class="line">[pagedown]： 向下翻动一页</span><br><span class="line">[pageup]： 向上翻动一页</span><br></pre></td></tr></table></figure>



<p>&gt;指令 和 &gt;&gt;指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&gt;&quot;</span> 是输出到文件中, 如果文件存在, 则原来的内容被清空, 不存在则创建文件</span><br><span class="line"><span class="string">&quot;&gt;&gt;&quot;</span>是把输出追加到文件中, 如果文件存在, 追加到末尾, 不存在则创建文件</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="built_in">ls</span> -l &gt; a.txt			将列表的内容写入a.txt中（覆盖写）</span><br><span class="line"><span class="built_in">ls</span> -l &gt;&gt; a.txt			将列表的内容写入a.txt的末尾</span><br><span class="line"><span class="built_in">cat</span> b.txt &gt; a.txt		将b.txt的内容写入a.txt（覆盖写）</span><br><span class="line"><span class="built_in">cat</span> b.txt &gt;&gt; a.txt		将b.txt的内容写入a.txt的末尾</span><br><span class="line"></span><br><span class="line">总结：就是将原本要在终端展示的内容写入某个文件中</span><br></pre></td></tr></table></figure>



<p>echo指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 输出内容到控制台</span><br></pre></td></tr></table></figure>

<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220316200542740.png" alt="image-20220316200542740"></p>
<p>head指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> [参数] [文件]		</span><br><span class="line"> 可用于查看文件的开头部分的内容，有一个常用的参数 -n 用于显示行数，默认为 10，即显示 10 行的内容。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-q 		隐藏文件名</span><br><span class="line">-v 		显示文件名</span><br><span class="line">-c&lt;数目&gt; 显示的字节数。</span><br><span class="line">-n&lt;行数&gt; 显示的行数。</span><br></pre></td></tr></table></figure>



<p>tail指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> [参数] [文件]		可用于查看文件的尾部部分的内容</span><br><span class="line"></span><br><span class="line">有一个常用的参数 -f 常用于查阅正在改变的日志文件。<span class="built_in">tail</span> -f filename 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</span><br><span class="line">注：只能展示追加的东西 即 &gt;&gt; 指令追加的东西</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-f 		循环读取</span><br><span class="line">-q 		不显示处理信息</span><br><span class="line">-v 		显示详细的处理信息</span><br><span class="line">-c&lt;数目&gt; 显示的字节数</span><br><span class="line">-n&lt;行数&gt; 显示文件的尾部 n 行内容</span><br><span class="line">--pid=PID 与-f合用,表示在进程ID,PID死掉之后结束</span><br><span class="line">-q 		从不输出给出文件名的首部</span><br><span class="line">-s 		与-f合用,表示在每次反复的间隔休眠S秒</span><br></pre></td></tr></table></figure>



<p>ln指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> [参数][源文件或目录][目标文件或目录]		</span><br><span class="line">它的功能是为某一个文件在另外一个位置建立一个同步的链接。类似于windows里的快捷方式</span><br><span class="line"></span><br><span class="line">命令参数</span><br><span class="line"></span><br><span class="line">必要参数：</span><br><span class="line">-b 		删除，覆盖以前建立的链接</span><br><span class="line">-d 		允许超级用户制作目录的硬链接</span><br><span class="line">-f 		强制执行</span><br><span class="line">-i 		交互模式，文件存在则提示用户是否覆盖</span><br><span class="line">-n 		把符号链接视为一般目录</span><br><span class="line">-s 		软链接(符号链接)</span><br><span class="line">-v 		显示详细的处理过程</span><br><span class="line"></span><br><span class="line">选择参数：</span><br><span class="line">-S 		<span class="string">&quot;-S&lt;字尾备份字符串&gt; &quot;</span>或 <span class="string">&quot;--suffix=&lt;字尾备份字符串&gt;&quot;</span></span><br><span class="line">-V 		<span class="string">&quot;-V&lt;备份方式&gt;&quot;</span>或<span class="string">&quot;--version-control=&lt;备份方式&gt;&quot;</span></span><br><span class="line">--<span class="built_in">help</span> 		显示帮助信息</span><br><span class="line">--version 	显示版本信息</span><br></pre></td></tr></table></figure>

<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220316203532753.png" alt="image-20220316203532753"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220316203612420.png" alt="image-20220316203612420"></p>
<p>history指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">history</span> 		查看已经执行过的历史命令，也可以执行历史命令</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="built_in">history</span> 5		查看最近5条命令</span><br><span class="line">！277 			执行历史的第277条指令</span><br></pre></td></tr></table></figure>





<h3 id="时间日期类指令"><a href="#时间日期类指令" class="headerlink" title="时间日期类指令"></a>时间日期类指令</h3><p>date指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span>		显示当前时间</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="built_in">date</span>+%Y		显示当前年份</span><br><span class="line"><span class="built_in">date</span>+%m		显示当前月份</span><br><span class="line"><span class="built_in">date</span>+%d		显示当前是哪一天</span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> -s 2022-3-15	设置日期</span><br></pre></td></tr></table></figure>



<p>cal指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cal		显示日历</span><br></pre></td></tr></table></figure>





<h3 id="搜索查找类指令"><a href="#搜索查找类指令" class="headerlink" title="搜索查找类指令"></a>搜索查找类指令</h3><p>find指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find  +  目录名称  +  参数</span><br><span class="line">用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-name		按名称查找（find /home -name hello.txt）</span><br><span class="line">-user		按用户名查找</span><br><span class="line">-size		按文件大小查找（大于+、小于-、等于）（find / -size +20M）</span><br></pre></td></tr></table></figure>



<p>locate指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate [-d ][--<span class="built_in">help</span>][--version][范本样式...]</span><br><span class="line"></span><br><span class="line">用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。</span><br><span class="line">locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称以及路径的locate数据库实现快速定位给定的文件。locate指令无需遍历整个文件系统，查询速度较快，为了保证查询结果的准确度，管理员必须定期更新locate时刻</span><br><span class="line"></span><br><span class="line">注：由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-b 		仅匹配路径名的基本名称</span><br><span class="line">-c 		只输出找到的数量</span><br><span class="line">-d 		使用 DBPATH 指定的数据库，而不是默认数据库 /var/lib/mlocate/mlocate.db</span><br><span class="line">-e 		仅打印当前现有文件的条目</span><br><span class="line">-1 		如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。</span><br><span class="line">-0 		在输出上带有NUL的单独条目</span><br><span class="line">-S 		不搜索条目，打印有关每个数据库的统计信息</span><br><span class="line">-q 		安静模式，不会显示任何错误讯息。</span><br><span class="line">-P 		检查文件存在时不要遵循尾随的符号链接</span><br><span class="line">-l 		将输出（或计数）限制为LIMIT个条目</span><br><span class="line">-n 		至多显示 n个输出。</span><br><span class="line">-m 		被忽略，为了向后兼容</span><br><span class="line">-r 		使用基本正则表达式</span><br><span class="line">-s 		被忽略，为了向后兼容</span><br><span class="line">-o 		指定资料库存的名称。</span><br><span class="line">-h 		显示帮助</span><br><span class="line">-i 		忽略大小写</span><br><span class="line">-V 		显示版本信息</span><br></pre></td></tr></table></figure>



<p>grep指令和管道符号 |</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep		过滤查找</span><br><span class="line">|			表示将前一个命令的处理结果输出传递给后面的命令处理</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="built_in">cat</span> a.txt | grep <span class="built_in">yes</span>		查找a.txt文件中<span class="built_in">yes</span>的语句</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">-a 或 --text : 不要忽略二进制的数据。</span><br><span class="line">-A&lt;显示行数&gt; 或 --after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。</span><br><span class="line">-b 或 --byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。</span><br><span class="line">-B&lt;显示行数&gt; 或 --before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。</span><br><span class="line">-c 或 --count : 计算符合样式的列数。</span><br><span class="line">-C&lt;显示行数&gt; 或 --context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。</span><br><span class="line">-d &lt;动作&gt; 或 --directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</span><br><span class="line">-e&lt;范本样式&gt; 或 --regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。</span><br><span class="line">-E 或 --extended-regexp : 将样式为延伸的正则表达式来使用。</span><br><span class="line">-f&lt;规则文件&gt; 或 --file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</span><br><span class="line">-F 或 --fixed-regexp : 将样式视为固定字符串的列表。</span><br><span class="line">-G 或 --basic-regexp : 将样式视为普通的表示法来使用。</span><br><span class="line">-h 或 --no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。</span><br><span class="line">-H 或 --with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。</span><br><span class="line">-i 或 --ignore-case : 忽略字符大小写的差别。</span><br><span class="line">-l 或 --file-with-matches : 列出文件内容符合指定的样式的文件名称。</span><br><span class="line">-L 或 --files-without-match : 列出文件内容不符合指定的样式的文件名称。</span><br><span class="line">-n 或 --line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。</span><br><span class="line">-o 或 --only-matching : 只显示匹配PATTERN 部分。</span><br><span class="line">-q 或 --quiet或--silent : 不显示任何信息。</span><br><span class="line">-r 或 --recursive : 此参数的效果和指定<span class="string">&quot;-d recurse&quot;</span>参数相同。</span><br><span class="line">-s 或 --no-messages : 不显示错误信息。</span><br><span class="line">-v 或 --invert-match : 显示不包含匹配文本的所有行。</span><br><span class="line">-V 或 --version : 显示版本信息。</span><br><span class="line">-w 或 --word-regexp : 只显示全字符合的列。</span><br><span class="line">-x --line-regexp : 只显示全列符合的列。</span><br><span class="line">-y : 此参数的效果和指定<span class="string">&quot;-i&quot;</span>参数相同。</span><br></pre></td></tr></table></figure>





<h3 id="压缩和解压类指令"><a href="#压缩和解压类指令" class="headerlink" title="压缩和解压类指令"></a>压缩和解压类指令</h3><p>gzip &#x2F; gunzip 指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip 文件名/目录名		压缩文件，只能将文件压缩为 *.gz 文件，压缩后不会保留原来的文件</span><br><span class="line">gunzip 文件名		解压缩文件</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">gzip a.txt ==&gt; a.txt.gz</span><br><span class="line">gunzip a.txt.gz ==&gt; a.txt</span><br></pre></td></tr></table></figure>



<p>zip &#x2F; unzip 指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip 文件名/目录名		用于压缩文件，压缩后的文件后缀名为 .zip，会保留源文件</span><br><span class="line">unzip 文件名	用于解压缩，会保留源文件</span><br><span class="line"></span><br><span class="line">zip参数：</span><br><span class="line">-A 		调整可执行的自动解压缩文件。</span><br><span class="line">-q 		不显示指令执行过程。</span><br><span class="line">-m 		将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。</span><br><span class="line">-t 		把压缩文件的日期设成指定的日期。</span><br><span class="line">-r 		递归处理，将指定目录下的所有文件和子目录一并处理。</span><br><span class="line">-b		&lt;工作目录&gt; 指定暂时存放文件的目录。</span><br><span class="line"></span><br><span class="line">unzip参数：</span><br><span class="line">-d		需要解压到的目录。</span><br></pre></td></tr></table></figure>



<p>tar指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar 文件名</span><br><span class="line">是打包指令，最后打包后的文件是tar.gz的文件</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">tar -zcvf a.tar.gz a1.txt a2.txt	将两个文件压缩到一个文件中</span><br><span class="line">tar -zcvf myhome.tar.gz /home/		将home目录下的文件都压缩起来</span><br><span class="line">tar -zxvf a.tar.gz  				将a.tar.gz解压到当前目录</span><br><span class="line">tar -zxvf a.tar.gz -C /opt/temp		将a.tar.gz解压到/opt/temp（temp目录需要存在）</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-c		产生.tar打包文件</span><br><span class="line">-v		显示详细信息</span><br><span class="line">-f		指定压缩后的文件名</span><br><span class="line">-z		打包同时压缩</span><br><span class="line">-x		解包.tar文件</span><br><span class="line">-C		解压到目标文件需要携带此参数</span><br></pre></td></tr></table></figure>



<h3 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h3><p>再linux中的每个用户必须属于一个组，不能独立于组外</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220319112751977.png" alt="image-20220319112751977"></p>
<p><strong>文件 &#x2F; 目录 所有者</strong></p>
<p>一般为文件的创造者，谁创建了该文件，谁就是所有者</p>
<p><strong>查看文件的所有者指令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -ahl</span><br></pre></td></tr></table></figure>

<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220319114305675.png" alt="image-20220319114305675"></p>
<p><strong>修改文件的所有者</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R newowner filename	改变文件的所有者</span><br><span class="line"><span class="built_in">chown</span> newowner:newgroup filename 改变文件的所有者和所有组</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-R		递归将目录下的所有子文件子目录修改</span><br></pre></td></tr></table></figure>

<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220319114700137.png" alt="image-20220319114700137"></p>
<p><strong>修改文件所在组</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> -R 组名 文件名</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-R		递归将目录下的所有子文件子目录修改</span><br></pre></td></tr></table></figure>



<p><strong>修改用户所在组</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -g 组名 用户名</span><br></pre></td></tr></table></figure>



<p><strong>改变用户初始登录目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -d 目录名 用户名</span><br></pre></td></tr></table></figure>





<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>权限的基本介绍：</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220320095349009.png" alt="image-20220320095349009"></p>
<ul>
<li>第一位：代表文件类型（ - 普通文件 | d 目录 | l 软连接 | c 字符设备（鼠标、键盘）| b 块文件）</li>
<li>第二~四位：表示文件拥有者的权限（r 可读 | w 可写 | x课执行）</li>
<li>第五~七位：表示与文件拥有者同一组的用户的权限</li>
<li>第八~十位：表示不与文件拥有者同组的用户的权限</li>
</ul>
<p><strong>rwx权限详解</strong></p>
<p>rwx权限还可用数字表示：r&#x3D;4、w&#x3D;2、x&#x3D;1（rwx&#x3D;4+2+1&#x3D;7）</p>
<p>rwx作用在文件</p>
<ul>
<li>r：代表可读；可以读取，查看</li>
<li>w：代表可写；可以修改，但不能删除文件，<strong>删除一个文件的前提条件是对该文件所在目录有写权限才能删除</strong></li>
<li>x：代表可执行；可以被执行</li>
</ul>
<p>rwx作用于目录</p>
<ul>
<li>r：代表可读：可以读取，ls查看目录内容</li>
<li>w：代表可写：可以修改，目录内创建、删除、重命名目录</li>
<li>x：代表可执行；可以进入该目录</li>
</ul>
<p><strong>修改权限</strong></p>
<p>通过<strong>chmod指令</strong>，可以修改文件或目录的权限</p>
<p>第一种修改方式：+、-、&#x3D; 修改权限</p>
<p>u：所有者    g：所有组    o：其他人    a：所有人</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u=rwx,g=rx,o=x a.txt 给a.txt的所有者添加rwx权限，所有组rx权限，其他人x权限</span><br><span class="line"><span class="built_in">chmod</span> o+w a.txt	给其他人加上w权限</span><br><span class="line"><span class="built_in">chmod</span> a-x a.txt	给所有人减去x权限</span><br></pre></td></tr></table></figure>



<p>第二种修改方式：通过数字变更权限</p>
<p>r&#x3D;4、w&#x3D;2、x&#x3D;1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 751 a.txt	给a.txt的所有者添加rwx权限，所有组rx权限，其他人x权限</span><br></pre></td></tr></table></figure>





<h3 id="crond-任务调度"><a href="#crond-任务调度" class="headerlink" title="crond 任务调度"></a>crond 任务调度</h3><p>概述：</p>
<ul>
<li>任务调度是指系统在某个时间执行的特定的命令或程序</li>
<li>任务调度分类：<ul>
<li>系统工作，如病毒扫描</li>
<li>个别用户工作，如对mysql数据库的备份</li>
</ul>
</li>
</ul>
<p>crontab进行定时任务的设置:略</p>
<hr>
<h2 id="Linux运行级别"><a href="#Linux运行级别" class="headerlink" title="Linux运行级别"></a>Linux运行级别</h2><p><img src="https://jjw-beiqi.github.io/2022/03/24/Linux/image-20220315085359926.png" alt="image-20220315085359926"></p>
<p><strong>指定运行级别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init [012356]</span><br></pre></td></tr></table></figure>



<p><strong>如何找回root密码</strong></p>
<p>进入单用户模式，然后修改root密码</p>
<hr>
<h2 id="Linux磁盘分区、挂载"><a href="#Linux磁盘分区、挂载" class="headerlink" title="Linux磁盘分区、挂载"></a>Linux磁盘分区、挂载</h2><h3 id="分区基础知识"><a href="#分区基础知识" class="headerlink" title="分区基础知识"></a>分区基础知识</h3><p><strong>分区的方式</strong></p>
<p>mbr分区：</p>
<p>1、最多支持四个主分区</p>
<p>2、系统只能安装在主分区</p>
<p>3、扩展分区要占一个主分区</p>
<p>4、MBR最大只支持2TB，但拥有最好的兼容性</p>
<p>gtp分区：</p>
<p>1、支持无限多个主分区</p>
<p>2、最大支持18EB的大容量</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis学习笔记</title>
    <url>/2022/03/22/MyBatis/</url>
    <content><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>MyBatis半自动框架主要解决了Hibernate全自动框架的黑盒操作，不支持对sql语句不能高定制的问题</p>
<p><a href="https://github.com/mybatis/mybatis-3">mybatis下载</a></p>
<h2 id="使用MyBatis"><a href="#使用MyBatis" class="headerlink" title="使用MyBatis"></a>使用MyBatis</h2><h3 id="不使用接口式编程"><a href="#不使用接口式编程" class="headerlink" title="不使用接口式编程"></a>不使用接口式编程</h3><p>1、引入依赖：<img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220206171143386-164636069180114.png" alt="image-20220206171143386"></p>
<p>2、创建一个数据库映射类（bean）</p>
<p>3、实现</p>
<blockquote>
<p>每一次都需要获得<strong>sqlSession对象</strong>，sqlSession相当于程序与数据库的一次会话，使用完后需要关闭，sqlSession对象通过<strong>SqlSessionFactory（数据库会话工厂）对象</strong>获得，SqlSessionFactory对象通过<strong>SqlSessionFactoryBuilder对象</strong>构建</p>
<p>每次需要查询数据库时，使用sqlSession对象的<strong>selectOne（选择一个sql语句）方法</strong>，其有两个参数（一为sql语句的唯一标识，二为sql语句需要的参数）</p>
</blockquote>
<br>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、根据xml配置文件（全局配置文件）创建一个SqlSessionFactory对象</span></span><br><span class="line"><span class="comment">     * 2、sql映射文件配置了每一个sql，以及sql的封装规则</span></span><br><span class="line"><span class="comment">     * 3、将sql映射文件注册在全局配置文件中</span></span><br><span class="line"><span class="comment">     * 4、代码：</span></span><br><span class="line"><span class="comment">     *      （1）根据全局配置文件得到SqlSessionFactory对象</span></span><br><span class="line"><span class="comment">     *      （2）使用SqlSessionFactory，获取到sqlSession对象，使用这个对象进行增删改查</span></span><br><span class="line"><span class="comment">     *          一个sqlSession代表和数据库的一次会话，用完需要关闭</span></span><br><span class="line"><span class="comment">     *      （3）使用sql语句的唯一标识来告诉MyBatis要执行哪个sql语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取sqlSession实例，能直接执行已经映射的sql语句</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：sql语句的唯一标识</span></span><br><span class="line"><span class="comment">         * 参数2：执行sql要调用参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;mapper.EmployeeMapper.selectEmp&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(employee.getLastName());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>EmployeeMapper.xml（sql语句的映射文件）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    namespace：名称空间</span></span><br><span class="line"><span class="comment">    id：唯一标识</span></span><br><span class="line"><span class="comment">    resultType：返回值类型。会自动映射 (a_b =&gt; aB)</span></span><br><span class="line"><span class="comment">    #&#123;id&#125;:从传递来的参数中取出id值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">        select * from tbl_employee where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>mybatis-config.xml（mybatis全局配置文件）</p>
<p>用于配置数据源、注册sql映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/the_test_for_db&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--将写好的sql映射文件注册到全局配置文件中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;EmployeeMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h3 id="使用接口式编程"><a href="#使用接口式编程" class="headerlink" title="使用接口式编程"></a>使用接口式编程</h3><p>1、创建EmployeeMapper接口和对应的方法</p>
<p>2、EmployeeMapper.xml（sql语句的映射文件）中的命名空间（namespace）需要改成EmployeeMapper的全类名，select标签的id需要改成对应的方法的方法名；这样就将sql映射文件与接口相对应起来了</p>
<p>3、使用sqlSession对象的<strong>getMapper方法</strong>获得EmployeeMapper接口，调用接口的方法进行操作数据库</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220322092912687.png" alt="image-20220322092912687"></p>
<br>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1、获取SqlSessionFactory对象</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> getSqlSessionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取SqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3、获取接口的实现类对象</span></span><br><span class="line">        <span class="comment">//会为接口自动创建一个代理对象，代理对象执行增删改查</span></span><br><span class="line">        <span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(employee.getLastName());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>EmployeeMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bean.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">getEmpById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>EmployeeMapper.xml（sql语句的映射文件）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;dao.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    namespace：名称空间;指定为接口的全类名</span></span><br><span class="line"><span class="comment">    id：唯一标识</span></span><br><span class="line"><span class="comment">    resultType：返回值类型。会自动映射 (a_b =&gt; aB)</span></span><br><span class="line"><span class="comment">    #&#123;id&#125;:从传递来的参数中取出id值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Employee getEmpById(Integer id);</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--select标签的id需要改成接口中方法的方法名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">        select * from tbl_employee where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p><strong>总结:</strong></p>
<ul>
<li><p><strong>SqlSession代表喝数据库的一次会话，用完必须关闭</strong></p>
</li>
<li><p><strong>SqlSession和connection一样都是非线程安全的，每次使用都要获取新的对象</strong></p>
</li>
<li><p><strong>mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象</strong></p>
</li>
<li><p><strong>两个重要的配置文件：</strong></p>
<ul>
<li><p><strong>mybatis全局配置文件：包含数据库连接池信息，事务管理器信息等……</strong></p>
</li>
<li><p><strong>sql映射文件：保存了每一个sql语句的映射信息</strong></p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h2 id="MyBatis全局配置文件"><a href="#MyBatis全局配置文件" class="headerlink" title="MyBatis全局配置文件"></a><strong>MyBatis全局配置文件</strong></h2><blockquote>
<p><font color="red"><strong>全局配置文件配置顺序：</strong></font></p>
<p><font color="red"><strong>properties &#x3D;&gt; settings &#x3D;&gt; typeAliases &#x3D;&gt; typeHandlers &#x3D;&gt; objectFactory &#x3D;&gt; objectWrapperFactory &#x3D;&gt; reflectorFactory &#x3D;&gt; plugins &#x3D;&gt; environments &#x3D;&gt; databaseIdProvider &#x3D;&gt; mappers</strong></font></p>
</blockquote>
<p>&lt;properties&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis可以使用properties来引入外部properties配置文件的内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;类路径下的资源&quot;</span> <span class="attr">url</span>=<span class="string">&quot;引入网络路径或者磁盘路径下的资源 &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>&lt;settings&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--settings包含很多重要的设置项</span></span><br><span class="line"><span class="comment">    setting用来设置每一个设置项--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUpderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;是否开启自动驼峰命名法映射&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>&lt;typeAliases&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--别名处理器，可以为我们的java类型起别名，别名不区分大小写--&gt;</span><br><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;typeAlias type=&quot;指定要其别名的类的全类名；默认名是类名小写&quot; alias=&quot;指定新的别名&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--批量起别名，可以为某个包下的所有类批量起别名--&gt;</span><br><span class="line">    &lt;package name=&quot;指定包名（为当前以及下面所有的包都起一个默认别名）&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--可以使用@Alias注解为某个类型指定新的别名--&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>



<p>&lt;typeHandlers&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--架起数据库和java程序的连接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>&lt;plugins&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!----&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>&lt;enviroments&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--环境，mybatis可以配置多种环境</span></span><br><span class="line"><span class="comment">	environment:配置一个具体的环境信息，必须有transactionManager标签和dataSource标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enviroments</span> <span class="attr">default</span>=<span class="string">&quot;选择某一个环境&quot;</span>&gt;</span> <span class="comment">&lt;!--可以在不同的情况下选择不同的环境，比如开发或者测试两个不同的情况--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enviroment</span> <span class="attr">id</span>=<span class="string">&quot;环境的唯一标识&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;事务管理器的类型(JDBC/MANAGED)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">enviroment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">enviroments</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>&lt;databaseIdProvider&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--根据你所指定的数据库厂商，提供对其他数据库厂商的sql语句支持</span></span><br><span class="line"><span class="comment">	type=&quot;DB_VENDOR&quot;：作用是得到数据库厂商的标识，mybatis根据数据库厂商标识执行不同的sql</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--为不同的数据库厂商起别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pro</span>  <span class="attr">name</span>=<span class="string">&quot;Oracle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">配置之后：</span><br><span class="line"><span class="comment">&lt;!--sql映射文件</span></span><br><span class="line"><span class="comment">	databaseId=&quot;oracle&quot;</span></span><br><span class="line"><span class="comment">	配置环境environment时选择oracle数据库，即使还有一个select标签id值一样，也会选择与数据库相对应的select标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;oracle&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>&lt;mappers&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--将sql映射文件注册到全局配置中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mapper:注册一个sql映射</span></span><br><span class="line"><span class="comment">                resource:引用类路径下的sql映射文件</span></span><br><span class="line"><span class="comment">                url:引用网络或磁盘路径下的sql映射文件</span></span><br><span class="line"><span class="comment">				class:引用（注册）接口</span></span><br><span class="line"><span class="comment">                    1、有sql映射文件，名必须和接口同名，且放在接口的同名目录下</span></span><br><span class="line"><span class="comment">                    2、没有sql文件，所有的sql都是使用注解写在接口上--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;EmployeeMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;dao.EmployeeMapper&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!---批量注册--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;包名&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface EmployeeMapper &#123;</span><br><span class="line">    @Select(&quot;select * from tbl_employee where id = #&#123;id&#125;&quot;)</span><br><span class="line">    public Employee getEmpById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多环境下：</strong></p>
<p><strong>在开发环境和测试环境不同情况下，可以在enviroments标签中配置不同的环境下所需要使用的事务管理器和数据源，然后databaseIdProvider标签使用给不同的厂商起不同的别名，在sql映射文件中的select标签或其他sql语句标签中使用databaseId属性表明该sql语句适用的是哪一个数据库厂商</strong></p>
<p><font color="red"> <strong>MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。 如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。</strong> </font></p>
<hr>
<h2 id="MyBatis映射文件"><a href="#MyBatis映射文件" class="headerlink" title="MyBatis映射文件"></a>MyBatis映射文件</h2><h3 id="MyBatis的CRUD操作"><a href="#MyBatis的CRUD操作" class="headerlink" title="MyBatis的CRUD操作"></a>MyBatis的CRUD操作</h3><p>insert语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--插入sql语句--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--parameterType:可以省略</span></span><br><span class="line"><span class="comment">	useGeneratedKeys:是否开启自增主键，仅对 insert 和 update 有用，这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	keyProperty:返回自增的主键到参数中的某个属性，需要搭配useGeneratedKeys使用，仅对 insert 和 update 有用，唯一标记一个属性，获得的主键值将会赋值给该属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmp&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;bean.Employee&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into tbl_employee(last_name,email,gender)</span><br><span class="line">    values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line">    <span class="comment">&lt;!--#&#123;&#125;表示从传递来的对象中取出大括号内的属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对于一些不提供主键自增功能的数据库，如Oracle，需要使用selectKey标签来获取主键的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into USER(id,user_name,password) </span><br><span class="line">    values(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;) </span><br><span class="line">    <span class="comment">&lt;!-- order:after 在插入之后再赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">order</span>=<span class="string">&quot;AFTER&quot;</span>&gt;</span></span><br><span class="line">        SELECT LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span> </span><br></pre></td></tr></table></figure>



<p>update语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--更新sql语句--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmp&quot;</span>&gt;</span></span><br><span class="line">    update tbl_employee set last_name=#&#123;lastName&#125;,email=#&#123;email&#125;,gender=#&#123;gender&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>delete语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--删除sql语句--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteEmpById&quot;</span>&gt;</span></span><br><span class="line">    delete from tbl_employee where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--主线程中增删改操作需要手动提交事务--&gt;</span></span><br><span class="line">sqlSession.commit();</span><br><span class="line"><span class="comment">&lt;!--若opensession()方法中的参数为true则会自动提交事务--&gt;</span></span><br><span class="line">sqlSessionFactory.openSession(true)</span><br></pre></td></tr></table></figure>



<p>select语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- resultType 返回值类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--select返回list类型</span></span><br><span class="line"><span class="comment">	resultType：如果返回的是一个集合，要写集合中的元素类型--&gt;</span></span><br><span class="line">public List<span class="tag">&lt;<span class="name">Employee</span>&gt;</span> getEmpByLastNameLike(String lastName);	(java)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByLastNameLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where last_name like #&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--select返回Map&lt;Integer,Employee&gt;类型</span></span><br><span class="line"><span class="comment">	resultType：如果返回的是一个集合，要写集合中的元素类型--&gt;</span></span><br><span class="line">@MapKey(&quot;id&quot;) <span class="comment">&lt;!--表明以id作为map的key--&gt;</span></span><br><span class="line">public Map&lt;Integer,Employee&gt; getEmpByLastNameLike(String lastName);	(java)    </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByLastNameLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where last_name like #&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="关联映射"><a href="#关联映射" class="headerlink" title="关联映射"></a><strong>关联映射</strong></h3><p><strong>类之间关系</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220326093646175.png" alt="image-20220326093646175"></p>
<p><strong>数据库表之间关系</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220326093710254.png" alt="image-20220326093710254"></p>
<h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义某个javaBean的封装规则</span></span><br><span class="line"><span class="comment">	type：自定义规则的java类型</span></span><br><span class="line"><span class="comment">	id：唯一标识--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;bean.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;MyEmp&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--指定主键列的封装规则</span></span><br><span class="line"><span class="comment">		column：指定哪一列</span></span><br><span class="line"><span class="comment">		property：指定对应的javaBean属性名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--定义普通列封装规则--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--其他不指定的列如果列名一致会自动封装；如果使用resultMap建议全写--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--resultMap:自定义结果集映射规则</span></span><br><span class="line"><span class="comment">	resultMap不能跟resultType一起使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByMap&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyEmp&quot;</span> &gt;</span></span><br><span class="line">    select * from tbl_employee where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="一对一关系映射"><a href="#一对一关系映射" class="headerlink" title="一对一关系映射"></a>一对一关系映射</h4><p><strong>方式一：</strong>使用自动映射处理一对一关系，也就是通过别名自动将值匹配到对应的字段上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserAndShoopingCartById&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">&quot;com.mybatis.entity.User&quot;</span>&gt;</span></span><br><span class="line">    select u.id, u.user_name userName, u.password,</span><br><span class="line">        s.cart_id &quot;shoppingCart.id&quot;,</span><br><span class="line">        s.price &quot;shoppingCart.price&quot;</span><br><span class="line">    from User u</span><br><span class="line">    left join shopping_cart s on u.id = s.user_id</span><br><span class="line">    where u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p><strong>方式二：</strong>在XML映射文件中配置结果映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">关联查询</span></span><br><span class="line"><span class="comment">    场景一：查询Employee的同时查询员工对应的部门</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!----------------------方法一-------------------------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;MyEmp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--dept就是Employee类型中的Department属性的属性名--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id和deptName是Department类型的成员变量名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.id&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyEmp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里由于两张表都有id属性 所以需要给他们起别名来区分--&gt;</span></span><br><span class="line">    select e.id id, e.last_name last_name, e.gender gender ,e.email email ,e.d_id d_id</span><br><span class="line">    d.id did d.dept_name dept_name from tbl_employee e,tbl_dept d</span><br><span class="line">    where e.id = d.id and e.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>方式三：</strong>association元素用于和一个复杂的类型进行关联</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--使用association定义单个对象的封装规则--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;MyEmp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- association可以指定联合的javaBean对象</span></span><br><span class="line"><span class="comment">		property：指定哪个属性是联合的对象</span></span><br><span class="line"><span class="comment">		javaType：指定这个属性对象的类型（不能省略）</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;bean.Department&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyEmp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里由于两张表都有id属性 所以需要给他们起别名来区分--&gt;</span></span><br><span class="line">    select e.id id, e.last_name last_name, e.gender gender ,e.email email ,e.d_id d_id</span><br><span class="line">    d.id did d.dept_name dept_name from tbl_employee e,tbl_dept d</span><br><span class="line">    where e.id = d.id and e.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>方式四：</strong>association元素的嵌套查询</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">分步查询</span></span><br><span class="line"><span class="comment">    场景：现实开发中不止会有EmployeeMapper.xml 也会有DepartmentMapper.xml</span></span><br><span class="line"><span class="comment">    我们可以使用association进行分步查询</span></span><br><span class="line"><span class="comment">    1、先按照员工id查询员工信息</span></span><br><span class="line"><span class="comment">    2、根据查询员工信息中的d_id值去部门表查出部门信息</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!------------------DepartmentMapper.xml--------------------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;dao.DepartmentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Department&quot;</span>&gt;</span></span><br><span class="line">        select * from tbl_department where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!------------------EmployeeMapper.xml---------------------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;MyEmp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- association可以指定联合的javaBean对象</span></span><br><span class="line"><span class="comment">		property：指定哪个属性是联合的对象</span></span><br><span class="line"><span class="comment">		select:表明当前属性是调用select指定的方法查出的结果（就是DepartmentMapper.xml sql映射文件绑定的方法）</span></span><br><span class="line"><span class="comment">		column：指定将哪一列的值传递给这个方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，然后封装给peoperty所指定的属性</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">select</span>=<span class="string">&quot;bean.Department.getDeptById&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">column</span>=<span class="string">&quot;d_id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyEmp&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">select e.id id, e.last_name last_name, e.gender gender ,e.email email ,e.d_id d_id</span></span><br><span class="line"><span class="comment">d.id did d.dept_name dept_name from tbl_employee e,tbl_dept d</span></span><br><span class="line"><span class="comment">where e.id = d.id and e.id = #&#123;id&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>



<p>注：我们每次查询Employee对象的时候，Department对象都会一并查询出来</p>
<p>但是我们不一定去使用Department对象，这样就造成资源浪费，我们可以在分段查询的基础上在全局配置文件中加上两个配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用延迟加载（懒加载）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-------------------------mybatis-config.xml---------------------------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settrings</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> <span class="comment">&lt;!--懒加载，所关联的值在使用时候才加载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span> <span class="comment">&lt;!--侵略性懒加载，在需要任何一个属性时候就加载全部属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settrings</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="一对多关系映射"><a href="#一对多关系映射" class="headerlink" title="一对多关系映射"></a>一对多关系映射</h4><p><strong>类之间关系</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220326093537007.png" alt="image-20220326093537007"></p>
<p><strong>数据库表之间关系</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220326093611193.png" alt="image-20220326093611193"></p>
<p><strong>方式一：</strong>与association类似，集合的嵌套结果映射就是指通过一次SQL查询得到所有的结果</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--场景二：查询每个部门的同时查询出该部门的员工列表--&gt;</span></span><br><span class="line">public class Department&#123;</span><br><span class="line">	...</span><br><span class="line">    private List<span class="tag">&lt;<span class="name">Employee</span>&gt;</span> emps;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!-----------方法一：使用collection定义关联集合类型的属性的封装规则 ------------&gt;</span></span><br><span class="line"><span class="comment">&lt;!------------------DepartmentMapper.xml--------------------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;MyDept&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bean.Department&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collection定义关联集合类型的属性的封装规则 </span></span><br><span class="line"><span class="comment">		ofType：指定集合里面元素的类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">porperty</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义集合中元素的封装规则--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--为什么这里不用查Department呢？因为这里前面Department的封装规则已经表明了当前查出来的Department是与里面封装的这个Employee是有关联的--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- did		dept_name		eid		last_name		gender		email --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyDept&quot;</span>&gt;</span></span><br><span class="line">    select d.id did d.dept_name dept_name, </span><br><span class="line">		e.id eid, e.last_name last_name, e.gender gender ,e.email email </span><br><span class="line">    from tbl_dept d</span><br><span class="line">    left join tbl_employee e</span><br><span class="line">    on d.id = e.d_id</span><br><span class="line">	where d.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p><strong>方式二：</strong>集合的嵌套查询同样会执行额外的SQL查询</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-----------方法二：分步查询------------&gt;</span></span><br><span class="line"><span class="comment">&lt;!--流程：</span></span><br><span class="line"><span class="comment">1、先查出Department的id和dept_name</span></span><br><span class="line"><span class="comment">2、再调用Employee中的getEmpByDeptId方法查出员工列表</span></span><br><span class="line"><span class="comment">3、通过collection标签将其封装到Dpartment的emps属性中</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!------------------DepartmentMapper.xml--------------------&gt;</span>    </span><br><span class="line"> <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;MyDept&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bean.Department&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collection定义关联集合类型的属性的封装规则 </span></span><br><span class="line"><span class="comment">		select:指定需要使用哪个方法查询</span></span><br><span class="line"><span class="comment">		column:指定需要传递的参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">porperty</span>=<span class="string">&quot;emps&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">select</span>=<span class="string">&quot;bean.Employee.getEmpByDeptId&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 扩展：</span></span><br><span class="line"><span class="comment">	多列值传递过去：将多列值封装map传递</span></span><br><span class="line"><span class="comment">		column=&quot;&#123;key=columnName,...&#125;&quot; 如 column=&quot;&#123;deptId=id,deptName=dept_name&#125;&quot;</span></span><br><span class="line"><span class="comment">	延迟加载：fetchType=&quot;lazy&quot; 也可以在全局中设置延迟加载 </span></span><br><span class="line"><span class="comment">			eager：立即加载，可以不改变全局设置，直接在这里设置参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>   </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptByIdStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;MyDept&quot;</span>&gt;</span></span><br><span class="line">    select id dept_name from tbl_dept where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-------------------EmployeeMapper.xml----------------------&gt;</span></span><br><span class="line"> public interface EmployeeMapper&#123;</span><br><span class="line">	...</span><br><span class="line">    public List<span class="tag">&lt;<span class="name">Employee</span>&gt;</span> getEmpByDeptId(integer deptId)&#123;...&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;   </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByDeptId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where d_id=#&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--扩展：鉴别器 具体使用方法在网上看--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">case</span>&gt;</span><span class="tag">&lt;/<span class="name">case</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="鉴别器映射"><a href="#鉴别器映射" class="headerlink" title="鉴别器映射"></a>鉴别器映射</h4><p>有时一个单独的数据库查询会返回很多种不同数据类型的结果集。<strong>discriminator鉴别器元素</strong>可以用来处理这种情况</p>
<p><strong>数据库表结构：</strong><img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220326095953466.png" alt="image-20220326095953466" style="zoom:50%;">    使用一张表，以某个字段标识子类</p>
<p><strong>方式一：</strong>使用discriminator鉴别器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.mybatis.entity.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;empMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">colum</span> = <span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">colum</span> = <span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">column</span>=<span class="string">&quot;employee_type&quot;</span>   </span></span><br><span class="line"><span class="tag">        <span class="attr">javaType</span>=<span class="string">&quot;String&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- value:指定额外字段的取值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;HE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;com.entity.HourlyMap&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;SE&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;com.entity.SalaryMap&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAllEmps&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;employeeMap&quot;</span>&gt;</span></span><br><span class="line">    select * from employee</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>方式二：</strong>使用extends继承父类映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.mybatis.entity.Employee&quot;</span> <span class="attr">id</span>=<span class="string">&quot;empMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">colum</span> = <span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">colum</span> = <span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- extends属性集成父类的映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.mybatis.entity.HourlyMap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hourMap&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;empMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;rate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;rate&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p>if 语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询员工</span></span><br><span class="line"><span class="comment">	要求：Employee类型中携带了哪个字段，查询条件就带上这个字段的值 --&gt;</span></span><br><span class="line">public interface EmployeeMapper&#123;</span><br><span class="line">	...</span><br><span class="line">	public List<span class="tag">&lt;<span class="name">Employee</span>&gt;</span> getEmpByConditionIf(Employee employee);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-------------------EmployeeMapper.xml----------------------&gt;</span>   </span><br><span class="line"><span class="comment">&lt;!------- if判断语句 ---------&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByConditionIf&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">	select * from tbl_employee     </span><br><span class="line">    where</span><br><span class="line">    <span class="comment">&lt;!-- test：判断表达式（OGNL表达式） </span></span><br><span class="line"><span class="comment">		从参数中取值进行判断</span></span><br><span class="line"><span class="comment">		特殊符号使用转义字符（参考文档）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">        id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;last_name!=null and lastName!=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and last_name like #&#123;lastName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null&quot;</span>&gt;</span></span><br><span class="line">        and email=#&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- ognl会进行字符串与数字的转换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender==1 or gender==0&quot;</span>&gt;</span></span><br><span class="line">        and gender=#&#123;gender&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- 内置参数：</span></span><br><span class="line"><span class="comment"> 	_databaseId 如果配置了databaseIdProvider，就是代表当前数据库的别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionDatabaseId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;mysql&#x27;&quot;</span>&gt;</span></span><br><span class="line">        select * from tbl_employee</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;_databaseId==&#x27;oracle&#x27;&quot;</span>&gt;</span></span><br><span class="line">        select * from employees</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>where语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!------- where条件语句（封装查询条件）---------&gt;</span></span><br><span class="line"><span class="comment">&lt;!--where标签将所有的查询条件包括在内。mybatis就会将where标签中拼装的sql，多出来的and或or去掉</span></span><br><span class="line"><span class="comment">	where只会去掉第一个多出来的and或or标签，比如 and id=1 and name=jjw；但不能去掉最后一个and或or，比如 id=1 and name=jjw and--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByConditionWhere&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">	select * from tbl_employee     </span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- test：判断表达式（OGNL表达式） </span></span><br><span class="line"><span class="comment">            从参数中取值进行判断</span></span><br><span class="line"><span class="comment">            特殊符号使用转义字符（参考文档）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">            id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        ....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>trim 语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!------- trim语句 ---------&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- where标签不能解决and在最后的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByConditionTrim&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">	select * from tbl_employee     </span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- trim截取标签</span></span><br><span class="line"><span class="comment">			prefix=&quot;&quot; 前缀，trim标签是整个字符串拼后的结果，prefix给拼串后的整个字符串加一个前缀</span></span><br><span class="line"><span class="comment">			prefixOverride=&quot;&quot; 前缀覆盖，去掉整个字符串前面多余的字符，可以有多个选择 例如 &quot;and|or&quot;</span></span><br><span class="line"><span class="comment">			suffix=&quot;&quot; 给拼串后的整个字符串加一个后缀</span></span><br><span class="line"><span class="comment">			suffixOverrides=&quot;&quot; 后缀覆盖，去掉整个字符串后面多余的字符，可以有多个选择 例如 &quot;and|or&quot; --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">            id=#&#123;id&#125; and </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        ....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>      </span><br></pre></td></tr></table></figure>



<p>choose 语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!------- choose条件选择语句 ---------&gt;</span>      </span><br><span class="line"><span class="comment">&lt;!-- 一个choose元素至少包含一个when子元素</span></span><br><span class="line"><span class="comment">	 一个choose元素包含 0 或 1 个otherwise子元素</span></span><br><span class="line"><span class="comment">	 choose元素可以实现类似于 if else 语句的作用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByConditionChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">	select * from tbl_employee    </span><br><span class="line">    <span class="comment">&lt;!-- 有什么就查什么 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id!=null&quot;</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">&lt;!-- 当前面所有的when子元素都不满足条件时，则执行otherwise中的条件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 其他条件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>set 语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!------- set语句（封装修改条件） ---------&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmpByConditionSet&quot;</span>&gt;</span></span><br><span class="line">	update tbl_employee</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastName!=null&quot;</span>&gt;</span></span><br><span class="line">            last_name=#&#123;lastName&#125;, <span class="comment">&lt;!--set标签会将多余的 “，” 去除--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        ....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	&lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;if test=&quot;lastName!=null&quot;&gt;</span></span><br><span class="line"><span class="comment">            last_name=#&#123;lastName&#125;, </span></span><br><span class="line"><span class="comment">        &lt;/if&gt;</span></span><br><span class="line"><span class="comment">        ....</span></span><br><span class="line"><span class="comment">    &lt;/trim&gt;</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>foreach 语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!------- foreach语句（封装修改条件） ---------&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByConditionForeach&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">	select * from tbl_employee where id in</span><br><span class="line">    	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">			collection：指定要遍历的集合</span></span><br><span class="line"><span class="comment">			item：将当前遍历出的元素赋值给变量</span></span><br><span class="line"><span class="comment">			separator：每个元素之间的分隔符</span></span><br><span class="line"><span class="comment">			open、close：拼接上开始 或 结束字符 </span></span><br><span class="line"><span class="comment">			index：索引，当参数为Map类型时，为Map的key</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item_id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;item_id&#125;</span><br><span class="line">    	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用foreach实现批量插入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmps&quot;</span>&gt;</span></span><br><span class="line">	insert into tbl_employee(last_name,email,gender,d_id)</span><br><span class="line">    values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">cllection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;emp.lastName&#125;,#&#123;emp.email&#125;,#&#123;emp.gender&#125;,#&#123;emp.dept.id &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span>  </span><br></pre></td></tr></table></figure>



<p>bind 标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bind标签</span></span><br><span class="line"><span class="comment">	bind 可以将OGNL表达式的值绑定到一个变量中，方便后来引用这个变量值，相当于定义了一个新的变量方便使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;_lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;_&#x27;+lastName+&#x27;%&#x27;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpsByConditionBind&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where last_name like #&#123;_lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure>



<p>抽取可重用的sql片段</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--抽取可重用的sql片段，方便后面引用--&gt;</span>        </span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertColumn&quot;</span>&gt;</span></span><br><span class="line">	id, last_name, email      </span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">insert into tbl_employees(</span><br><span class="line">        <span class="comment">&lt;!--引用外部定义的sql语句--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertColumn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">) ...</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="MyBatis参数处理"><a href="#MyBatis参数处理" class="headerlink" title="MyBatis参数处理"></a>MyBatis参数处理</h2><p><strong>单个参数</strong>：mybatis不会做特殊处理</p>
<p>​    #{参数名}：取出参数</p>
<p><strong>多个参数</strong>：mybatis会做特殊处理，多个参数会被封装成一个map，#{}就是从map中获取指定的key的值</p>
<p>​    #{param1}…#{paramN} 或者 参数的索引也可以</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;mysql&quot;</span> &gt;</span></span><br><span class="line">    select * from tbl_employee where id = #&#123;agr0&#125; and last_name = #&#123;arg1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;mysql&quot;</span> &gt;</span></span><br><span class="line">    select * from tbl_employee where id = #&#123;param1&#125; and last_name = #&#123;param2&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>命名参数</strong>：明确指定封装参数时map的key</p>
<p>​    #{命名}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Employee <span class="title function_">getEmpById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id,<span class="meta">@Param(&quot;lastName&quot;)</span> String lastName)</span>;</span><br></pre></td></tr></table></figure>



<p><strong>POJO</strong>：</p>
<p>如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo</p>
<p>​    #{属性名}：取出传入的pojo的属性值</p>
<p><strong>Map</strong>：</p>
<p>如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用，为了方便，我们也可以传入map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Employee <span class="title function_">getEmpByMap</span><span class="params">(Map&lt;String,Object&gt; map)</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>,<span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;lastName&quot;</span>,<span class="string">&quot;jjw&quot;</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> mapper.getEmpByMap(map);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;bean.Employee&quot;</span> &gt;</span></span><br><span class="line">    select * from tbl_employee where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>TO</strong>：</p>
<p>如果多个参数不是业务模型中的数据，没有对应的pojo，经常使用，推荐使用一个TO数据传输对象，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page</span>&#123;</span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><font color="red">特别注意：如果是Collection（List、Set）类型或者是数组，也会特殊处理</font></strong></p>
<p>​    <strong><font color="red">#{conllection[0]}    &#x2F;（当参数为list）#{list[0]}    &#x2F;（当参数为数组）#{array[0]}</font></strong></p>
<p><strong>MyBatis参数获取：</strong></p>
<p>​    #{}：可以获取map中的值或者pojo对象属性的值；</p>
<p>​    ${}：可以获取map中的值或者pojo对象属性的值；</p>
<p><strong>区别：</strong></p>
<p>​    #{}：是以预编译的形式，将参数设置到sql语句中</p>
<p>​    ${}：取出的值直接拼装到sql语句中；会有安全问题</p>
<hr>
<h2 id="MyBatis分页插件"><a href="#MyBatis分页插件" class="headerlink" title="MyBatis分页插件"></a>MyBatis分页插件</h2><p>1、</p>
<p>普通Java项目中引入依赖    <img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220330090218686.png" alt="image-20220330090218686"></p>
<p>maven项目中引入pagehelper依赖    </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2、找到mybatis配置文件，在此文件中加入插件配置如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 插件配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">   <span class="comment">&lt;!-- 配置分页插件 --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt; --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- always总是返回PageInfo类型,check检查返回类型是否为PageInfo,none返回Page --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;property name=&quot;returnPageInfo&quot; value=&quot;always&quot;/&gt; --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>3、调用PageHelper类中的方法，实现分页的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数一：页号</span></span><br><span class="line"><span class="comment">//参数二：一页包含多少条数据</span></span><br><span class="line">PageHelper.startPage(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//下面的第一个查询方法，会按照上面的分页方式查询</span></span><br></pre></td></tr></table></figure>



<p>分页查询时，查询方法返回的List对象实际上是Page&lt;E&gt;类型，如果需要取得分页信息，需要将结果强制类型转换为Page&lt;E&gt;类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Page&lt;User&gt; userPages = (Page&lt;User&gt;)users;</span><br><span class="line">System.out.println(userPages.getTotal());<span class="comment">//总条数</span></span><br><span class="line">System.out.println(userPages.getPageNum());<span class="comment">//当前页数</span></span><br><span class="line">System.out.println(userPages.getPageSize());<span class="comment">//每页条数</span></span><br><span class="line">System.out.println(userPages.getPages());<span class="comment">//总页数</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="MyBatis缓存机制"><a href="#MyBatis缓存机制" class="headerlink" title="MyBatis缓存机制"></a>MyBatis缓存机制</h2><p>MyBatis系统中默认定义了两级缓存</p>
<p><strong>一级缓存和二级缓存</strong></p>
<ul>
<li>默认情况下只有一级缓存开启（也称为本地缓存）</li>
<li>二级缓存需要手动开启和配置，是基于namespace级别的缓存</li>
<li>MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存</li>
</ul>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220329092811934.png" alt="image-20220329092811934">

<p>sqlSession级别的缓存</p>
<p>作用：与数据库同一次会话期间查询到的数据会放在一级缓存中，是一直开启的，无法关闭</p>
<p><strong>但增删改操作不会将数据放入缓存中，还会将缓存清空</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testCache <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> getSqlSessionFactory();</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//一级缓存中使用Map存储查询结果中的对象</span></span><br><span class="line">        <span class="comment">//key值: statementid+参数 （statementId 就是接口的全限定名加上方法名）</span></span><br><span class="line">        <span class="comment">//value值:查询结果中的对象</span></span><br><span class="line">        <span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp1</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp2</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">1</span>); <span class="comment">//mapper会去一级缓存中查找，并返回上一次返回的对象</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(emp1 == emp2) <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>一级缓存失效情况（没有使用到当前一级缓存的情况，效果就是，还需要向数据库发出查询）</strong></p>
<ol>
<li>sqlSession不同</li>
<li>sqlSession相同，查询条件不同</li>
<li>sqlSession相同，两次查询之间执行了<strong>增删改操作</strong>（这次增删改可能对数据有影响）</li>
<li>sqlSession相同，手动清除了一级缓存</li>
</ol>
<ul>
<li>&#96;&#96;&#96;java<br>session.clearCache();<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**一级缓存的生命周期**</span><br><span class="line"></span><br><span class="line">- MyBatis在开启一个数据库会话时，会 创建一个新的SqlSession对象；当会话结束时，SqlSession对象也一并释放掉</span><br><span class="line">- 如果SqlSession调用了close()方法，会释放掉一级缓存，一级缓存将不可用</span><br><span class="line">- 如果SqlSession调用了clearCache()，会清空缓存，但是该对象仍可使用</span><br><span class="line">- **在SqlSession中执行了任何一个update操作、insert操作、delete操作，都会清空缓存**，但是该对象可以继续使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**MyBatis中，如果以下条件都一样，那么就认为它们是完全相同的两次查询**</span><br><span class="line"></span><br><span class="line">- 传入的 statementId （statementId 就是接口的全限定名加上方法名）</span><br><span class="line">- 查询时要求的结果集中的结果范围 </span><br><span class="line">- 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串</span><br><span class="line">- 传递给java.sql.Statement要设置的参数值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 二级缓存</span><br><span class="line"></span><br><span class="line">namespace级别的缓存，**也就是每个sql映射文件对应一个自己的二级缓存**</span><br><span class="line"></span><br><span class="line">**工作机制：**</span><br><span class="line"></span><br><span class="line">1. 一个会话，查询一条数据，这个数据就会呗放在当前会话的一级缓存中</span><br><span class="line">2. 如果会话关闭，一级缓存中的数据会被保存到二级缓存中，新的查询信息就可以参照二级缓存</span><br><span class="line">3. 不同 namespace 查出的数据会放在自己对应的缓存中（map）</span><br><span class="line"></span><br><span class="line">注：只有会话提交或关闭之后，一级缓存中的数据才会转移到二级缓存中</span><br><span class="line"></span><br><span class="line">顺序：二级缓存-&gt;一级缓存-&gt;数据库</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;MyBatis/image-20220329102144695.png&quot; alt=&quot;image-20220329102144695&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**使用：**</span><br><span class="line"></span><br><span class="line">1. 开启二级缓存配置 （需要放在 environments 标签之前）</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;!-------------------mabatis-config.xml-------------------&gt;</span><br><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>XxxMapper.xml中配置使用二级缓存</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		eviction：缓存的回收策略</span></span><br><span class="line"><span class="comment">			- LRU 最近最少使用的</span></span><br><span class="line"><span class="comment">			- FIFO 先进先出策略</span></span><br><span class="line"><span class="comment">			- SOFT 软引用，移除基于垃圾回收器状态和软引用规则的对象</span></span><br><span class="line"><span class="comment">			- WEAK 弱引用，更积极的移除基于垃圾回收器状态和软引用规则的对象</span></span><br><span class="line"><span class="comment">			默认使用的是LRU</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		flushInterval：缓存刷新间隔</span></span><br><span class="line"><span class="comment">			缓存多长时间清空一次，默认不清空，可以设置一个毫秒值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		readOnly：是否只读</span></span><br><span class="line"><span class="comment">			true：只读 mybatis认为所有从缓存中获取数据的操作都只是只读操作，不会修改数据 mybatis为了加快获取速度，直接就会将在缓存中的引用交给用户。不安全</span></span><br><span class="line"><span class="comment">			false：非只读 mybatis认为获取的数据可能会被修改 mybatis会利用序列化和反序列化技术克隆一份新的数据给你。安全</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		size：缓存多少元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		type：指定自定义缓存的全类名（实现Cache接口）</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;&quot;</span> <span class="attr">flushInterval</span>=<span class="string">&quot;&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;&quot;</span> <span class="attr">size</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>我们的POJO需要实现序列化接口</li>
</ol>
<p>@Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EmployeeMapper</span> <span class="variable">mapper1</span> <span class="operator">=</span> session1.getMapper(EmployeeMapper.class);</span><br><span class="line"><span class="type">EmployeeMapper</span> <span class="variable">mapper2</span> <span class="operator">=</span> session2.getMapper(EmployeeMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="type">Employee</span> <span class="variable">emp1</span> <span class="operator">=</span> mapper1.getEmpById(<span class="number">1</span>);</span><br><span class="line">System.out.println(emp1);</span><br><span class="line">session1.close();</span><br><span class="line"></span><br><span class="line"><span class="type">Employee</span> <span class="variable">emp2</span> <span class="operator">=</span> mapper2.getEmpById(<span class="number">1</span>);</span><br><span class="line">System.out.println(emp2);</span><br><span class="line">session2.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//只会发送一次sql查询，因为第一次关闭数据库连接之后会利用序列化和反序列化技术克隆一份新的数据在二级缓存中</span></span><br></pre></td></tr></table></figure>



<p><strong>二级缓存中脏数据产生的原因</strong></p>
<ul>
<li>通常情况下每个Mapper映射文件都有自己的二级缓存</li>
<li>有些查询需要关联多张表</li>
<li>涉及这多张表的增删改查操作通常不在一个映射文件中</li>
<li>当数据有变化时，多表查询的缓存不一定会清空，这种情况下就会出现脏数据</li>
</ul>
<p>例如：</p>
<table>
<thead>
<tr>
<th align="center">user二级缓存</th>
<th>order二级缓存</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{userid&#x3D;1，orderid&#x3D;{1，2，3}}</td>
<td>{orderid&#x3D;1}</td>
</tr>
</tbody></table>
<p><strong>如果这时候将order表中的这条数据删除，只会影响到order二级缓存中的数据，而不会影响到user二级缓存中的数据，造成数据脏读，我们可以让多个Mapper公用一个Cache缓存来解决问题</strong></p>
<p>如果想让多个Mapper公用一个Cache缓存，可以使用<strong>&lt;cache-ref namespace&#x3D;””&gt;<strong>元素配置参照缓存，这样不仅能减少配置项，</strong>还能解决脏读问题</strong></p>
<img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220329105735375.png" alt="image-20220329105735375" style="zoom: 80%;">



<p><strong>二级缓存适用场景</strong></p>
<ul>
<li>以查询为主的应用中，只有尽可能少的增、删、改操作</li>
<li>绝大多数都是单表操作时，很少出现相互关联的情况</li>
<li>如关联的表比较少，可以通过参照缓存进行配置</li>
</ul>
<p><strong>扩展：</strong></p>
<ol>
<li><p>每个 <strong>select标签</strong> 都有 <strong>userCache属性</strong></p>
<ul>
<li>true：可以使用二级缓存</li>
<li>false：不使用二级缓存</li>
</ul>
</li>
<li><p>每个<strong>增删改查标签</strong>都有 <strong>flushCache属性</strong></p>
</li>
</ol>
<p>增删改默认为true，即<strong>增删改之后就会清空一级和二级缓存</strong>，所以增删改之后再查询不会从缓存中拿，而是重新发送一次sql查询</p>
<ol start="3">
<li>sqlSession.clearCache()，只是清除一级缓存中的数据</li>
</ol>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220219164047000.png" alt="image-20220219164047000"></p>
<h2 id="ehcache缓存"><a href="#ehcache缓存" class="headerlink" title="ehcache缓存"></a>ehcache缓存</h2><p>Mybatis使用一二级缓存时采用的是map来存储数据，这样做过于简单，我们可以使用ehcache进行缓存</p>
<p>1、引入依赖：<img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220219165613257.png" alt="image-20220219165613257"><img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220219174950268.png" alt="image-20220219174950268"></p>
<p>2、在XxxMapper.xml文件中更改 cache标签 的type属性，即使用 org.mybatis.caches.ehcache.EhcachCache 作为二级缓存</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220219170820383.png" alt="image-20220219170820383"></p>
<p>也可以更改一些参数（具体参考官方文档）</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/MyBatis/image-20220219170853013.png" alt="image-20220219170853013"></p>
<p>3、增加ehcache.xml文件</p>
<p>参考：<a href="https://blog.csdn.net/tototuzuoquan/article/details/42873775">https://blog.csdn.net/tototuzuoquan/article/details/42873775</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D: \44\ehcache&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsOnDisk</span>= <span class="string">&quot;1000000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>= <span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/03/22/Redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><a href="https://github.com/microsoftarchive/redis/tags">windows版本</a></p>
<p><a href="https://blog.csdn.net/hzlarm/article/details/99432240">linux版本操作参考</a></p>
<br>

<h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>NoSQL是解决性能问题的一种技术，Redis是一种典型的NoSQL数据库</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223122352249.png" alt="image-20220223122352249"></p>
<br>

<hr>
<br>

<h2 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h2><p>Redis的操作基本都是基于内存的，CPU资源根本就不是Redis的性能瓶颈，所以Redis不需要通过多线程技术来提升CPU利用率。</p>
<p>redis是设计为为缓存使用的</p>
<p>redis所有的操作都是原子性的。采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响</p>
<h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p><strong>开启 redis 数据库</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223123433600.png" alt="image-20220223123433600"></p>
<p>在安装目录下使用 redis-server.exe  redis.windows.conf 命令打开</p>
<br>

<p><strong>help命令</strong></p>
<p>help  command 获得指定命令的帮助文档</p>
<p>help <tab> 获得一个列表的帮助文档</tab></p>
<p>help @group 获得群组的帮助文档</p>
<br>

<p><strong>set命令</strong></p>
<p>set  key  value </p>
<p>插入一个数据，以 key 为键，以 value 为值        </p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223124451651.png" alt="image-20220223124451651"></p>
<br>

<p><strong>get命令</strong></p>
<p>get  key</p>
<p>以 key 获得一个数据</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223124527201.png" alt="image-20220223124527201"></p>
<br>

<p><strong>del命令</strong></p>
<p>del  key</p>
<p>删除一个数据</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223125929261.png" alt="image-20220223125929261"></p>
<br>

<p><strong>quit、exit命令</strong></p>
<p>quit  &#x2F;  exit </p>
<p>退出客户端</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223124743380.png" alt="image-20220223124743380"></p>
<br>



<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a><strong>string</strong></h4><p>redis 自身是一个Map，其中所有的数据都是采用 key : value 的形式存储的</p>
<p>数据类型指的是存储的数据，key部分永远都是字符串 </p>
<p>如果字符串以整数的形式展示，则可以作为数字使用，但还是个字符串</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223125557894.png" alt="image-20220223125557894"></p>
<br>

<ul>
<li><p><strong>mset命令</strong></p>
<p>一次添加多个数据，添加多个数据建议使用mset，但有极大的数据，建议分割后再发送，因为执行极大量的数据会造成线程阻塞</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223130220363.png" alt="image-20220223130220363"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223130445381.png" alt="image-20220223130445381"></p>
<br>
</li>
<li><p><strong>mget命令</strong></p>
<p>一次获取多个数据，获取多个数据建议使用mget，但有极大的数据，建议分割后再发送，因为执行极大量的数据会造成线程阻塞</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223130344753.png" alt="image-20220223130344753"></p>
<br>
</li>
<li><p><strong>strlen命令</strong></p>
<p>获取某个数据的字符长度</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223130645478.png" alt="image-20220223130645478"></p>
<br>
</li>
<li><p><strong>append命令</strong></p>
<p>往一个数据的后面追加字符串</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223130817294.png" alt="image-20220223130817294"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223130751676.png" alt="image-20220223130751676"></p>
<br></li>
</ul>
<p><strong>string类型数据的扩展操作</strong></p>
<p><strong>业务场景：</strong>大型企业中，分表是基本操作，使用多张表存储相同类型数据，但是对于主键id必须要不能重复</p>
<p><strong>设置数值数据增加指定范围的值</strong></p>
<ul>
<li><p><strong>incr命令</strong></p>
<p>让指定的数据自增一</p>
</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223184032269.png" alt="image-20220223184032269"></p>
<br>

<ul>
<li><p><strong>incrby命令</strong></p>
<p>让指定的数据增加指定的值</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220224100602737.png" alt="image-20220224100602737"></p>
</li>
</ul>
<br>

<ul>
<li><p><strong>incrbyfloat命令</strong></p>
<p>让指定的数据增加指定的值（小数值）</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220224100743968.png" alt="image-20220224100743968"></p>
</li>
</ul>
<br>

<p><strong>设置数值数据减小指定范围的值</strong></p>
<ul>
<li><strong>decr命令</strong></li>
</ul>
<p>让指定的数据自减一</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220223184119282.png" alt="image-20220223184119282"></p>
<br>

<ul>
<li><p><strong>decrby命令</strong></p>
<p>让指定的数据减小指定的值（小数值）</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220224100917546.png" alt="image-20220224100917546"></p>
</li>
</ul>
<br>

<p><strong>业务场景：</strong>海选投票，只能通过微信投票，每个微信号每4小时只能投1票</p>
<ul>
<li><p><strong>setex命令</strong></p>
<p>添加一个值，并限制其过期的时间</p>
<p>setex  key  seconds value</p>
</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220224105534015.png" alt="image-20220224105534015"></p>
<ul>
<li><p><strong>psetex命令</strong></p>
<p>setex命令的毫秒版本</p>
</li>
</ul>
<br>

<p><strong>业务场景：</strong>展示某用户的粉丝数量，博客数量</p>
<p>格式一：</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220224111049219.png" alt="image-20220224111049219"></p>
<p>格式二：</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220224111258626.png" alt="image-20220224111258626"></p>
<br>

<hr>
<br>

<h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a><strong>hash</strong></h4><ul>
<li>新的存储结构：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li>
<li>需要的存储结构：一个存储空间保存多个键值对数据</li>
<li>hash类型：底层使用哈希表结构实现数据存储</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220224151853159.png" alt="image-20220224151853159"></p>
<br>

<ul>
<li><p><strong>添加 &#x2F; 修改数据</strong></p>
<br>

<p>hset  key  field  value</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset user name zhangsan</span><br><span class="line">hset user age 38</span><br><span class="line">hset user id 1</span><br></pre></td></tr></table></figure>

<p>批量添加 &#x2F; 修改数据</p>
<p>hmset  key  field1  value1  field2  value2…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hmset user name zhangsan age 38 id 1</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>获取数据</strong></p>
<br>

<p>hget  key  field</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hget user name // ==&gt; &quot;zhangsan&quot;</span><br></pre></td></tr></table></figure>

<p>hgetall  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hgetall user  // ==&gt; 单数为field</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;38&quot;</span><br><span class="line">5) &quot;id&quot;</span><br><span class="line">6) &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p>批量获取数据</p>
<p>hmget  key  field1  field2…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hmget user name age</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>删除数据</strong></p>
<br>

<p>hdel  key  field</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdel user name age id</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>获取哈希表中字段的数量</strong></p>
<br>

<p>hlen  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hlen user  // ==&gt; 3</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>获取哈希表中是否存在指定的字段</strong></p>
<br>

<p>hexists  key  field</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexists user name // ==&gt; 1 (1表示true，0表示false)</span><br></pre></td></tr></table></figure>

<br></li>
</ul>
<p><strong>hash类型数据的扩展操作</strong></p>
<ul>
<li><p><strong>获取数据</strong></p>
<br>

<p>获取哈希表中所有的键</p>
<p>hkeys  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hkeys user // ==&gt;</span><br><span class="line">1) &quot;id&quot;</span><br><span class="line">2) &quot;name&quot;</span><br><span class="line">3) &quot;age&quot;</span><br></pre></td></tr></table></figure>

<p>获取哈希表中有的值</p>
<p>hvals  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hvals user // ==&gt;</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;jjw&quot;</span><br><span class="line">3) &quot;21&quot;</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>增加 &#x2F; 减小数据</strong></p>
<br>

<p>设置指定字段的数值数据增加指定范围的值</p>
<p>hincrby  key  field  incremnet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hincrby user age 2 // ==&gt; 23</span><br></pre></td></tr></table></figure>

<p>hincrbyfloat  key  field  incremnet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hincrby user age 2。5 // ==&gt; 23.5</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<p>注：</p>
<p>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象</p>
<p>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，不可滥用</p>
<br>

<ul>
<li><p><strong>如果当前这个key中有值就不做任何操作，如果没有就添加数据</strong></p>
<p>hsetnx  key  field  value </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hsetnx user name jjw</span><br></pre></td></tr></table></figure></li>
</ul>
<br>


<hr>
<br>

<h4 id="list"><a href="#list" class="headerlink" title="list"></a><strong>list</strong></h4><ul>
<li>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</li>
<li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li>
<li>list类型：保存多个数据，底层使用双向链表存储结构实现</li>
</ul>
<br>

<ul>
<li><p><strong>添加 &#x2F; 修改数据</strong></p>
<p>左添加 &#x2F; 修改数据</p>
<p>lpush  key  value1 value2…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpush list huawei xiaomi apple</span><br></pre></td></tr></table></figure>

<p>右添加 &#x2F; 修改数据</p>
<p>rpush  key  value1  value2…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpush list huawei</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>获取数据</strong></p>
<p>按范围获取数据</p>
<p>lrange  key  start  stop</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lrange list 0 2 // ==&gt; &quot;apple&quot; &quot;xiaomi&quot; &quot;huawei&quot;</span><br></pre></td></tr></table></figure>

<p>按索引获取数据</p>
<p>lindex  key  index</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lindex list 1 // ==&gt; &quot;xiaomi&quot;</span><br></pre></td></tr></table></figure>

<p>获取list类型的长度</p>
<p>llen  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">llen list</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>获取并移除数据</strong></p>
<p>左弹出数据</p>
<p>lpop  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpop list // ==&gt; &quot;apple&quot;</span><br></pre></td></tr></table></figure>

<p>右弹出数据</p>
<p>rpop  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpop list // ==&gt; &quot;huawei&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<p><strong>list类型数据扩展操作</strong></p>
<ul>
<li><p><strong>规定时间内获取并移除数据</strong></p>
<p>左弹出（b代表阻塞，可以从多个list中获取）</p>
<p>blpop  key1  key2  timeout</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blpop list 30 // 表示如果没有可以等待30秒，30秒之后没有就算了</span><br></pre></td></tr></table></figure>

<br>

<p>右弹出</p>
<p>brpop  key1  key2  timeout</p>
<br>
</li>
<li><p><strong>移除指定数据</strong></p>
<br>

<p>从左向右删除</p>
<p>lrem  key  count(移除多少个)  value</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpush list a b c c d e</span><br><span class="line">lrem list 1 c // ==&gt; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<p>注：</p>
<ul>
<li>list中保存的数据都是string类型的，数据总容量是有限的最多2^32-1个元素</li>
<li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或栈形式</li>
<li>负数为全部数据操作结束的索引</li>
</ul>
<br>

<hr>
<br>

<h4 id="set"><a href="#set" class="headerlink" title="set"></a><strong>set</strong></h4><ul>
<li>新的存储需求：存储大量的数据，在查询方面提供更高的效率</li>
<li>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</li>
<li>set类型：与hash存储结构完全相同，仅存储键，不存储值，并且值是不允许重复的</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220226100410766.png" alt="image-20220226100410766"></p>
<br>

<ul>
<li><p><strong>添加数据</strong></p>
<p>sadd  key  member1  member2…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd users jjw1 jjw2</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>获取全部数据</strong></p>
<br>

<p>smembers  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smembers users // ==&gt; &quot;jjw1&quot; &quot;jjw2&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>判断集合中是否包含指定数据</strong></p>
<br>

<p>sismember  key  member</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sismember users jjw1</span><br></pre></td></tr></table></figure>

<br></li>
</ul>
<p><strong>set类型数据的扩展操作</strong></p>
<ul>
<li><p><strong>随机获取集合中指定数量的数据</strong></p>
<br>

<p>srandmember  key  [count]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd news 1 2 3 4 5</span><br><span class="line">sranmember news 2 // ==&gt;随机出现 &quot;2&quot; &quot;4&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>随机获取集合中的某个数据 并将该数据移出集合</strong></p>
<p>spop  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd news 1 2 3 4 5</span><br><span class="line">spop news  // ==&gt; &quot;3&quot; 剩下： &quot;1&quot; &quot;2&quot; &quot;4&quot; &quot;5&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>求两个集合的交、并、差集</strong></p>
<br>

<p>sinter  key1  key2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd set1 1 2 3 4 5</span><br><span class="line">sadd set2 4 5 6 7 8</span><br><span class="line">sinter set1 set2 // ==&gt; &quot;4&quot; &quot;5&quot;</span><br></pre></td></tr></table></figure>

<p>sunion  key1  key2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd set1 1 2 3 4 5</span><br><span class="line">sadd set2 4 5 6 7 8</span><br><span class="line">sunion set1 set2 // ==&gt; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot;</span><br></pre></td></tr></table></figure>

<p>sdiff  key1  key2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd set1 1 2 3 4 5</span><br><span class="line">sadd set2 4 5 6 7 8</span><br><span class="line">sdiff set1 set2 // ==&gt; set1-set2 ==&gt; &quot;1&quot; &quot;2&quot; &quot;3&quot;</span><br><span class="line">sdiff set2 set1 // ==&gt; set2-set1 ==&gt; &quot;6&quot; &quot;7&quot; &quot;8&quot;</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>求两个集合的交、并、差集并存储到指定集合中</strong></p>
<br>

<p>sinterstore  destination  key1  key2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sinterstore set3 set1 set2</span><br><span class="line">smembers set3 // ==&gt; &quot;4&quot; &quot;5&quot;</span><br></pre></td></tr></table></figure>

<p>sunionstore  destination  key1  key2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sunionstore set3 set1 set2</span><br></pre></td></tr></table></figure>

<p>sdiffstore  destination  key1  key2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sdiffstore set3 set1 set2</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>将指定数据从原始集合中移动到目标集合中</strong></p>
<br>

<p>smove  source  destination  member</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smove set1 set2 1</span><br><span class="line">smembers set2 // ==&gt; &quot;1&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot;</span><br></pre></td></tr></table></figure>

<br></li>
</ul>
<hr>
<br>

<h4 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted_set"></a><strong>sorted_set</strong></h4><ul>
<li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p>
</li>
<li><p>需要的存储结构：新的存储模型，可以保存可排序的数据</p>
</li>
<li><p>sorted_类型：在set的存储结构基础上添加可排序字段（注意：score字段仅用于排序，不能用于存储数据）</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220226110016770.png" alt="image-20220226110016770"></p>
</li>
</ul>
<br>

<ul>
<li><p><strong>添加数据</strong></p>
<br>

<p>zadd  key  score1  member1  score2  member2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd sset 99 lisi</span><br><span class="line">zadd sset 94 zhangsan</span><br><span class="line">zadd sset 100 wangwu </span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>获取全部的数据</strong></p>
<br>

<p>zrange  key  start  stop  [withscores]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrange sset 0 -1 // ==&gt; 由小到大</span><br><span class="line">&quot;zhangsan&quot;</span><br><span class="line">&quot;lisi&quot;</span><br><span class="line">&quot;wangwu&quot;</span><br></pre></td></tr></table></figure>

<p>zrevrange  key  start  stop  [withscores]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrevrange sset 0 -1 withscores(带上scores字段) // ==&gt; 由大到小</span><br><span class="line">&quot;wangwu&quot;</span><br><span class="line">&quot;100&quot;</span><br><span class="line">&quot;lisi&quot;</span><br><span class="line">&quot;99&quot;</span><br><span class="line">&quot;zhangsan&quot;</span><br><span class="line">&quot;94&quot;</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>删除数据</strong></p>
<br>

<p>zrem  key  member1  member2…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrem sset wangwu </span><br></pre></td></tr></table></figure>

<br></li>
</ul>
<p><strong>sorted_set类型数据的基本操作</strong></p>
<ul>
<li><p><strong>按条件获取数据</strong></p>
<br>

<p>由小到大获取数据</p>
<p>zrangebyscore  key  min  max  [withscores]  [limit（限定查出多少个数据）]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrangebyscore sset 93 99 withscores // ==&gt;</span><br><span class="line">&quot;zhangsan&quot;</span><br><span class="line">&quot;94&quot;</span><br><span class="line">&quot;lisi&quot;</span><br><span class="line">&quot;99&quot;</span><br></pre></td></tr></table></figure>

<p>由大到小获取数据</p>
<p>zrevrangebyscore  key  max  min  [withscores]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zrevrangebyscore sset 99 93 // ==&gt;</span><br><span class="line">&quot;lisi&quot;</span><br><span class="line">&quot;zhangsan&quot;</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>条件删除数据</strong></p>
<br>

<p>按索引范围删除</p>
<p>zremrangebyrank  key  start  stop</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zremrangebyrank sset 0 1</span><br></pre></td></tr></table></figure>

<p>按score字段范围删除</p>
<p>zremrangebyscore  key  min  max</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zremrangebyscore sset 93 99 // 删除score字段93 99之间的数据</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>获取集合数据总量</strong></p>
<p>zcard  key</p>
<br>

<p>按score字段范围获取总量</p>
<p>zcount  key  min  max</p>
</li>
</ul>
<br>

<ul>
<li><p><strong>集合交、并操作</strong></p>
<p>zinterstore  destination  numkeys  key1  key2 …</p>
<p>zunionstore  destination  numkeys  key1  key2 …</p>
<br>
</li>
<li><p><strong>获取数据对应的索引</strong></p>
<br>

<p>由小到大查找索引</p>
<p>zrank  key  member</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd movies 100 a 99 b 150 c</span><br><span class="line">zrank movies b // ==&gt; 0</span><br></pre></td></tr></table></figure>

<p>由大到小查找索引</p>
<p>zrevrank   key  member</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd movies 100 a 99 b 150 c</span><br><span class="line">zrevrank movies b // ==&gt; 2</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>score值获取与修改</strong></p>
<br>

<p>zscore  key  member</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zscore movies b // ==&gt; 99</span><br></pre></td></tr></table></figure>

<p>对某一个数据的score字段进行加操作</p>
<p>zincrby  key  increment  member</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zincrby movies b 1</span><br></pre></td></tr></table></figure>

<br></li>
</ul>
<p>注：</p>
<ul>
<li>score保存的数据存储空间是64位</li>
<li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，所以在排序时可能出现排序的问题，使用时候要谨慎</li>
<li>sorted_set底层存储的还是基于set结构的，因此数据不能重复，新值会覆盖旧值的score字段</li>
</ul>
<br>

<h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><br>

<h4 id="key通用操作"><a href="#key通用操作" class="headerlink" title="key通用操作"></a>key通用操作</h4><ul>
<li><p><strong>删除指定key</strong></p>
<br>

<p>del  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set str str1 str2</span><br><span class="line">hset hash hash1 hash2</span><br><span class="line">lpush list list1 list2</span><br><span class="line">sadd set set1 set2</span><br><span class="line">zadd sset sset1 sset2</span><br><span class="line"></span><br><span class="line">del str</span><br><span class="line">del hash</span><br><span class="line">del list</span><br><span class="line">del set</span><br><span class="line">del sset</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>获取key的类型</strong></p>
<br>

<p>type  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set str str1 str2</span><br><span class="line">hset hash hash1 hash2</span><br><span class="line">lpush list list1 list2</span><br><span class="line">sadd set set1 set2</span><br><span class="line">zadd sset sset1 sset2</span><br><span class="line"></span><br><span class="line">type str // ==&gt; string</span><br><span class="line">type hash // ==&gt; hash</span><br><span class="line">type list // ==&gt; list</span><br><span class="line">type set // ==&gt; set</span><br><span class="line">type sset // ==&gt; sored_set</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>判断key是否存在</strong></p>
<br>

<p>exists  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exists list</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>为key改名</strong></p>
<br>

<p>rename  key  newkey</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename user1 user2</span><br></pre></td></tr></table></figure>

<p>如果newkey不存在才改名</p>
<p>renamenx  key  newkey</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">renamenx user1 user2</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>对所有key排序</strong></p>
<br>

<p>对一个集合类型进行排序</p>
<p>sort</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpush aa 1 aa 3 aa 2</span><br><span class="line">lrange aa 0 -1 // ==&gt; &quot;2&quot; &quot;3&quot; &quot;1&quot;</span><br><span class="line">sort aa // ==&gt; &quot;1&quot; &quot;2&quot; &quot;3&quot; (不改变元数据)</span><br></pre></td></tr></table></figure></li>
</ul>
<br>



<h5 id="key扩展操作（时效性控制）"><a href="#key扩展操作（时效性控制）" class="headerlink" title="key扩展操作（时效性控制）"></a>key扩展操作（时效性控制）</h5><ul>
<li><p><strong>指定key设置有效期</strong></p>
<br>

<p>expire  key  seconds</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expire user 3</span><br></pre></td></tr></table></figure>

<p>pexpire  key  milliseconds（毫秒）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pexpire user 3000</span><br></pre></td></tr></table></figure>

<p>expireat  key  timestamp（时间戳）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure>

<p>pexpireat  key  milliseconds-timestamp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>获取key的有效时间</strong></p>
<br>

<p>ttl  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ttl user // ==&gt; 24（秒）</span><br></pre></td></tr></table></figure>

<p>pttl  key（毫秒）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pttl user // ==&gt; 300（毫秒）</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>切换key从时效性转换为永久性</strong></p>
<br>

<p>persist  key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">persist user</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><strong>查询key</strong></p>
<br>

<p>keys  pattern</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询规则：</span><br><span class="line">* 匹配任意数量的任意符号</span><br><span class="line">？匹配一个任意符号</span><br><span class="line">[] 匹配一个指定符号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">keys *					查询所有</span><br><span class="line">keys it*				查询所有以it开头</span><br><span class="line">keys *heima				 查询所有以heima结尾</span><br><span class="line">keys ??heima			 查询所有前面两个字符任意，后面以heima结尾</span><br><span class="line">keys user: ?			 查询所有以user:开头，最后一个字符任意</span><br><span class="line">keys u[st]er:1			 查询所有以u开头，以er:1结尾，中间包含一个字母，s或t</span><br></pre></td></tr></table></figure>

<br></li>
</ul>
<h3 id="数据库通用操作"><a href="#数据库通用操作" class="headerlink" title="数据库通用操作"></a>数据库通用操作</h3><ul>
<li>redis为每个服务提供有16个数据库，编号从0~15</li>
<li>每个数据库之间的数据相互独立</li>
</ul>
<br>

<h4 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h4><ul>
<li><p><strong>切换数据库</strong></p>
<br>

<p>select  index</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 2 //切换到2号数据库</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>其它操作</strong></p>
<br>

<p>quit（退出）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure>

<p>ping（测试连接）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure>

<p>echo message（打印日志）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo asd // ==&gt; &quot;asd&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>数据移动</strong></p>
<br>

<p>move  key  db</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set jjw 1</span><br><span class="line">move jjw 1</span><br><span class="line">select 1</span><br><span class="line">get jjw // ==&gt; &quot;1&quot; (如果要移动到的数据库有这个key，则移动失败)</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<ul>
<li><p><strong>数据清除</strong></p>
<br>

<p>dbsize（查看数据库里的数据总量）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure>

<p>flushdb（清除当前所在数据库的所有数据）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushdb</span><br></pre></td></tr></table></figure>

<p>flushall（清除所有数据库的所有数据）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushall</span><br></pre></td></tr></table></figure>

<br></li>
</ul>
<hr>
<br>

<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>Java语言连接redis服务：Jedis、SpringData Redis、Lettuce</p>
<br>

<p>1、创建maven工程</p>
<p>2、pom.xml文件中引入Jedis所需jar</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、使用 jedis</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jedisTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1、连接redis</span></span><br><span class="line">        <span class="comment">//参数一：主机</span></span><br><span class="line">        <span class="comment">//参数二：端口号</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//2、操作redis</span></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jjw&quot;</span>);</span><br><span class="line">        <span class="comment">//3、关闭redis</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Jedis工具类制作"><a href="#Jedis工具类制作" class="headerlink" title="Jedis工具类制作"></a>Jedis工具类制作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisUtil</span> &#123;</span><br><span class="line">    <span class="comment">//主机号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String HOST;</span><br><span class="line">    <span class="comment">//端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> PORT;</span><br><span class="line">    <span class="comment">//最大连接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> MAXTOTAL;</span><br><span class="line">    <span class="comment">//最大活动数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> MAXIDLE;</span><br><span class="line">    <span class="comment">//Jedis连接池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取redis.properties文件</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">resourceBundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Jedis连接池配置</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line"></span><br><span class="line">        HOST = resourceBundle.getString(<span class="string">&quot;redis.host&quot;</span>);</span><br><span class="line">        PORT = Integer.parseInt(resourceBundle.getString(<span class="string">&quot;redis.port&quot;</span>));</span><br><span class="line">        MAXTOTAL = Integer.parseInt(resourceBundle.getString(<span class="string">&quot;redis.maxTotal&quot;</span>));</span><br><span class="line">        MAXIDLE = Integer.parseInt(resourceBundle.getString(<span class="string">&quot;redis.maxIdle&quot;</span>));</span><br><span class="line">        jedisPoolConfig.setMaxTotal(MAXTOTAL);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(MAXIDLE);</span><br><span class="line"></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig,HOST,PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="Linux下使用Redis"><a href="#Linux下使用Redis" class="headerlink" title="Linux下使用Redis"></a>Linux下使用Redis</h2><p>linux下操作mysql：<a href="https://blog.csdn.net/longgeaisisi/article/details/78669007">https://blog.csdn.net/longgeaisisi/article/details/78669007</a></p>
<p>linux下操作redis：<a href="https://blog.csdn.net/qq_43543789/article/details/104261786">https://blog.csdn.net/qq_43543789/article/details/104261786</a></p>
<br>

<p><strong>安装</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220301080548399.png" alt="image-20220301080548399"></p>
<br>

<p><strong>开启服务</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220303210504336.png" alt="image-20220303210504336"></p>
<br>

<p><strong>暂停服务</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220303210538687.png" alt="image-20220303210538687"></p>
<br>

<p><strong>查看状态</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220303210619820.png" alt="image-20220303210619820"></p>
<br>

<p><strong>打开客户端</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220303211004498.png" alt="image-20220303211004498"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220303214939586.png" alt="image-20220303214939586"></p>
<br>

<p><strong>修改配置文件</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220303211614970.png" alt="image-20220303211614970"></p>
<p>基础配置</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220303212245415.png" alt="image-20220303212245415"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220303212515654.png" alt="image-20220303212515654"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220303212617045.png" alt="image-20220303212617045"></p>
<br>

<hr>
<br>

<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>持久化就是利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化，<strong>为了防止数据的意外丢失，确保数据安全</strong></p>
<br>

<h4 id="RDB（快照）启动方式"><a href="#RDB（快照）启动方式" class="headerlink" title="RDB（快照）启动方式"></a>RDB（快照）启动方式</h4><p>描述：将当前数据进行保存，快照形式，存储数据结果，二进制存储</p>
<ul>
<li><p>在配置文件中修改文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbfilename dump.rdb		通常设为 dump-端口号.rdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件中修改rdb文件存放路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir /var/lib/redis		通常放到 data 文件夹下</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件中开启压缩、开启加载检测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdbcompression yes		设置存储至本地数据库时是否压缩数据</span><br><span class="line">rdbchecksum yes		设置是否进行RDB文件格式校验</span><br></pre></td></tr></table></figure>

<br></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save // 持久化</span><br></pre></td></tr></table></figure>

<br>

<p><strong>sava指令的执行会阻塞当前Redis服务器，有可能会造成阻塞时间过长，线上环境不建议使用</strong></p>
<p>是否有方法解决？</p>
<p><strong>后台执行</strong></p>
<ul>
<li>操作者发起指令；redis服务器在合理的时间控制指令执行</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220304200858981-16463965415471.png" alt="image-20220304200858981"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bgsave // 不是立即执行的</span><br></pre></td></tr></table></figure>

<br>

<p>忘记执行持久化操作了怎么办？</p>
<p><strong>自动执行</strong></p>
<ul>
<li>redis服务器在满足条件的时候发起指令</li>
<li>在conf配置文件中配置</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220304202142201-16463965832042.png" alt="image-20220304202142201"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 100 10 // 100秒内 key发生了10次变化就执行save指令</span><br></pre></td></tr></table></figure>

<br>

<p>注：</p>
<ul>
<li>save配置要根据实际业务情况进行设置，频率过高或过低都会出现性能问题</li>
<li>save配置对于second和changes设置通常具有互补对应关系</li>
<li><strong>save配置启动后执行的是bgsave操作</strong></li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220304202646522.png" alt="image-20220304202646522"></p>
<br>

<h5 id="RDB特殊启动形式"><a href="#RDB特殊启动形式" class="headerlink" title="RDB特殊启动形式"></a>RDB特殊启动形式</h5><ul>
<li><p>全量复制</p>
</li>
<li><p>服务器运行过程中重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务器是指定保存数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<p><strong>RDB优点</strong></p>
<ul>
<li><p>RDB是一个紧凑压缩的二进制文件，存储效率较高</p>
</li>
<li><p>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</p>
</li>
<li><p>RDB恢复数据的速度要比AOF快很多</p>
</li>
<li><p>应用:服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</p>
<br></li>
</ul>
<p><strong>RDB缺点</strong></p>
<ul>
<li>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</li>
<li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</li>
<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</li>
</ul>
<br>

<h4 id="AOF（日志）启动形式"><a href="#AOF（日志）启动形式" class="headerlink" title="AOF（日志）启动形式"></a>AOF（日志）启动形式</h4><p>描述：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂</p>
<p>以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的，可以简单描述为<strong>改记录数据为记录数据产生的过程</strong></p>
<p><strong>AOF的主要作用时解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</strong></p>
<br>

<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220304203908830.png" alt="image-20220304203908830"></p>
<br>

<p>AOF写数据的三种策略</p>
<ul>
<li><p>always（每次）</p>
<p>每次写入操作均同步到AOF文件中，<strong>数据零误差，性能较低</strong></p>
</li>
<li><p>everysec（每秒）</p>
<p>每秒将缓冲区中的指令同步到AOF文件中，<strong>数据准确性较高，性能较高，建议使用</strong></p>
</li>
<li><p>no（系统控制）</p>
<p>由操作系统控制每次同步周期，<strong>整体过程不可控</strong></p>
</li>
</ul>
<br>

<p>在配置文件中开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes|no // 开启后尽管RDB文件有配置，但优先使用AOF文件</span><br></pre></td></tr></table></figure>

<p>配置选择哪一种策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfsync always|everysec|no</span><br></pre></td></tr></table></figure>

<p>配置文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfilename filename // 建议配置为appendonly-端口号.aof</span><br></pre></td></tr></table></figure>

<p>配置存储路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure>

<br>

<h5 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h5><p>参考：<a href="https://blog.csdn.net/hezhiqiang1314/article/details/69396887">https://blog.csdn.net/hezhiqiang1314/article/details/69396887</a></p>
<p><strong>由于不断的对redis进行操作会使aof文件越来越大，因此aof提供了如下几种重写规则</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220304210222010.png" alt="image-20220304210222010"></p>
<br>

<p><strong>手动重写</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220304210733852.png" alt="image-20220304210733852"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bgrewriteaof // 后台重写aof</span><br></pre></td></tr></table></figure>

<br>

<p><strong>自动重写</strong></p>
<p>配置文件中修改配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size // 触发条件是当前aof文件大小大于设置的最小值</span><br><span class="line">auto-aof-rewrite-percentage percentage // （当前大小-基础大小）/基础大小 &gt; 设定百分比</span><br></pre></td></tr></table></figure>

<br>

<p><strong>重写流程</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220304212835111.png" alt="image-20220304212835111"></p>
<br>

<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220304212737253.png" alt="image-20220304212737253"></p>
<br>



<h4 id="RDB-和-AOF-的区别"><a href="#RDB-和-AOF-的区别" class="headerlink" title="RDB 和 AOF 的区别"></a>RDB 和 AOF 的区别</h4><p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220304213913840.png" alt="image-20220304213913840"></p>
<p>选择：</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220305093210383.png" alt="image-20220305093210383"></p>
<br>

<hr>
<br>

<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p><strong>Redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断</strong></p>
<br>

<h4 id="事务基本操作"><a href="#事务基本操作" class="headerlink" title="事务基本操作"></a>事务基本操作</h4><br>

<p>开启事务，设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multi</span><br></pre></td></tr></table></figure>

<br>

<p>执行事务，设定事务的结束位置，同时执行事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec</span><br></pre></td></tr></table></figure>

<br>

<p>取消事务，终止当前事务的定义，multi之后，exec之前 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">discard</span><br></pre></td></tr></table></figure>

<br>

<p>注：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</p>
<br>

<h4 id="事务的工作流程"><a href="#事务的工作流程" class="headerlink" title="事务的工作流程"></a>事务的工作流程</h4><p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220305101520726.png" alt="image-20220305101520726"></p>
<br>

<h4 id="事务的注意事项"><a href="#事务的注意事项" class="headerlink" title="事务的注意事项"></a>事务的注意事项</h4><br>

<p><strong>定义事务的过程中，命令格式输入错误怎么办？</strong></p>
<ul>
<li><p>语法错误：命令书写格式有误</p>
</li>
<li><p>处理结果：如果定义的事务中所包含的命令存在语法错误，整体的事务中所有命令都不执行</p>
</li>
<li><p>运行错误：命令格式正确，但无法正确的执行。如对list进行incr操作</p>
</li>
<li><p>处理结果：能够正确执行的命令将会执行，运行错误的命令将不会执行</p>
</li>
<li><p>需要自己手动回滚</p>
</li>
</ul>
<br>

<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p><strong>监视锁</strong></p>
<p>必须在事务开启前执行</p>
<p>对key添加监视锁，<strong>在执行exec前如果key发生了变化，终止事务执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch key1 ...</span><br></pre></td></tr></table></figure>



<p>取消对所有key的监视</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unwatch</span><br></pre></td></tr></table></figure>

<br>

<table>
<thead>
<tr>
<th>客户端1</th>
<th>客户端2</th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220305104446896.png" alt="image-20220305104446896"></td>
<td><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220305104510188.png" alt="image-20220305104510188"></td>
</tr>
</tbody></table>
<br>

<p><strong>分布式锁</strong></p>
<p>参考：<a href="https://blog.csdn.net/weixin_39764379/article/details/111006501">https://blog.csdn.net/weixin_39764379/article/details/111006501</a></p>
<p>使用setnx设置一个公共锁，利用setnx命令达到返回值特征，有值返回设置失败，无值返回设置成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setnx lock-key value</span><br></pre></td></tr></table></figure>

<p>操作完毕通过del删除锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del lock-key</span><br></pre></td></tr></table></figure>

<img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220306105031716.png" alt="image-20220306105031716" style="zoom:50%;">

<br>



<p><strong>分布式锁的死锁解决方案</strong></p>
<p><strong>业务分析</strong></p>
<ul>
<li>锁由用户控制加锁，若用户在加锁之后停电了，宕机了锁就解锁不了，存在风险</li>
<li>需要解锁操作不仅由用户控制，也能由系统控制</li>
</ul>
<br>

<p>使用expire为锁添加时间限定，到时不释放锁，放弃锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expire lock-key second</span><br><span class="line">pexpire lock-key milliseconds // 毫秒级</span><br></pre></td></tr></table></figure>

<p>客户端一：<img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220306110220224.png" alt="image-20220306110220224" style="zoom: 50%;"></p>
<br>

<p>客户端二：<img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220306110331241.png" alt="image-20220306110331241" style="zoom: 50%;"></p>
<br>

<hr>
<br>

<h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><p>数据会存放在expires，redis中有16个expires，以hash的类型存储</p>
<p><strong>过期数据</strong></p>
<p>过期的数据不会马上删除，因为其他的指令更需要被执行，先执行其他的指令</p>
<br>

<p><strong>过期数据数据删除策略</strong></p>
<ol>
<li><p>定时删除</p>
<p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</p>
<p>优点：节约内存，到时就删，快速释放</p>
<p>缺点：CPU压力大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</p>
<br>
</li>
<li><p>惰性删除</p>
<p>数据到达过期时间，不做处理，等下次访问该数据时发现过期了就删除，返回不存在</p>
<p>优点：节约CPU性能，发现必须删除时才删除</p>
<p>缺点：内存压力大，出现长期占用内存的数据</p>
<br>
</li>
<li><p>定期删除</p>
<p>Redis启动服务初始化时，读取配置server.hz的值，默认为10；每秒钟执行server.hz次serverCron()</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220307211711276.png" alt="image-20220307211711276"></p>
</li>
</ol>
<br>

<p><strong>逐出算法</strong></p>
<p>当新数据进入redis时，内存不够怎么办？</p>
<p>Redis使用内存存储数据，在执行每一个命令前，会调用freeMemorylfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</p>
<p>注意:逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</p>
<br>

<p>配置文件中配置最大可用内存，占用物理内存的比例，默认值为0，表示不限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory</span><br></pre></td></tr></table></figure>

<br>

<p>配置文件中配置每次选取待删除数据的个数，选取数据时并不会全库扫描，采用随机获取数据的方式作为待检测删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory-samples</span><br></pre></td></tr></table></figure>

<br>

<p>配置文件中配置<strong>数据逐出策略</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory-policy</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">检测易失数据(可能会过期的数据集server.db[i].expires )</span><br><span class="line">volatile-lru:挑选最近最少使用的数据淘汰</span><br><span class="line">volatile-Ifu:挑选最近使用次数最少的数据淘汰</span><br><span class="line">volatile-ttl:挑选将要过期的数据淘汰</span><br><span class="line">volatile-random:任意选择数据淘汰</span><br><span class="line">检测全库数据(所有数据集server.db[i].dict )</span><br><span class="line">allkeys-Iru:挑选最近最少使用的数据淘汰</span><br><span class="line">allkeys-lfu:挑选最近使用次数最少的数据淘汰</span><br><span class="line">allkeys-random:任意选择数据淘汰</span><br><span class="line">放弃数据驱逐</span><br><span class="line">no-enviction(驱逐)︰禁止驱逐数据(redis4.0中默认策略)，会引发错误OOM(OutOf Memory)</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>



<h3 id="服务器基础配置"><a href="#服务器基础配置" class="headerlink" title="服务器基础配置"></a>服务器基础配置</h3><p>设置服务器以守护进程的方式运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonize yes|no</span><br></pre></td></tr></table></figure>

<br>

<p>绑定主机地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind ...</span><br></pre></td></tr></table></figure>

<br>

<p>设置服务器端口号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6379</span><br></pre></td></tr></table></figure>

<br>

<p>设置数据库数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure>

<br>

<p>日志记录文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logfile 端口号.log</span><br></pre></td></tr></table></figure>

<br>

<p>设置服务器以指定日志记录级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loglevel debug|verbose|notice|warning</span><br></pre></td></tr></table></figure>

<br>

<p>设置同一时间最大客户端连接数，默认无限制。当客户端连接达到上限，Redis会关闭新的连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxclients 0</span><br></pre></td></tr></table></figure>

<br>

<p>客户端闲置等待最大时长，达到最大值后关闭连接，如需关闭该功能，设置为0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timeout 300</span><br></pre></td></tr></table></figure>

<br>

<p>导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include /path/server-端口号.conf</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h3 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h3><br>

<h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h4><p>获取指定key对应偏移量上的bit值</p>
<p>gerbit key offset</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gerbit bit 0 1</span><br></pre></td></tr></table></figure>

<br>

<p>设置指定key对应偏移量上的bit值，value只能是1或0</p>
<p>setbit key offset value</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbit bit 0 1</span><br><span class="line">setbit bit 3 1</span><br><span class="line">setbit bit 4 1</span><br><span class="line">// ==&gt; 1101</span><br></pre></td></tr></table></figure>

<br>

<p><strong>Bitmaps扩展操作</strong></p>
<br>

<p>计算bitmaps中有多少个1</p>
<p>bitcount key [start end]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitcount bit（1101） // ==&gt; 3 </span><br></pre></td></tr></table></figure>

<br>

<p>对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中</p>
<p>bitop op destKey key1 ….</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitop and destKey aa bb</span><br></pre></td></tr></table></figure>

<br>



<h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p>基数统计；基数是数据集去重后的元素个数</p>
<p>HyperLogLog是用来做基数统计的，运用了LogLog的算法</p>
<br>

<p><strong>HyperLogLog类型的基本操作</strong></p>
<p>添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfadd key element</span><br></pre></td></tr></table></figure>

<br>

<p>统计数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfcount key</span><br></pre></td></tr></table></figure>

<br>

<p>合并数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfmerge destkey sourcekey</span><br></pre></td></tr></table></figure>

<br>

<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220308100500397.png" alt="image-20220308100500397"></p>
<br>

<h4 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h4><p><strong>GEO类型的基本操作</strong></p>
<p>添加坐标点</p>
<p>geoadd  key  longitude  latitude  member</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geoadd geos 1 1 a</span><br></pre></td></tr></table></figure>

<br>

<p>获取坐标点</p>
<p>geopos  key  member</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geopos geos a</span><br></pre></td></tr></table></figure>

<br>

<p>计算坐标点距离</p>
<p>geodist  key  member1  member2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geodist geos a b</span><br></pre></td></tr></table></figure>

<br>

<p>根据坐标求范围内的数据</p>
<p>georadius  key  longitude  latitude  redius  m|km|ft|mi</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">georadius geos 1.5 1.5 90 km</span><br></pre></td></tr></table></figure>

<br>

<p>根据点求范围内数据</p>
<p>georadiusbymember  key  member redius  m|km|ft|mi</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">georadiusbymember geos a 180 km</span><br></pre></td></tr></table></figure>

<br>

<p>获取指定点对应的坐标hash值</p>
<p>geohash  key  member …</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<br>



<hr>
<br>

<h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><br>

<h4 id="主从复制（需要再理解一遍）"><a href="#主从复制（需要再理解一遍）" class="headerlink" title="主从复制（需要再理解一遍）"></a>主从复制（需要再理解一遍）</h4><p><strong>简介</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220309145409667.png" alt="image-20220309145409667"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220309145545884.png" alt="image-20220309145545884"></p>
<br>



<p><strong>作用</strong></p>
<ul>
<li>读写分离：master写、slave读，提高服务器的读写负载能力</li>
<li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个节点分担数据读取负载，大大提高redis服务器并发量和吞吐量</li>
<li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
</ul>
<br>



<p><strong>工作流程</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220309150505312.png" alt="image-20220309150505312"></p>
<br>

<p>大致可以分为三个阶段            </p>
<br>

<ul>
<li><strong>建立连接（slave连接master）</strong></li>
</ul>
<p>步骤：</p>
<p>1、设置mater的地址和端口，保存master信息</p>
<p>2、建立socket连接</p>
<p>3、发送ping命令</p>
<p>4、身份验证</p>
<p>5、发送slave端口信息</p>
<p>6、连接成功 </p>
<br>

<p>方式一：客户端发送命令</p>
<p>slaveof  masterip  masterport</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//开启两个服务器 一个端口号6380（slave） 一个端口号6379（master）</span><br><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<br>

<p>方式二：以配置文件启动时连接</p>
<p>redis-server  ….&#x2F;redis-6380.conf  –slaveof  masterip  masterport</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server ..../redis-6380.conf --slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<br>

<p>方式三：改变配置文件连接</p>
<p>在配置文件中添加 slaveof  masterip  masterport</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<br>

<p>断开连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li><strong>数据同步</strong></li>
</ul>
<p>在slave初次连接master后，复制master中的所有数据到slave</p>
<p>将slave的数据库状态更新成master当前的数据库状态</p>
<br>

<p>步骤：</p>
<p>1、请求同步数据</p>
<p>2、 创建RDB同步数据</p>
<p>3、恢复RDB同步数据</p>
<p>4、请求部分同步数据</p>
<p>5、恢复部分同步数据</p>
<p>6、同步工作完成</p>
 <br>

<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220309164159534.png" alt="image-20220309164159534"></p>
<br>

<ul>
<li><strong>命令传播</strong></li>
</ul>
<p>​    <br></p>
<hr>
<br>

<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p><strong>简介</strong></p>
<p>哨兵(sentinel)是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master</p>
<br>

<p><strong>作用</strong></p>
<ul>
<li><strong>监控</strong><br>不断的检查master和slave是否正常运行。master存活检测、master与slave运行情况检测</li>
<li><strong>通知(提醒)</strong><br>当被监控的服务器出现问题时，向其他(哨兵间，客户端)发送通知。</li>
<li><strong>自动故障转移</strong><br>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li>
</ul>
<br>

<p><strong>启用哨兵模式</strong></p>
<p>注：需要先创建一个sentinel.conf的文件，默认是没有的</p>
<p>配置：</p>
<ol>
<li><p>port :当前 Sentinel服务运行的端口</p>
</li>
<li><p>dir : Sentinel服务运行时使用的临时文件夹</p>
</li>
<li><p>sentinel monitor master001 192.168.110.101 6379 2 : Sentinel去监视一个名为 master001 的主redis实例，这个主实例的IP地址为本机地址 192.168 . 110.101 ，端口号为 6379 ，而将这个主实例判断为失效至少需要 2 个 Sentinel进程的同意，只要同意Sentinel的数量不达标，自动failover就不会执行</p>
</li>
<li><p>sentinel down-after-milliseconds master001 30000 : 指定了Sentinel认为Redis实例已经失效所需的毫秒数。 当实例超过该时间没有返回PING，或者直接返回错误，那么Sentinel将这个实例标记为主观下线。只有一个 Sentinel进程将实例标记为主观下线并不一定会引起实例的自动故障迁移：只有在足够数量的Sentinel都将一个实例标记为主观下线之后，实例才会被标记为客观下线，这时自动故障迁移才会执行</p>
</li>
<li><p>sentinel parallel-syncs master001 1 ：指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</p>
</li>
<li><p>sentinel failover-timeout master001 180000 ：如果在该时间（ms）内未能完成failover操作，则认为该failover失败</p>
</li>
<li><p>sentinel notification-script <master-name> <script-path> ： 指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，但是很常用</script-path></master-name></p>
</li>
</ol>
<p>启动哨兵</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//启动之前需要先启动主机和从机，先搭建好主从模式</span><br><span class="line">redis-sentinel sentinel-端口号.conf</span><br></pre></td></tr></table></figure>

<br>



<p><strong>工作原理</strong></p>
<p>哨兵在进行主从切换的过程中经历了三个阶段</p>
<ul>
<li><p>监控</p>
<p>同步各个节点的状态信息</p>
<ul>
<li>获取各个sentinel的状态</li>
<li>获取master的状态和各个slave的详细信息</li>
</ul>
</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220310164857301.png" alt="image-20220310164857301"></p>
<br>

<ul>
<li>通知</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220310165533115.png" alt="image-20220310165533115"></p>
<br>

<ul>
<li>故障转移<ul>
<li>发现问题</li>
<li>竞选负责人</li>
<li>优选新master</li>
<li>新master上任，其他slave切换master，原master作为slave故障恢复后连接</li>
</ul>
</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220311144112988.png" alt="image-20220311144112988"></p>
<br>

<hr>
<br>

<h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>简介：集群就是使用网络将若干台计算机连通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</p>
<br>

<p><strong>作用</strong></p>
<ul>
<li>分散单台服务器的访问压力，实现负载均衡</li>
<li>分散单台服务器的存储压力，实现可扩展性</li>
<li>降低单台服务器宕机带来的业务灾难</li>
</ul>
<br>

<p><strong>集群结构设计</strong></p>
<p>数据存储设计</p>
<ul>
<li>通过算法设计，计算出key应该保存的位置</li>
<li>将所有的存储空间计划切割成16384份，每台主机保存一部分</li>
<li>每份代表的是一个存储空间，不是一个key的保存空间</li>
<li>将key按照计算出来的结果放到对应的存储空间</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220311145956927.png" alt="image-20220311145956927"></p>
<br>

<p>集群内部通讯设计</p>
<ul>
<li>各个数据库相互通信，保存各个库中槽的编号数据</li>
<li>一次命中，直接返回</li>
<li>一次未命中，告知具体位置</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220311150824956.png" alt="image-20220311150824956"></p>
<br>

<p><strong>集群搭建</strong></p>
<p>参考：<a href="https://blog.csdn.net/qq_42815754/article/details/82912130">https://blog.csdn.net/qq_42815754/article/details/82912130</a></p>
<p>配置文件中添加配置，表示这个为一个cluster节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-enabled yes </span><br></pre></td></tr></table></figure>

<p>配置文件中添加配置，集群配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-config-file nodes-6379.conf</span><br></pre></td></tr></table></figure>

<p>配置文件中添加配置，表示超时时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-node-timeout 10000</span><br></pre></td></tr></table></figure>

<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220311155652638.png" alt="image-20220311155652638"></p>
<br>

<p><strong>Cluster节点指令</strong></p>
<p>查看集群节点信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>

<p>进入一个从节点redis，切换其主节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster replicate &lt;master-id&gt;</span><br></pre></td></tr></table></figure>

<p>发现一个新节点，新增主节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster meet ip:port</span><br></pre></td></tr></table></figure>

<p>忽略一个没有solt的节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster forget &lt;id&gt;</span><br></pre></td></tr></table></figure>

<p>手动故障转移</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster failover</span><br></pre></td></tr></table></figure>



<br>

<hr>
<br>

<h3 id="企业级解决方案"><a href="#企业级解决方案" class="headerlink" title="企业级解决方案"></a>企业级解决方案</h3><h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p><strong>原因：</strong></p>
<p>1、请求数量较高</p>
<p>2、主从之间数据吞吐量较大，数据同步操作频度较高</p>
<br>

<p><strong>解决方案：</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220311163929680.png" alt="image-20220311163929680"></p>
<br>

<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p><strong>原因：</strong></p>
<p>1、<strong>在一个较短的时间内，缓存中较多的key集中过期</strong></p>
<p>2、<strong>此周期内请求访问过期的数据,redis未命中，redis向数据库获取数据</strong></p>
<p>3、<strong>数据库同时接收到大量的请求无法及时处理</strong></p>
<p>4、Redis大量请求被积压，开始出现超时现象</p>
<p>5、数据库流量激增，<strong>数据库崩溃</strong></p>
<p>6、重启后仍然面对缓存中无数据可用 </p>
<p>7、Redis服务器资源被严重占用，Redis服务器崩溃</p>
<p>8、Redis集群呈现崩塌，集群瓦解</p>
<p>9、应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</p>
<p>10、应用服务器，redis，数据库全部重启，效果不理想</p>
<br>

<p><strong>解决方案：</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220311164524794.png" alt="image-20220311164524794"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220311164709916.png" alt="image-20220311164709916"></p>
<br>



<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p><strong>原因：</strong></p>
<p>1、Redis中某个key过期，该key访问量巨大</p>
<p>2、多个数据请求从服务器直接压到Redis后，均未命中</p>
<p>3、Redis在短时间内发起了大量对数据库中同一数据的访问</p>
<br>

<p><strong>解决方案：</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220311165632643.png" alt="image-20220311165632643"></p>
<br>

<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>原因：</strong></p>
<p>1、Redis中大面积出现未命中</p>
<p>2、出现非正常URL访问</p>
<br>

<p><strong>解决方案：</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/22/Redis/image-20220311170256349.png" alt="image-20220311170256349"></p>
]]></content>
      <categories>
        <category>HideBlog</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记</title>
    <url>/2022/03/18/Spring/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="spring框架概述"><a href="#spring框架概述" class="headerlink" title="spring框架概述"></a>spring框架概述</h2><ul>
<li><p>spring是一个轻量级的开源框架</p>
</li>
<li><p>spring解决企业开发的复杂性</p>
</li>
<li><p>spring有两个核心部分<strong>IOC</strong>和<strong>Aop</strong></p>
<ul>
<li><p>IOC：控制反转，把创建对象的过程交给spring进行管理</p>
</li>
<li><p>Aop：面向切面编程，不修改源代码的情况下进行功能增强</p>
</li>
</ul>
<br></li>
</ul>
<p>spring下载地址<img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220130164829123.png" alt="image-20220130164829123"></p>
<p>spring基本5个jar包<img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220130165213984.png" alt="image-20220130165213984"></p>
<p><strong>使用步骤：</strong></p>
<ul>
<li>导入jar包</li>
<li>在src目录下创建spring使用的xml配置文件（spring config文件）</li>
<li>配置相关对象</li>
<li>启动程序</li>
</ul>
<br>

<h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><p><em>通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中</em></p>
<p>使用IOC的目的：为了降低耦合度</p>
<br>

<h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><p>xml解析、工厂模式、反射</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220130173046282.png" alt="image-20220130173046282"></p>
<br>

<hr>
<br>

<h3 id="IOC接口（BeanFactory）"><a href="#IOC接口（BeanFactory）" class="headerlink" title="IOC接口（BeanFactory）"></a>IOC接口（BeanFactory）</h3><p>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p>
<p>spring提供IOC容器实现的两种方式</p>
<ul>
<li><p>BeanFactory：IOC容器基本实现方式，是spring内部使用的接口，不建议使用</p>
<ul>
<li>BeanFactory是懒加载，一开始只读取配置文件，获取对象时才创建对象</li>
</ul>
</li>
<li><p>ApplicationContext：是BeanFactory的子接口，提供更多更强大的功能</p>
<ul>
<li><p>加载配置文件时就创建对象</p>
</li>
<li><p>有两个实现类<strong>FileSystemXmlApplicationContext</strong>（盘符路径）和<strong>ClassPathXmlApplicationContext</strong>（类路径）</p>
</li>
</ul>
</li>
</ul>
<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用配置好的对象</span></span><br><span class="line"><span class="comment">//1、加载spring配置文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;配置文件名.xml&quot;</span>)</span><br><span class="line"><span class="comment">//2、获取配置创建的对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;对象配置的id值&quot;</span>, User.class<span class="comment">/*要创建的类型*/</span>);</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h3 id="IOC操作Bean管理（基于xml）"><a href="#IOC操作Bean管理（基于xml）" class="headerlink" title="IOC操作Bean管理（基于xml）"></a>IOC操作Bean管理（基于xml）</h3><h4 id="Bean管理"><a href="#Bean管理" class="headerlink" title="Bean管理"></a>Bean管理</h4><p>Bean管理指的是两个操作</p>
<ul>
<li>spring创建对象</li>
<li>spring注入属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring创建对象--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用bean标签可以实现对象创建--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--创建对象的时候，默认执行无参构造方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在bean标签中有很多属性（常见）--&gt;</span></span><br><span class="line">id属性：给对象取一个别名（唯一标识）</span><br><span class="line">class属性：类全路径（包全路径）</span><br><span class="line">name属性：与id属性效果一致，但是name中可以添加特殊符号</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring注入属性</span></span><br><span class="line"><span class="comment">DI：依赖注入，就是注入属性，是IOC的具体实现方式--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--set注入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1、先创建类，定义属性和对应的set方法--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2、在spring配置文件中创建对象并注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--name属性就是类中属性名称 value就是要注入的值--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>&gt;</span><span class="tag">&lt;/<span class="name">null</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--属性可以是null值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--构造注入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1、先创建类，定义属性和有参构造方法--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2、在spring配置文件中创建对象并注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--name属性就是类中属性名称 value就是要注入的值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--p名称空间注入，可简化基于xml配置方式--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1、添加配置xmlns:p=&quot;http://www.springframework.org/schema/p&quot;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2、在spring配置文件中创建对象并注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.User&quot;</span> <span class="attr">p:userName</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>注入外部bean</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--注入外部bean使用ref属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.Address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">value</span>=<span class="string">&quot;heibeishifandaxue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>级联赋值</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--需要有这个属性的get方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;技术部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Dept&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;后勤部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注入集合属性</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springDemo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数组类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>234<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>345<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--List类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>234<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>345<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入引用类型</span></span><br><span class="line"><span class="comment">            &lt;ref bean=&quot;&quot;&gt;&lt;/ref&gt;</span></span><br><span class="line"><span class="comment">            &lt;ref bean=&quot;&quot;&gt;&lt;/ref&gt;</span></span><br><span class="line"><span class="comment">            &lt;ref bean=&quot;&quot;&gt;&lt;/ref&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--Map类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--Set类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>234<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>345<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>提取集合类型</strong></p>
<p>1、添加util配置</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220131135613821.png" alt="image-20220131135613821"></p>
<p>2、提取集合，并注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>234<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>345<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;users&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;users&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<br>

<p>spring有两种类型bean，一种普通bean，另一种工厂bean（FactoryBean）</p>
<p>1、普通bean：在配置文件中定义bean类型就是返回类型</p>
<p>2、工厂bean：在配置文件定义bean类型可以和返回类型不一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义返回的bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserName(<span class="string">&quot;jjw&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否为单例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FactoryBean.<span class="built_in">super</span>.isSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mybean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.MyBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当使用getbean方法获得bean时，返回User--&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><p>作用域就是单实例、多实例、request、session</p>
<p>在spring里面，可以设置bean实例是单实例或者多实例</p>
<p><strong>在spring里面，默认情况是单实例</strong></p>
<br>

<p><strong>单例：</strong></p>
<p>当bean为单例模式时，加载spring配置文件时就会创建单例对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span> <span class="comment">&lt;!--单例--&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>多例：</strong></p>
<p>当bean为多例时，执行getBean方法时才创建对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span> <span class="comment">&lt;!--多例--&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>1、通过构造器创建bean实例（无参构造）</p>
<p>2、为bean的属性设置值和对其他bean的引用（调用set方法）</p>
<p>（可以添加后置处理器，添加后在第3步之前将bean实例传递给后置处理器的postProcessBeforeInitialization方法）</p>
<p>3、调用bean的初始化方法（需要自己配置）</p>
<p>（可以添加后置处理器，添加后在第3步之后将bean实例传递给后置处理器的postProcessAfterInitialization方法）</p>
<p>4、bean可以使用</p>
<p>5、当容器关闭时，调用bean的销毁方法（需要自己配置）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orders</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Orders</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一步，执行无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOname</span><span class="params">(String oname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.oname = oname;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二步，调用set方法设置属性值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三步，执行初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步，执行销毁方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.Orders&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jjw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="Bean自动装配"><a href="#Bean自动装配" class="headerlink" title="Bean自动装配"></a><em>Bean自动装配</em></h4><p>根据指定的装配规则（<strong>属性名称</strong>或<strong>属性类型</strong>），spring自动将匹配的属性值进行注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean标签的autowire属性可以实现自动装配</span></span><br><span class="line"><span class="comment">	autowire属性常用的两个值为</span></span><br><span class="line"><span class="comment">		byName：根据属性名注入，采用的时set注入，所以需要有set方法</span></span><br><span class="line"><span class="comment">		byType：根据属性类型注入，采用的时set注入，所以需要有set方法--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--类中的属性名要与xml中id值一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.Orders&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--类中的属性名要与xml中id值一致--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.Orders&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="引入外部属性文件"><a href="#引入外部属性文件" class="headerlink" title="引入外部属性文件"></a><em>引入外部属性文件</em></h4><p>1、创建外部属性文件，properties格式的文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;!--以阿里的德鲁伊数据库连接池配置为例--&gt;</span></span><br><span class="line"><span class="attr">建议加上***.***否则容易命名冲突</span></span><br><span class="line"><span class="attr">prop.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">prop.url</span>=<span class="string">jdbc:mysql://localhost:3306/userDb</span></span><br><span class="line"><span class="attr">prop.userName</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">prop.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>2、添加context上下文配置</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220131195517342.png" alt="image-20220131195517342"></p>
<p>3、将外部properties文件引入到spring配置文件中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:***.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h3 id="IOC操作Bean管理（基于注解）"><a href="#IOC操作Bean管理（基于注解）" class="headerlink" title="IOC操作Bean管理（基于注解）"></a>IOC操作Bean管理（基于注解）</h3><ul>
<li>@Component：普通的组件</li>
<li>@Service：用于业务逻辑层</li>
<li>@Controller：用于控制层</li>
<li>@Repository：用于dao层</li>
</ul>
<p>功能是一样的，都可以用来创建bean实例</p>
<br>

<h4 id="基于注解创建对象"><a href="#基于注解创建对象" class="headerlink" title="基于注解创建对象"></a>基于注解创建对象</h4><p>1、引入spring.aop.x.x.x.RELEASE.jar</p>
<p>2、开启组件扫描，添加context上下文配置（多个包之间逗号隔开）</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220131195517342-164636079790815.png" alt="image-20220131195517342"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;要扫描的包（包名），包名，...&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、创建类，添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(value = &quot;user&quot;)</span> <span class="comment">//默认value为类名首字母小写的驼峰命名法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>开启包扫描的细节</strong></p>
<p>自定义扫描的包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">use-default-filters=&quot;false&quot;：表示现在不使用默认filter，自己配置filter</span></span><br><span class="line"><span class="comment">context:include-filter：设置要扫描的内容</span></span><br><span class="line"><span class="comment">context:exclude-filter：设置不扫描的内容</span></span><br><span class="line"><span class="comment">type=&quot;annotation&quot; 表示根据注解来扫描</span></span><br><span class="line"><span class="comment">expression=&quot;org.springframework.stereotype.Controller&quot;：表示只扫描双引号里的注解--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Component&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="基于注解实现属性注入"><a href="#基于注解实现属性注入" class="headerlink" title="基于注解实现属性注入"></a>基于注解实现属性注入</h4><p>@AutoWired：根据属性类型自动注入</p>
<p>@Qualifier：根据属性名称自动注入</p>
<p>@Resource：根据类型或者名称自动注入</p>
<p>@Value：注入普通类型属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Orders orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Qualifier需要和@AutoWired搭配使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(value = &quot;orders&quot;/*id值*/)</span></span><br><span class="line">    <span class="keyword">private</span> Orders orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span> <span class="comment">//@Resource(name=&quot;orders&quot;/*id值*/)</span></span><br><span class="line">    <span class="keyword">private</span> Orders orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(value = &quot;jjw&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="基于注解注入多例"><a href="#基于注解注入多例" class="headerlink" title="基于注解注入多例"></a>基于注解注入多例</h4><p>1、在需要多例调用的类上加 <strong>@Scope(“prototype”)</strong></p>
<p>2、在进行注入时不能直接使用 <strong>@Autowired</strong> ，最简单的方法是使用工厂方式注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动注入一个工厂，使用工厂实例化需要多例的类</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ObjectFactory&lt;T&gt; objectFactory;</span><br><span class="line"><span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> objectFactory.getObject();</span><br></pre></td></tr></table></figure>

<br>

<h4 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a><em>完全注解开发</em></h4><p>1、创建配置类，替代xml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//作为配置类，替代配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.test&quot;)</span> <span class="comment">//开启包扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、加载配置类，通过配置类获取bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//加载配置类</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">Orders</span> <span class="variable">orders</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;orders&quot;</span>,Orders.class);</span><br><span class="line">        orders.setOname(<span class="string">&quot;jjw&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><br>

<h3 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h3><p>什么是Aop</p>
<ul>
<li><p>面向切面编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<strong>耦合度降低</strong>，<strong>提高程序的可重用性</strong>，同时<strong>提高了开发的效率</strong></p>
</li>
<li><p>主要目的是将日志记录、性能统计、事物管理、异常处理等代码从业务逻辑代码中划分出来，从而可以在不修改源代码的情况下添加新的功能</p>
</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220201165200537.png" alt="image-20220201165200537"></p>
<br>

<h3 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h3><p>AOP底层使用了动态代理的方式，增强类中某个方法的功能</p>
<p><strong>有两种情况的动态代理</strong></p>
<p><strong>1、有接口的情况，使用JDK动态代理</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220201201233960.png" alt="image-20220201201233960"></p>
<p>创建接口实现类代理对象，增强类的方法</p>
<br>

<p><strong>实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*使用反射包下的Proxy类的newProxyInstance方法</span></span><br><span class="line"><span class="comment">*第一个参数：类加载器</span></span><br><span class="line"><span class="comment">*第二个参数：增强方法所在的类。这个类实现的接口，支持多个接口</span></span><br><span class="line"><span class="comment">*第三个参数：实现这个InvocationHandler，创建代理对象，写增强的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        <span class="type">UserDaoImpl</span> <span class="variable">userDaoImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//增强的逻辑</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//方法之前</span></span><br><span class="line">                System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//要增强的方法</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(userDaoImpl,args);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//方法之后执行</span></span><br><span class="line">                System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+method.getName());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>2、没有接口的情况，使用CGLIB动态代理</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220201203010743.png" alt="image-20220201203010743"></p>
<p>创建子类的代理对象，增强子类的方法</p>
<br>

<hr>
<br>

<h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p><strong>1、连接点</strong></p>
<p>类里面哪些方法可以被增强，这些方法称为连接点</p>
<br>

<p><strong>2、切入点</strong></p>
<p>实际被真正增强的方法，称为切入点</p>
<br>

<p><strong>3、通知</strong></p>
<ul>
<li><p>实际增强的逻辑部分称为通知</p>
</li>
<li><p>通知有多种类型</p>
<ul>
<li>前置通知</li>
<li>后置通知</li>
<li>环绕通知</li>
<li>异常通知</li>
<li>最终通知</li>
</ul>
</li>
</ul>
<br>

<p><strong>4、切面</strong></p>
<p>把通知应用到切入点的过程，称为切面</p>
<br>

<h3 id="AOP操作"><a href="#AOP操作" class="headerlink" title="AOP操作"></a>AOP操作</h3><p>参考：<a href="https://www.cnblogs.com/joy99/p/10941543.html">https://www.cnblogs.com/joy99/p/10941543.html</a></p>
<p>spring框架一般都是基于<strong>AspectJ</strong>实现AOP操作        *AspectJ不是spring的组成部分，它是一个独立的AOP框架</p>
<br>

<p><strong>引入AspectJ依赖</strong><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220202201934490.png" alt="image-20220202201934490"></p>
<p><strong>语法结构</strong><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220202202149656.png" alt="image-20220202202149656"></p>
<br>

<h4 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h4><p>1、创建<strong>User类</strong>，在类中定义方法</p>
<p>2、创建<strong>UserProxy增强类</strong></p>
<p>3、进行通知的配置</p>
<ul>
<li>在spring配置文件中开启配置扫描</li>
<li>使用注解创建<strong>User</strong>和<strong>UserProxy</strong></li>
<li>在增强类上添加注解**@Aspect**</li>
<li>在spring配置文件中开启生成代理对象</li>
</ul>
<p>4、配置不同类型的通知</p>
<ul>
<li>在增强类里面，在作为通知方法上添加通知类型注解，使用切入点表达式配置</li>
</ul>
<br>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启Aspect生成代理对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="comment">//@Before注解表示作为前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.test.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.test.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* com.test.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.test.User.add(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around1.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;around2.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//加载配置类</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>,User.class);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203142803295.png" alt="image-20220203142803295"></p>
<br>

<p><strong>抽取相同的切入点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.test.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="comment">//@Before注解表示作为前置通知</span></span><br><span class="line"><span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before.....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>有多个增强类，对同一个方法进行增强，可以设置增强类优先级，使其按顺序增强</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(3)</span> <span class="comment">//数值越小，优先级越高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h4><p>1、创建两个类，增强类和被增强类，创建方法</p>
<p>2、在spring配置文件中创建两个类对象</p>
<p>3、在spring配置文件中配置切入点</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203150952815.png" alt="image-20220203150952815"></p>
<br>

<hr>
<br>

<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p>JdbcTemplate是spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库进行操作</p>
<br>

<p><strong>引入jar包</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203161721997.png" alt="image-20220203161721997"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203161738736.png" alt="image-20220203161738736"></p>
<br>

<p><strong>数据库连接池配置</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203162110508.png" alt="image-20220203162110508"></p>
<br>

<p><strong>配置JdbcTemplate对象，注入DataSource</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203162731323.png" alt="image-20220203162731323"></p>
<br>

<p><strong>在dao层的dao实现类中注入JdbcTemplate对象</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220203164024760.png" alt="image-20220203164024760"></p>
<br>

<hr>
<br>

<h3 id="JdbcTemplate操作数据库"><a href="#JdbcTemplate操作数据库" class="headerlink" title="JdbcTemplate操作数据库"></a>JdbcTemplate操作数据库</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>1、对应数据库表创建类</p>
<p>2、在dao进行数据库添加操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">    <span class="comment">//创建sql语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_book value(?,?)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用方法实现</span></span><br><span class="line">    <span class="comment">//第一个参数为sql语句，第二个参数为对应?中的数值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, book.getName() , book.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">    <span class="comment">//创建sql语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_book set book_naem=?,book_price=?, where book_id=?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用方法实现</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, book.getName() , book.getPrice() , book.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteBook</span><span class="params">(Book book)</span>&#123;</span><br><span class="line">	<span class="comment">//创建sql语句</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line">    <span class="comment">//调用方法实现</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, book.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><strong>返回有多少条记录</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">selectCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from t_book&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql,Integer.class);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>返回一个对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Book <span class="title function_">selectById</span><span class="params">(String id)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_book where user_id = ?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BeanPropertyRowMapper会将返回的数据进行封装成对应的类,属性名需要一样</span></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class),id);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>返回一个集合</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">findAllBook</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_book&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BeanPropertyRowMapper会将返回的数据进行封装成对应的类</span></span><br><span class="line">    List&lt;Book&gt; bookList = jdbcTemplate.query(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bookList;</span><br><span class="line">&#125;xxxxxxxxxx8 1public List&lt;Book&gt; <span class="title function_">findAllBook</span><span class="params">()</span>&#123;<span class="number">2</span>    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_book&quot;</span>;<span class="number">3</span>    <span class="number">4</span>    <span class="comment">//BeanPropertyRowMapper会将返回的数据进行封装成对应的类5    List&lt;Book&gt; bookList = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class));6    7    return bookList;8&#125;public List&lt;Book&gt; findAllBook()&#123;    String sql = &quot;select * from t_book&quot;;        //BeanPropertyRowMapper会将返回的数据进行封装成对应的类    List&lt;Book&gt; bookList = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class));        return bookList;&#125;</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h4><p><strong>批量添加</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchAdd</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_book value(?,?)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] count = jdbcTemplate.batchUpdate(sql,batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>批量修改</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdate</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_book set book_naem=?,book_price=?, where book_id=?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] count = jdbcTemplate.batchUpdate(sql,batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>批量删除</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchDelete</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] count = jdbcTemplate.batchUpdate(sql,batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务概念</strong></p>
<p>事务时数据库操作最基本单元，逻辑上一组操作，要么都成功，要么都失败</p>
<p>在spring中进行事务操作有两种方式</p>
<p>1、编程式事务管理</p>
<p>2、声明式事务管理（底层使用AOP原理）</p>
<br>

<p><strong>四大特性</strong></p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<br>

<h3 id="示例（银行转账为例）"><a href="#示例（银行转账为例）" class="headerlink" title="示例（银行转账为例）"></a>示例（银行转账为例）</h3><p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220204194207653.png" alt="image-20220204194207653"></p>
<p><strong>步骤</strong></p>
<p>1、在spring配置文件中配置事务管理器</p>
<p>2、在spring配置文件中引入名称空间tx</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220204201052249.png" alt="image-20220204201052249"></p>
<p>3、开启事务注解</p>
<p>4、在service层上添加事务注解（也可以添加到方法上面）</p>
<ul>
<li>如果把注解添加到类上面，这个类里面所有的方法都添加事务</li>
<li>如果把这个注解添加到方法上面，就只给某一个方法添加事务</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定开启哪个事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driver</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduceMoney</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">//创建sql语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_bank set money = money-? where username=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;jjw1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMoney</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">//创建sql语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_bank set money = money+? where username=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;jjw2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accountMoney</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行事务操作</span></span><br><span class="line">        userDao.reduceMoney();</span><br><span class="line">        userDao.addMoney;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="声明式事务管理参数配置"><a href="#声明式事务管理参数配置" class="headerlink" title="声明式事务管理参数配置"></a>声明式事务管理参数配置</h3><p><strong>@Transaction(参数)</strong></p>
<br>

<p>propagation：事务的传播行为</p>
<ul>
<li>多事务方法直接进行调用，这个过程中事务是如何进行管理的（一个有无事务的方法调用另外一个有无事务的方法，事务如何进行处理）</li>
</ul>
<br>

<p>spring定义了七种事务传播行为</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220204204012987.png" alt="image-20220204204012987"></p>
<br>

<p>ioslation：事务隔离级别</p>
<ul>
<li>多事务操作之间不会产生影响，不会产生脏读，不可重复读、虚读</li>
</ul>
<br>

<p>timeout：超时时间</p>
<ul>
<li>事务需要在一定的时间内进行提交，否则进行回滚</li>
<li>默认为-1（不超时），设置时间已秒为单位</li>
</ul>
<br>

<p>readOnly：是否只读</p>
<ul>
<li>只能查询操作</li>
<li>默认为false（不只读）</li>
</ul>
<br>

<p>rollbackFor：回滚</p>
<ul>
<li>设置出现哪些异常进行事务回滚</li>
</ul>
<br>

<p>noRollbackFor：不回滚</p>
<ul>
<li>设置出现哪些异常进行不事务回滚</li>
</ul>
<br>

<br>

<h4 id="完全注解方式"><a href="#完全注解方式" class="headerlink" title="完全注解方式"></a><em>完全注解方式</em></h4><p>创建配置类，使用配置类替代xml配置文件</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220204205657762.png" alt="image-20220204205657762"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220204205933089.png" alt="image-20220204205933089"></p>
<br>

<hr>
<br>

<h2 id="spring5框架新功能"><a href="#spring5框架新功能" class="headerlink" title="spring5框架新功能"></a>spring5框架新功能</h2><p><strong>整个spring5框架是基于Java8的</strong>，运行时兼容JDK9</p>
<br>

<h3 id="支持整合日志框架"><a href="#支持整合日志框架" class="headerlink" title="支持整合日志框架"></a>支持整合日志框架</h3><p>spring5框架自带了通用的日志封装，官方建议使用Log4j2</p>
<br>

<p><strong>整合Log4j2</strong></p>
<p>1、引入jar包<img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220205124649342.png" alt="image-20220205124649342"></p>
<p>2、创建log4j2.xml（名称固定）配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志级别以及优先级排序:oFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Confiquration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到1og4j2内部各种详细输出--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--先定义所有的appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出日.志信息到控制台--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyY-MM-dd HH:mm : ss .sss&#125; [t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--root:用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p>3、自定义日志内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Test.class);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//加载配置类</span></span><br><span class="line">    log.info(<span class="string">&quot;info............&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Nullable注解和函数式注册对象"><a href="#Nullable注解和函数式注册对象" class="headerlink" title="Nullable注解和函数式注册对象"></a>Nullable注解和函数式注册对象</h3><p><strong>@Nullable</strong></p>
<p>@Nullable注解可以使用在方法上面，属性上面，参数上面</p>
<p>方法：表示方法返回值可以为空，不会报空指针异常</p>
<p>属性值：表示属性值可以为空</p>
<p>参数：表示参数值可以为空</p>
<br>

<p><strong>函数式注册对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建GenericApplicationContext对象</span></span><br><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="comment">//调用context的方法对象注册</span></span><br><span class="line">context.refresh();</span><br><span class="line">context.registerBean(<span class="string">&quot;user&quot;</span>,User.class,()-&gt; <span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line"><span class="comment">//获取对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h3 id="单元测试框架（JUnit5）"><a href="#单元测试框架（JUnit5）" class="headerlink" title="单元测试框架（JUnit5）"></a>单元测试框架（JUnit5）</h3><p><strong>整合JUnit4</strong></p>
<p>1、引入依赖</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220205145509132.png" alt="image-20220205145509132"></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220205151659537.png" alt="image-20220205151659537"></p>
<br>

<p>2、创建测试类，使用注解方式完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span> <span class="comment">//单元测试框架</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean.xml&quot;)</span> <span class="comment">//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Jtest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">//JUnit4下的@Test注解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>若不使用JUnit4框架的话test方法中需要加载配置文件后才能使用ioc容器中的bean，使用了@RunWith注解将会自动开启ioc容器，不需要再通过getBean()方法获得bean</strong></p>
<br>

<p><strong>整合JUnit5</strong></p>
<p>1、引入依赖</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/18/Spring/image-20220205152322878.png" alt="image-20220205152322878"></p>
<br>

<p>2、创建测试类，使用注解方式完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(&quot;classpath:bean.xml&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:bean.xml&quot;)</span> <span class="comment">//复合注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Jtest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud学习笔记</title>
    <url>/2022/03/27/SpringCloud/</url>
    <content><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p><strong>概述：</strong></p>
<p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在独立的进程中，服务与服务间采用轻量级的通信机制互相协作（通常是基于HTTP协议的RESTFul API）。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建</p>
<p><strong>SpringCloudAlibaba介绍：</strong></p>
<ul>
<li>对SpringCloud的标准实现</li>
<li>以微服务为核心的整体解决方案</li>
<li>开源与平台服务分开维护</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/27/SpringCloud/image-20220327153557109.png" alt="image-20220327153557109"></p>
<p><strong>测试版本号：</strong></p>
<p>JDK 1.8+</p>
<p>Java 8</p>
<p>Maven 3.8.2</p>
<p>SpringBoot 2.3.2</p>
<p><strong>SpringCloudAlibaba、SpringCloud、SpringBoot各版本对应关系：</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/27/SpringCloud/image-20220327155340146.png" alt="image-20220327155340146"></p>
<hr>
<h2 id="RestTemplate模拟分布式架构"><a href="#RestTemplate模拟分布式架构" class="headerlink" title="RestTemplate模拟分布式架构"></a>RestTemplate模拟分布式架构</h2><p><strong>包结构：</strong></p>
<img src="https://jjw-beiqi.github.io/2022/03/27/SpringCloud/image-20220327164453885.png" alt="image-20220327164453885" style="zoom:67%;">



<p><strong>介绍：</strong></p>
<ul>
<li>Order为订单，Stock为库存</li>
<li>Order端口号为8011，Stock端口号为8010</li>
<li>Order增加订单方法（add）调用Stock扣除库存方法（reduct）</li>
</ul>
<p><a href="http://localhost:8011/order/add">http://localhost:8011/order/add</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下单成功！&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://localhost:8010/stock/reduct&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>+msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://localhost:8010/stock/reduct">http://localhost:8010/stock/reduct</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/stock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/reduct&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reduct</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扣减库存&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>结果：</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/27/SpringCloud/image-20220327171653063.png" alt="image-20220327171653063"></p>
<p>上述使用 RestTemplate 模拟的分布式架构其实有很大的弊端，请求的 url 是固定的不能更改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">restTemplate.getForObject(<span class="string">&quot;http://localhost:8010/stock/reduct&quot;</span>, String.class);</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="SpringCloudAlibaba环境搭建"><a href="#SpringCloudAlibaba环境搭建" class="headerlink" title="SpringCloudAlibaba环境搭建"></a>SpringCloudAlibaba环境搭建</h2><p><strong>组件版本关系：</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/27/SpringCloud/image-20220327175535680.png" alt="image-20220327175535680"></p>
<p><strong>自测所用版本：</strong></p>
<p>Spring Cloud Alibaba：2.2.5.RELEASE</p>
<p>Spring Boot：2.3.2.RELEASE</p>
<p>Spring Cloud：Hoxton.SR8</p>
<blockquote>
<p>Spring Cloud Alibaba会自动管理各组件版本，所以在引入各组件依赖时不需要加版本号</p>
</blockquote>
<h3 id="引入spring-cloud-alibaba依赖"><a href="#引入spring-cloud-alibaba依赖" class="headerlink" title="引入spring-cloud-alibaba依赖"></a>引入spring-cloud-alibaba依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Cloud Alibaba的版本管理，通过dependency完成继承 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="引入spring-cloud依赖"><a href="#引入spring-cloud依赖" class="headerlink" title="引入spring-cloud依赖"></a>引入spring-cloud依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Cloud版本管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud&lt;/ groupId&gt;</span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><p><a href="github.com/alibaba/nacos">下载链接</a></p>
<p><strong>什么是 Nacos</strong></p>
<p>官方：一个更易于构建云原生应用的动态<strong>服务发现</strong>，<strong>服务配置</strong>和<strong>服务管理平台</strong></p>
<blockquote>
<p>SOA架构解决了分布式架构中调用关系错综复杂、难以维护的情况，只需要将服务器地址（localhost:8010）更改成对应的服务名即可</p>
<p>而微服务架构结合了SOA架构的这种优点，将其作为一个组件 &#x3D;&#x3D;&#x3D;&#x3D;&gt; 注册中心</p>
<p>注册中心就是把服务注册到一个中心中，调用的时候直接写服务名即可，而不需要调用远程服务地址</p>
</blockquote>
<p><strong>Nacos的关键特性包括：</strong></p>
<ul>
<li>服务发现和服务健康监测</li>
<li>动态配置服务</li>
<li>动态DNS服务</li>
<li>服务及其元数据管理</li>
</ul>
<h3 id="注册中心演变及其设计思想"><a href="#注册中心演变及其设计思想" class="headerlink" title="注册中心演变及其设计思想"></a>注册中心演变及其设计思想</h3><blockquote>
<img src="https://jjw-beiqi.github.io/2022/03/27/SpringCloud/image-20220328112018730.png" alt="image-20220328112018730" style="zoom: 67%;">

<p>缺点：需要手动维护服务远程地址</p>
<img src="https://jjw-beiqi.github.io/2022/03/27/SpringCloud/image-20220328112248584.png" alt="image-20220328112248584" style="zoom: 67%;">

<p>缺点：当服务进行水平扩展，有多个远程地址时，需要在本地实现一个负载均衡机制</p>
<img src="https://jjw-beiqi.github.io/2022/03/27/SpringCloud/image-20220328113553915.png" alt="image-20220328113553915" style="zoom:67%;">

<p>缺点：每个服务都需要在Nginx中配置</p>
<img src="https://jjw-beiqi.github.io/2022/03/27/SpringCloud/image-20220330194211779.png" alt="image-20220330194211779" style="zoom:67%;">
</blockquote>
<h3 id="Nacos核心功能"><a href="#Nacos核心功能" class="headerlink" title="Nacos核心功能"></a>Nacos核心功能</h3><p><strong>服务注册:</strong> Nacos Client会通过发送REST请求的方式向Nacos Server注册自己的服务，提供自身的元数据，比如ip地址、端口等信息。Nacos Server接收到注册请求后，就会把这些元数据信息存储在一个双层的内存Map中。</p>
<p>**服务心跳:**在服务注册后，Nacos Client会维护一个定时心跳来持续通知Nacos Server，说明服务一直处于可用状态，防止被剔除。默认5s发送一次心跳。</p>
<p><strong>服务同步:</strong> Nacos Server集群之间会互相同步服务实例，用来保证服务信息的一致性。</p>
<p><strong>服务发观︰</strong>股务消费者(Naoos Client)在调用服务提供者的服务时，会发送一个REST清求给Nacos Sever，获取上面注册的服务清单，并且缓存在Nacos Client本地，同时会在Nacos Client本地开启一个定时任务定时拉取服务端最新的注册表信息更新到本地缓存</p>
<p><strong>服务健康检查:</strong> Nacos Server会开启一个定时任务用来检查注册服务实例的健康情况，对于超过15s没有收到客户带心练的实例会将它的healhty属性置为false（客户端服务发现时不会发现），如果某个实例超过30秒没有收到心跳，直接剔除该实例（被剔除的实例如果恢复发送心跳则会重新注册）</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/27/SpringCloud/image-20220330201624941.png" alt="image-20220330201624941"></p>
]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC学习笔记</title>
    <url>/2022/03/20/SpringMVC/</url>
    <content><![CDATA[<h1 id="SpringMvc"><a href="#SpringMvc" class="headerlink" title="SpringMvc"></a>SpringMvc</h1><p>SpringMvc是Spring的一个后续产品，是Spring的一个子项目</p>
<p>SpringMvc是Spring为表述层开发提供的一整套完备的解决方案</p>
<h2 id="创建SpringMvc项目"><a href="#创建SpringMvc项目" class="headerlink" title="创建SpringMvc项目"></a>创建SpringMvc项目</h2><ol>
<li><p>创建maven下的web项目</p>
<p>参考：<a href="https://blog.csdn.net/weixin_42222334/article/details/80362126">https://blog.csdn.net/weixin_42222334/article/details/80362126</a></p>
</li>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置web.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置SpringMvc的前端控制器，对浏览器发送的请求进行统一处理 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置SpringMvc配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将前端控制器DispatherServlet的初始化时间提前到服务器启动时 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      设置springmvc的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">      /所匹配的请求可以是/login或.js...</span></span><br><span class="line"><span class="comment">      但不能匹配.jsp的请求</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<br>


<hr>
<br>

<h2 id="配置springMVC-xml"><a href="#配置springMVC-xml" class="headerlink" title="配置springMVC.xml"></a>配置springMVC.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器，也可以选择其他的视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 视图解析器优先级 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>扩展：过滤器、拦截器、aop 顺序</strong></p>
<p>由于SpringMVC的前端控制器是DispatherServlet所以有必要了解一下过滤器、拦截器、aop 的执行顺序</p>
<p>filter—&gt;Interceptor—-&gt;@Aspect –&gt;Interceptor</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/20151219102326359.png" alt="img"></p>
<br>

<hr>
<br>

<h2 id="SpringMVC的请求"><a href="#SpringMVC的请求" class="headerlink" title="SpringMVC的请求"></a>SpringMVC的请求</h2><br>

<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系</p>
<ul>
<li>标识一个类：设置请求的请求路径的初始信息</li>
<li>标识一个方法：设置映射请求请求路径的具体信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="meta">@RequestMapping(value=&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">controller</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//返回视图名称</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//http://localhost:8080/springmvc/test/index</span></span><br></pre></td></tr></table></figure>

<p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMvc的核心配置文件，通过扫描组件会找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，通过Thymeleaf（也可以使用其他的视图解析器）对视图进行渲染，最终转发到视图所对应页面</p>
<br>

<p><strong>@RequestMapping中的value属性</strong></p>
<p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p>
<p>@RequestMapping注解的value属性必须设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&#123;&quot;index&quot;,&quot;test&quot;&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//返回视图名称</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>@RequestMapping中的method属性</strong></p>
<p>@RequestMapping中的method属性通过请求的请求方式（get&#x2F;post匹配请求映射）</p>
<p>@RequestMapping中的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;,method=RequestMethod.GET)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//返回视图名称</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>@RequestMapping的派生注解</strong></p>
<ul>
<li><p>@GetMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等同于@RequestMapping(method=RequestMethod.GET)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>@PostMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等同于@RequestMapping(method=RequestMethod.POST)</span></span><br></pre></td></tr></table></figure>

<p>…</p>
</li>
</ul>
<br>

<p><strong>@RequestMapping中的params属性</strong></p>
<p>@RequestMapping中的params属性通过请求的请求参数匹配请求映射</p>
<p>@RequestMapping中的params属性是一个字符串的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;param&quot;:要求请求映射所匹配的请求必须携带param请求参数</span><br><span class="line">&quot;param&quot;:要求请求映射所匹配的请求必须不能携带param请求参数</span><br><span class="line">&quot;param=value&quot;:要求请求映射所匹配的请求必须携带param请求参数且param=value&quot;</span><br><span class="line">param!=value&quot;:要求请求映射所匹配的请求必须携带param请求参数但是param!=value</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;,param=&#123;&quot;usename&quot;,&quot;!abc&quot;&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//返回视图名称</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>SpringMVC支持ant风格的路径</strong></p>
<p>？：表示任意的单个字符</p>
<p>*：表示任意的0个或多个字符</p>
<p>**：表示任意的一层或多层目录</p>
<br>

<hr>
<br>

<h3 id="SpringMVC获取请求参数"><a href="#SpringMVC获取请求参数" class="headerlink" title="SpringMVC获取请求参数"></a>SpringMVC获取请求参数</h3><p>可以使用servletAPI获取参数，但基本不使用</p>
<p>当发送的参数名与@RequestMapping标识方法中参数名一致时，会自动匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>当有多个请求参数名一样时，如： …?hobby&#x3D;a&amp;hobby&#x3D;b</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以这么写</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(String hobby)</span>&#123; <span class="comment">//hobby=&quot;a,b&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(String[] hobby)</span>&#123; <span class="comment">//hobby=[a,b]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>@RequestParam()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当请求参数名和方法参数名不一致时，使用@RequestParam()</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(&quot;user_name&quot;)</span> String username, </span></span><br><span class="line"><span class="params">    String password)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestParam()</span>将请求参数和方法参数映射起来，属性：</span><br><span class="line">    required 是否必须带有这个请求参数</span><br><span class="line">    defaultValue 不管required属性值为<span class="literal">true</span>或<span class="literal">false</span>，当value所指定的请求参数没有传输或传输的值为“”时，则使用默认值</span><br></pre></td></tr></table></figure>

<br>

<p><strong>@RequestHeader</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(</span></span><br><span class="line"><span class="params">    String username, </span></span><br><span class="line"><span class="params">    String password,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;Host&quot;)</span> String host)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestHeader()</span>会从请求头中取出对应的字段赋值给参数，属性：</span><br><span class="line">    required 是否必须带有这个请求参数</span><br><span class="line">    defaultValue 不管required属性值为<span class="literal">true</span>或<span class="literal">false</span>，当value所指定的请求参数没有传输或传输的值为“”时，则使用默认值</span><br></pre></td></tr></table></figure>

<br>

<p><strong>@CookieValue</strong></p>
<p>与前面的使用方法一样</p>
<br>

<p><strong>通过POJO获取请求参数</strong></p>
<p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="keyword">public</span> String password;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(User user)</span>&#123; </span><br><span class="line">    System.out.println(user.getUsername() + user.getPassword);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>解决中文乱码问题</strong></p>
<p>在web.xml文件中添加字符编码过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字符编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置请求编码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 设置响应编码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置字符编码过滤器的过滤路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>



<hr>
<br>

<h3 id="域对象共享数据"><a href="#域对象共享数据" class="headerlink" title="域对象共享数据"></a>域对象共享数据</h3><p><strong>使用servletAPI向request域对象共享数据</strong></p>
<p>可以使用servletAPI向域对象中存放数据，但基本不使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;testString&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>使用ModelAndView向request域对象共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * ModelAndView有Model和View的功能</span></span><br><span class="line"><span class="comment">        * Model主要用于向请求域中共享数据</span></span><br><span class="line"><span class="comment">        * View主要用于设置视图，实现页面跳转</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">//向请求域中共享数据</span></span><br><span class="line">    mv.addObject(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图，实现页面跳转</span></span><br><span class="line">    mv.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>使用Model向request域对象共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(Model m)</span>&#123;</span><br><span class="line">    m.addAttribute(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>使用Map向request域对象共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(Map&lt;String,Object&gt; map)</span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>使用ModelMap向request域对象共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(ModelMap mm)</span>&#123;</span><br><span class="line">    mm.addAttribute(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>向session域中共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>向application域共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="SpringMVC的视图"><a href="#SpringMVC的视图" class="headerlink" title="SpringMVC的视图"></a>SpringMVC的视图</h2><br>

<h3 id="自定义视图解析器"><a href="#自定义视图解析器" class="headerlink" title="自定义视图解析器"></a>自定义视图解析器</h3><p>当控制器方法中设置的视图名没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p>
<br>

<h3 id="转发视图"><a href="#转发视图" class="headerlink" title="转发视图"></a>转发视图</h3><p>SpringMVC中默认的转发视图是InternalResourceView</p>
<p>创建转发视图的情况：</p>
<p>当控制器方法中所设置的视图名称以 “forward:” 为前缀时，<strong>创建InternalResourceView视图</strong>，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀 “forward:” 去掉，剩余部分作为最终路径通过转发的方式实现跳转<strong>（只能跳转@RequestMapping映射过的视图）</strong></p>
<p>例如 “forward:&#x2F;“，”forward:&#x2F;employee”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="重定向视图"><a href="#重定向视图" class="headerlink" title="重定向视图"></a>重定向视图</h3><p>SpringMVC中默认的重定向视图是RedirectView</p>
<p>当控制器方法中所设置的视图名称以 “redirect:” 为前缀时，<strong>创建RedirectView视图</strong>，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀 “redirect:” 去掉，剩余部分作为最终路径通过重定向的方式实现跳转<strong>（只能跳转@RequestMapping映射过的视图）</strong></p>
<p>例如 “redirect:&#x2F;“，”redirect:&#x2F;employee”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="视图控制器-view-controller"><a href="#视图控制器-view-controller" class="headerlink" title="视图控制器 view-controller"></a>视图控制器 view-controller</h3><p><em>当控制器方法中，<strong>仅仅用来实现页面跳转（即不做任何其他的操作，只是页面跳转）</strong>，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</em></p>
<blockquote>
<p>使用场景：</p>
<p>spring文档里建议并将其做为最佳实践将所有的jsp页面放到WEB-INF下，不让直接访问，那么我们只能通过controller来访问jsp页面了，但是我们总不能为每个页面都写一个controller吧，那样太麻烦了，所以mvc:view-controller就是处理这个场景的一个shortcut（快捷方式）。</p>
</blockquote>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/image-20220313105546745-16471406629442.png" alt="image-20220313105546745"></p>
<br>

<p>配置view-controller后所有映射都会失效</p>
<p>原因：<strong>如果没有mvc:annotation-driven，那么所有的@Controller注解可能就没有解析</strong>，所有当有请求时候都没有匹配的处理请求类，就都去<strong>mvc:default-servlet-handler</strong>即default servlet处理了。</p>
<br>

<blockquote>
<p><a href="https://blog.csdn.net/qq_41984887/article/details/105045936">&lt;mvc:annotation-driven &#x2F;&gt;的作用</a></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/image-20220313105823765-16471406609571.png" alt="image-20220313105823765"></p>
</blockquote>
<br>

<h3 id="InternalResourceViewResolver控制器"><a href="#InternalResourceViewResolver控制器" class="headerlink" title="InternalResourceViewResolver控制器"></a>InternalResourceViewResolver控制器</h3><p>springMCV.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="RESTFul简介"><a href="#RESTFul简介" class="headerlink" title="RESTFul简介"></a>RESTFul简介</h2><blockquote>
<p> REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移。 它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。 他在论文中提到：”我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST指的是一组架构约束条件和原则。” 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。</p>
<p> REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。</p>
</blockquote>
<p>参考：<a href="https://www.runoob.com/w3cnote/restful-architecture.html">菜鸟教程</a></p>
<br>

<h3 id="RESTFul的实现"><a href="#RESTFul的实现" class="headerlink" title="RESTFul的实现"></a>RESTFul的实现</h3><p>具体来说就是HTTP协议里的四个表示操作方式的动词：GET、POST、PUT、DELETE</p>
<ul>
<li>GET：用于获取资源</li>
<li>POST：用于新建资源</li>
<li>PUT：用于更新资源</li>
<li>DELETE：用于删除资源</li>
</ul>
<br>

<p>REST风格提倡URL地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为URL地址的一部分，以保证整体风格的一致性</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统方式</th>
<th>REST风格</th>
</tr>
</thead>
<tbody><tr>
<td>查询</td>
<td>getUserById?id&#x3D;1</td>
<td>user&#x2F;1——&gt;GET</td>
</tr>
<tr>
<td>保存</td>
<td>saveUser</td>
<td>user——&gt;POST</td>
</tr>
<tr>
<td>删除</td>
<td>deleteUser?id&#x3D;1</td>
<td>user&#x2F;1——&gt;DELETE</td>
</tr>
<tr>
<td>更新</td>
<td>updateUser</td>
<td>user——&gt;PUT</td>
</tr>
</tbody></table>
<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/user/&#123;id&#125;&quot;, method=RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/user&quot;, method=RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveUser</span><span class="params">(String username,String password)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/user/&#123;id&#125;&quot;, method=RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/user&quot;, method=RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateUser</span><span class="params">(String username,String password)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="PUT、DELETE请求方式存在浏览器兼容问题"><a href="#PUT、DELETE请求方式存在浏览器兼容问题" class="headerlink" title="PUT、DELETE请求方式存在浏览器兼容问题"></a>PUT、DELETE请求方式存在浏览器兼容问题</h3><blockquote>
<p>浏览器确实支持PUT和DELETE，但是HTML不支持。</p>
<p>这是因为HTML 4.01和最终的W3C HTML 5.0规范都说它们的form元素应允许的唯一HTTP方法是GET和POST。</p>
<p>在HTML 5的开发过程中对此进行了很多讨论，有一次他们将它们添加到HTML 5中，然后再次删除。之所以从HTML5规范中删除其他方法，是因为HTML 4级浏览器永远无法支持它们(在制作时不属于HTML)。</p>
</blockquote>
<br>

<p>解决：在web.xml文件中配置HiddenHttpMethodFilter过滤器</p>
<p><em><strong>注：同时编码过滤器必须放在HiddenHttpMethodFilter过滤器之前</strong></em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置HiddenHttpMethodFilter过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<ul>
<li><p>PUT请求表单提交代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显式请求方式为post请求方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/user&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加一个隐藏域用于更改请求方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;更改&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p>由于DELETE请求通常使用超链接、按钮形式，所以使用js代码将超链接、按钮与隐藏域绑定</p>
<p>更改DELETE请求参考：<a href="https://blog.csdn.net/zzz841318172/article/details/109614543">如何将超链接GET请求变成DELETE请求</a></p>
</li>
</ul>
<br>

<br>

<p>扩展问题：DispatcherServlet是访问不到静态资源的，当DispatcherServlet访问不到时，应该让Tomcat配置的DefaultServlet去访问静态资源，因此需要配置<strong>mvc:default-servlet-handler</strong>标签，由于配置<strong>mvc:default-servlet-handler</strong>标签后也会导致映射路径失效，所以也需要配置<strong>mvc:annotation-driven</strong>标签</p>
<blockquote>
<p>如果配置了DispatcherServlet，那么所有的请求都会被拦截,包括静态资源。</p>
<ul>
<li>‘&#x2F;‘ 将会替换掉容器的default servlet, 将会处理所有其他handler(Servlet)都不处理的访问请求.</li>
<li>如果web.xml没有配置其他特殊路径的servlet, 基本上所有的请求都交由DispatcherServlet处理.</li>
<li>将不会再访问容器中原始默认的servlet(你对静态资源的访问就是通过容器默认servlet处理的)，故而静态资源将不可访问！</li>
</ul>
</blockquote>
<br>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开放静态资源访问 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<br>

<p><font color="orange"><strong>刨根问底一下 为什么加入两个注解就没有问题了呢？</strong></font></p>
<blockquote>
<p>首先是两个注解都不加，此时HandlerMappings中的<strong>AnnotationHandlerMapping</strong>中<strong>存储这Controller和url的映射关系</strong>，由于我们<strong>没有编写Controller去处理js html等静态资源</strong>，所以此时的状态是动态资源可以访问，静态资源不可访问。</p>
<img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/1263112-20190406160521291-2027530586.png" alt="img" style="zoom:50%;">

<p>其次是<strong>只加上default-servlet-handler，发现处理Controller的AnnotationHandler不见了</strong>，取而代之的是SimpleURLHandlerMapping，该Handler种的handlerMap非常简单只有一个&#x2F;** <strong>即无论什么请求都直接去当前webapp下去找。这样配置静态资源肯定是可以访问的</strong>，因为它的作用和不使用SpringMVC中的DIsplacedServlet直接使用Tomcat一样。但由于AnnotationHandler的缺失，导致Controller这种基于注解配置处理请求的方法无法访问，所以这种配置下的状态是<strong>静态资源可以访问，动态资源不可以访问。</strong></p>
<img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/1263112-20190406160807464-126528350.png" alt="img" style="zoom:50%;">

<p><strong>最后当把两个注解都加上的时候，不仅有处理静态资源的SimpleUrlHandlerMapping，还多了一个优先级最高的RequestMapping</strong>，点开详情信息发现我们配置的Controller都在里面。这就是我们要的效果：</p>
<p><font color="red"><strong>对于每一个非jsp请求都会被DispatchServlet拦下，然后交给优先级最高的RequestMapping处理。RequestMapping遍历自己的Mappings，如果这个请求是一个动态请求，那么一定可以找到对应的Controller，Controller处理并返回；如果该请求是一个针对静态资源文件的，RequestMapping无能为力，他会按照优先级交给后续HandlerMapping如没啥用的BeanNameUrlHandlerMapping，以及放在最后用来兜底的SimpleUrlHandlerMapping，当SimpleUrlHandlerMapping拿到一个针对静态资源的请求后，会在&#x2F;**目录下找到静态资源并返回。</strong></font></p>
<img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/1263112-20190406161147379-857785000.png" alt="img" style="zoom: 67%;">



<p><a href="https://www.cnblogs.com/AshOfTime/p/10655014.html">转载自原创博主</a></p>
</blockquote>
<hr>
<br>

<h2 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h2><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</p>
<p>HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，ResponseEntity</p>
<br>

<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span>&#123;</span><br><span class="line">    System.out.println(requestBody);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/user/test&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=&quot;...&quot;&amp;password=&quot;...&quot;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="RequestEntity"><a href="#RequestEntity" class="headerlink" title="RequestEntity"></a>RequestEntity</h3><p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可通过getHeaders()获得请求头信息，通过getBody()获取请求体信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span>&#123;</span><br><span class="line">    System.out.println(requestEntity.getHeaders());</span><br><span class="line">    System.out.println(requestEntity.getBody());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;成功！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：浏览器页面显式 成功！</p>
<br>

<p><strong>处理 json</strong></p>
<p>1、导入依赖</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/image-20220322141832294.png" alt="image-20220322141832294"></p>
<p>2、在SpringMVC核心配置文件中开启mvc的注解驱动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven/&gt;</span><br></pre></td></tr></table></figure>

<p>3、在处理器方法上使用@ResponseBody注解进行标识</p>
<p>4、将Java对象直接作为控制器方法的返回值返回时，就会自动转换为json格式字符串</p>
<br>

<h3 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h3><p>ResponseEntity用于控制器方法的返回值类型，该控制器的返回值就是响应到浏览器的响应报文</p>
<br>

<h3 id="RestController注解"><a href="#RestController注解" class="headerlink" title="@RestController注解"></a>@RestController注解</h3><p>@RestController注解是SpringMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody</p>
<br>

<hr>
<br>

<h2 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h2><br>

<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>利用ResponseEntity实现下载功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; test(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取servletContext对象</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletcontext</span> <span class="operator">=</span> session.getServletContext ();</span><br><span class="line">    <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">realpath</span> <span class="operator">=</span> servletcontext. getRealPath(<span class="string">&quot;/static/img/1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//创建输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realpath);</span><br><span class="line">    <span class="comment">//创建字节数组（这里最好使用循环读取）</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">    <span class="comment">//将流读到字节数组中</span></span><br><span class="line">    is.read(bytes);</span><br><span class="line">    <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">    MultiValueMap&lt;String,String&gt; headers = <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    <span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">    headers.add(<span class="string">&quot;content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//设置响应状态码</span></span><br><span class="line">    <span class="type">HttpStatus</span> <span class="variable">statuscode</span> <span class="operator">=</span> HttpStatus.OK;</span><br><span class="line">    <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">    ResponseEntity&lt;<span class="type">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(bytes,headers,statuscode) ;</span><br><span class="line">    <span class="comment">//关团输入流is.close(;</span></span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload&lt;/ artifactId&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 必须使用post请求方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/up&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    头像:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;photo&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">”上传</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在SpringMVC核心配置文件中配置文件上传解析器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件上传解析器，将上传的文件封装为MultipartFile --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根据id获取的解析器 解析器id必须为multipartResolver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;up&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(MultipartFile photo,HttpSession session)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> photo.getOriginalFilename();</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="type">String</span> <span class="variable">photoPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(photoPath);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> photoPath + File.separator<span class="comment">/*文件分隔符*/</span> + fileName;</span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终上传到这个文件夹：<img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/image-20220324105512280.png" alt="image-20220324105512280"></p>
<br>

<hr>
<br>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>SpringMVC中的拦截器用于拦截控制器方法的执行</p>
<p>SpringMVC中的拦截器需要实现HandlerInterceptor或者继承HandlerInterceptorAdapter类</p>
<p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置</p>
<br>

<h3 id="拦截器的配置"><a href="#拦截器的配置" class="headerlink" title="拦截器的配置"></a>拦截器的配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.interceptors.Interceptor&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 对所有请求进行拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="实现拦截器"><a href="#实现拦截器" class="headerlink" title="实现拦截器"></a>实现拦截器</h3><p>拦截器三个方法执行时机</p>
<ul>
<li>控制器方法执行之前</li>
<li>控制器方法执行之后</li>
<li>渲染视图完毕之后</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//控制器方法执行之前</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        true：放行，即调用控制器方法</span></span><br><span class="line"><span class="comment">        false：不放行，即不调用控制器方法</span></span><br><span class="line"><span class="comment">        */</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//控制器方法执行之后</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//渲染视图完毕之后</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.afterCompletion(request, response, handler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>关于preHandle放行可以在DispatcherServlet源码中看见如下代码</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/image-20220324111906179.png" alt="image-20220324111906179"></p>
<p>进入applyPreHandle方法中可以看见若拦截器的preHandle方法返回true则这个方法返回true，结合DispatcherServlet的源码可知 if 代码块中的return不会执行，可以继续往下走</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/image-20220324112151787.png" alt="image-20220324112151787"></p>
</blockquote>
<br>

<h3 id="拦截指定路径"><a href="#拦截指定路径" class="headerlink" title="拦截指定路径"></a>拦截指定路径</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span>	<span class="comment">&lt;!-- 配置需要拦截的路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>/&gt;</span>	  <span class="comment">&lt;!-- 配置需要排除在外的拦截路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.interceptors.Interceptor&quot;</span>/&gt;</span>	<span class="comment">&lt;!-- 配置使用哪个拦截器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="多个拦截器的执行顺序"><a href="#多个拦截器的执行顺序" class="headerlink" title="多个拦截器的执行顺序"></a>多个拦截器的执行顺序</h3><p>若每个拦截器的preHandle()都返回true</p>
<ul>
<li>则此时拦截器的执行顺序与拦截器在SpringMVC配置文件中的配置顺序有关</li>
<li>preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行（）</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/image-20220324124618700.png" alt="image-20220324124618700"></p>
<p>若某个拦截器的preHandle()返回了false</p>
<ul>
<li>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</li>
</ul>
<br>

<hr>
<br>

<h2 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h2><p>SpringMVC提供了一个处理控制器方法执行过程中出现的异常的接口：HandlerExceptionResolver</p>
<p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</p>
<br>

<h3 id="使用自定义异常理器"><a href="#使用自定义异常理器" class="headerlink" title="使用自定义异常理器"></a>使用自定义异常理器</h3><p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver</p>
<p><strong>基于配置的异常处理</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置异常处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 				props的键表示处理方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">				props的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">			--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;异常全类名&quot;</span>&gt;</span>新的视图名称<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将异常信息以键值对的形式放入请求域中（可选） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;键名&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>基于注解的异常处理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置需要处理的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span>;</span><br><span class="line">    <span class="comment">//ex表示当前请求处理中出现的异常对象</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">testException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mv.addObject(<span class="string">&quot;Exception&quot;</span>,ex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="注解配置SpringMVC"><a href="#注解配置SpringMVC" class="headerlink" title="注解配置SpringMVC"></a>注解配置SpringMVC</h2><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p>
<br>

<h4 id="创建初始化类，代替web-xml"><a href="#创建初始化类，代替web-xml" class="headerlink" title="创建初始化类，代替web.xml"></a>创建初始化类，代替web.xml</h4><blockquote>
<p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。</p>
<p>Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的<br>WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletinitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletlnitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//web工程的初始化类，用于代替web.xml</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">webInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定spring的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定DispatcherServlet的映射规则</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">characterEncodingFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        characterEncodingFilter.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        characterEncodingFilter.setForceResponseEncoding(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">hiddenHttpMethodFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;characterEncodingFilter,hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getRootConfigClasses、getServletConfigClasses、getServletMappings是必须的以外，还可以重写其他的方法</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/image-20220324140948565.png" alt="image-20220324140948565"></p>
<br>

<p><strong>完成后项目结构如下图</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/20/SpringMVC/image-20220324141036114.png" alt="image-20220324141036114"></p>
<br>

<h3 id="SpringConfig类"><a href="#SpringConfig类" class="headerlink" title="SpringConfig类"></a>SpringConfig类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标志为配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//开启扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">//开启注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Webconfig类"><a href="#Webconfig类" class="headerlink" title="Webconfig类"></a>Webconfig类</h3><p><strong>总体：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标识当前类为一个配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com&quot;)</span></span><br><span class="line"><span class="comment">//mvc注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ITemplateResolver <span class="title function_">templateResolver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">webApplicationContext</span> <span class="operator">=</span> ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(</span><br><span class="line">                webApplicationContext.getServletContext()</span><br><span class="line">        );</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SpringTemplateEngine <span class="title function_">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span>&#123;</span><br><span class="line">        <span class="type">SpringTemplateEngine</span> <span class="variable">templateEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringTemplateEngine</span>();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成视图解析器并为解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span>&#123;</span><br><span class="line">        <span class="type">ThymeleafViewResolver</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThymeleafViewResolver</span>();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文件解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CommonsMultipartResolver</span> <span class="variable">commonsMultipartResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">        <span class="keyword">return</span> commonsMultipartResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置异常处理解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMappingExceptionResolver</span> <span class="variable">exceptionResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line">        <span class="comment">//以键值对形式放入要处理的异常</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;java.lang.Exception&quot;</span>,<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">        exceptionResolver.setExceptionMappings(prop);</span><br><span class="line">        <span class="comment">//将异常信息放入请求域</span></span><br><span class="line">        exceptionResolver.setExceptionAttribute(<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">        resolvers.add(exceptionResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//default-servlet-handler</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interceptor</span>();</span><br><span class="line">        <span class="comment">//排除拦截路径</span></span><br><span class="line">        registry.addInterceptor(interceptor).excludePathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加view-controller</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/hello&quot;</span>).setViewName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="配置视图解析器"><a href="#配置视图解析器" class="headerlink" title="配置视图解析器"></a>配置视图解析器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置生成模板解析器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ITemplateResolver <span class="title function_">templateResolver</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">webApplicationContext</span> <span class="operator">=</span> ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">    <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(</span><br><span class="line">        webApplicationContext.getServletContext()</span><br><span class="line">    );</span><br><span class="line">    templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates&quot;</span>);</span><br><span class="line">    templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">    templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">    <span class="keyword">return</span> templateResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SpringTemplateEngine <span class="title function_">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span>&#123;</span><br><span class="line">    <span class="type">SpringTemplateEngine</span> <span class="variable">templateEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringTemplateEngine</span>();</span><br><span class="line">    templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">    <span class="keyword">return</span> templateEngine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成视图解析器并为解析器注入模板引擎</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span>&#123;</span><br><span class="line">    <span class="type">ThymeleafViewResolver</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThymeleafViewResolver</span>();</span><br><span class="line">    viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="配置文件上传解析器"><a href="#配置文件上传解析器" class="headerlink" title="配置文件上传解析器"></a>配置文件上传解析器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置文件解析器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">CommonsMultipartResolver</span> <span class="variable">commonsMultipartResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">    <span class="keyword">return</span> commonsMultipartResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="配置异常处理解析器"><a href="#配置异常处理解析器" class="headerlink" title="配置异常处理解析器"></a>配置异常处理解析器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置异常处理解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> &#123;</span><br><span class="line">    <span class="type">SimpleMappingExceptionResolver</span> <span class="variable">exceptionResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line">    <span class="comment">//以键值对形式放入要处理的异常</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    prop.setProperty(<span class="string">&quot;java.lang.Exception&quot;</span>,<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">    exceptionResolver.setExceptionMappings(prop);</span><br><span class="line">    <span class="comment">//将异常信息放入请求域</span></span><br><span class="line">    exceptionResolver.setExceptionAttribute(<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">    resolvers.add(exceptionResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="配置default-servlet-handler"><a href="#配置default-servlet-handler" class="headerlink" title="配置default-servlet-handler"></a>配置default-servlet-handler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//default-servlet-handler</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">    configurer.enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interceptor</span>();</span><br><span class="line">    <span class="comment">//排除拦截路径</span></span><br><span class="line">    registry.addInterceptor(interceptor).excludePathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="配置view-controller"><a href="#配置view-controller" class="headerlink" title="配置view-controller"></a>配置view-controller</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加view-controller</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">    registry.addViewController(<span class="string">&quot;/hello&quot;</span>).setViewName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式详解</title>
    <url>/2022/03/21/singleton/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
</blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<br>

<p><strong>优点：</strong></p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<br>

<p><strong>缺点：</strong></p>
<p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<br>

<p><strong>使用场景：</strong></p>
<ul>
<li>1、要求生产唯一序列号。</li>
<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建的一个对象需要消耗的资源过多，比如 I&#x2F;O 与数据库的连接等。</li>
</ul>
<br>

<hr>
<h1 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h1><br>

<h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><blockquote>
<p>描述：基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p>
</blockquote>
<p>如果后续并没有使用到，可能会造成浪费空间</p>
<p>线程安全问题与登记式是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">HUNGRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="登记式"><a href="#登记式" class="headerlink" title="登记式"></a>登记式</h2><blockquote>
<p>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>
<p>描述：它跟饿汉式不同的是：饿汉式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 <strong>Holder类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。</strong></p>
</blockquote>
<br>

<p><strong>但没有同步锁是如何保证线程安全的呢？</strong></p>
<p>jvm在加载Holder时不会连SingletonHolder一同加载（ lazy loading ），这里涉及到<strong>类的加载时机</strong></p>
<blockquote>
<ol>
<li>遇到 new 、getstatic 、putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化 。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及凋用一个类的静态方法的时候。</li>
<li>使用 java-lang 、 reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invokeMethodHandle 实例最后的解析结果 REF-getStatic 、 REF_putStatic 、 REF invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>
</ol>
</blockquote>
<br>

<p><strong>外部调用getInstance()方法后，会触发SingletonHolder的加载，任意一个线程获取该【类加载】的锁后，就能保SingletonHolder首次给new出来，只有一个线程进入该内部类。加载完成后，static成员变量是唯一的。</strong></p>
<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> <span class="title function_">Holder</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Holder <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.holder;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<br>

<h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>当使用到的时候才去加载这个类，避免了空间的浪费</p>
<p>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy == <span class="literal">null</span>)&#123;</span><br><span class="line">            lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>上述实现存在一个明显的问题，就是在多线程的情况下不能保证只返回了一个实例，因为getInstance()方法没有加同步锁，可能会造成线程安全的问题</p>
<p>因此我们需要在getInstance()方法上加上同步锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy == <span class="literal">null</span>)&#123;</span><br><span class="line">            lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>在给getInstance()方法加上同步锁之后，这个方法变成线程安全的了，也不会有产生多个实例的情况了。</p>
<p>但是这样做的话我们发现每一次判断lazy实例是否存在的时候就要去拿到同步锁，而判断与线程安全是无关的，因此在方法上加同步锁会大大降低性能。因此我们采取<strong>双重锁校验模式</strong>，将同步代码块放在方法中，每次先判断实例是否存在，如果存在就直接返回实例；不存在再去拿同步锁进行初始化，这样可以减少线程上下文的切换，提升性能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>上述实现代码，似乎很完美的解决了线程安全问题和性能的问题，但它仍然是线程不安全的。<strong>因为初始化代码的new关键字并不是原子性操作</strong></p>
<blockquote>
<p>new的操作步骤：</p>
<ul>
<li>分配内存空间</li>
<li>执行构造方法，初始化对象</li>
<li>把这个对象指向这个空间</li>
</ul>
<p>由于不是原子性操作，可能会造成指令重排的问题，例如先将这个对象指向这个空间，再去初始化对象</p>
</blockquote>
<p>情况：一个线程A执行代码，在new操作时发生了指令重排，导致先将对象指向分配的空间，再去初始化对象；这时线程B进入发现这个对象已经指向了一个空间，<strong>它就会认为这个对象!&#x3D;null</strong>，但实际上这个对象可能还未完成初始化对象</p>
<p>所以由于存在这种情况，我们必须禁止指令重排，即<strong>加上volatile关键字</strong>，这样才算是完整的双重锁校验模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="反射机制破坏单例（以懒汉式为例）"><a href="#反射机制破坏单例（以懒汉式为例）" class="headerlink" title="反射机制破坏单例（以懒汉式为例）"></a>反射机制破坏单例（以懒汉式为例）</h3><p>虽然解决了线程安全问题、性能和原子性的问题，但因为存在反射机制，可以人为的去破坏单例模式。所以仍然存在安全问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestReflection</span> &#123;</span><br><span class="line">    <span class="comment">//测试反射</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;Lazy&gt; constructor = Lazy.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Lazy</span> <span class="variable">lazy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            lazy = constructor.newInstance();</span><br><span class="line">            System.out.println(lazy==Lazy.getInstance()); <span class="comment">//false</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="增加校验"><a href="#增加校验" class="headerlink" title="增加校验"></a>增加校验</h4><p>我们可以在造构造器中判断是否存在这个实例来解决问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lazy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Lazy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Lazy.class)&#123;</span><br><span class="line">            <span class="comment">//当这个实例已经存在了则不能使用反射机制创建对象</span></span><br><span class="line">            <span class="keyword">if</span> (lazy!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请勿使用反射机制破坏&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                lazy = <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazy == <span class="literal">null</span>) &#123;</span><br><span class="line">                    lazy = <span class="keyword">new</span> <span class="title class_">Lazy</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>



<h3 id="反序列化机制破坏单例（以懒汉式为例）"><a href="#反序列化机制破坏单例（以懒汉式为例）" class="headerlink" title="反序列化机制破坏单例（以懒汉式为例）"></a>反序列化机制破坏单例（以懒汉式为例）</h3><p>虽然这样防止了反射破坏单例模式，但是还仍存在安全隐患</p>
<p>反序列化机制能够破坏单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestSerializable</span> &#123;</span><br><span class="line">    <span class="comment">//测试序列化破坏</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Write Obj to file</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">        oos.writeObject(Lazy.getInstance());</span><br><span class="line">        <span class="comment">//Read Obj from file</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">        <span class="type">Lazy</span> <span class="variable">newInstance</span> <span class="operator">=</span> (Lazy) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(newInstance== Lazy.getInstance()); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="防止反序列化破坏"><a href="#防止反序列化破坏" class="headerlink" title="防止反序列化破坏"></a>防止反序列化破坏</h4><p>防止反序列化仅需要在代码中添加如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lazy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>为什么添加这段代码就能够防止反序列化破坏单例呢？</strong></p>
<p>对象的序列化过程通过 ObjectOutputStream 和 ObjectInputputStream 来实现的，而反序列化时会进入到 ObjectInputputStream 的 readOrdinaryObject 方法中</p>
<p>源码：</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/21/singleton/image-20220328203136918.png" alt="image-20220328203136918"></p>
<p><strong>上述源码中的这一段代码中有两段重要的代码</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/21/singleton/image-20220328203229857.png" alt="image-20220328203229857"></p>
<p><code>isInstantiable</code>：如果一个serializable&#x2F;externalizable的类可以在运行时被实例化，那么该方法就返回true。</p>
<p><code>desc.newInstance</code>：该方法通过反射的方式<strong>查找被序列化的类的第一个没有实现序列化接口的父类，并调用其无参构造方法创建一个对象，所以就算在被序列化的类中的无参构造方法中拦截反射也不能够防止反序列化的破坏！！</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/21/singleton/image-20220328203920455.png" alt="image-20220328203920455"></p>
<p><code>hasReadResolveMethod</code>:如果实现了serializable 或者 externalizable接口的类中包含<code>readResolve</code>则返回true</p>
<p><code>invokeReadResolve</code>:通过反射的方式调用要被反序列化的类的readResolve方法，并把返回值赋值给rep</p>
<p><strong>最后 obj &#x3D; rep 并返回 obj，而我们写的类中，readResolve方法返回的是唯一的Lazy类的实例，由此得到的对象和通过getInstance()得到的对象是一致的</strong></p>
<hr>
<br>

<h2 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h2><p>我们先来看一个枚举的单例模式的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> EnumSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="使用无参构造器反射创建"><a href="#使用无参构造器反射创建" class="headerlink" title="使用无参构造器反射创建"></a>使用无参构造器反射创建</h3><p>当我们试图使用反射机制去创建这个枚举类时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;EnumSingleton&gt; constructor= <span class="literal">null</span>;</span><br><span class="line">constructor = EnumSingleton.class.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">EnumSingleton singleton= <span class="literal">null</span>;</span><br><span class="line">singleton = constructor.newInstance();</span><br><span class="line">System.out.println(singleton);</span><br></pre></td></tr></table></figure>

<p>将会报异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodException: com.lxp.pattern.singleton.EnumSingleton.&lt;init&gt;()</span><br></pre></td></tr></table></figure>

<p>使用debug模式运行，会发现是因为EnumSingleton.class.getDeclaredConstructors()获取所有构造器，会发现并没有我们所设置的无参构造器，但是我们并没有在枚举类中设置其他的有参构造方法，这是怎么回事呢？查看编译后的源码，其继承了Enum类，所以会有（String.class,int.class）的构造器</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/21/singleton/image-20220321203503408.png" alt="image-20220321203503408"></p>
<br>

<h3 id="使用有参构造器反射创建"><a href="#使用有参构造器反射创建" class="headerlink" title="使用有参构造器反射创建"></a>使用有参构造器反射创建</h3><p>也许会有疑问，是不是因为自身的类没有无参构造方法才导致的异常？但执行下述代码后仍然会异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;EnumSingleton&gt; constructor= <span class="literal">null</span>;</span><br><span class="line">constructor = EnumSingleton.class.getDeclaredConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">EnumSingleton singleton= <span class="literal">null</span>;</span><br><span class="line">singleton = constructor.newInstance();</span><br><span class="line">System.out.println(singleton);</span><br></pre></td></tr></table></figure>

<p>抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br></pre></td></tr></table></figure>

<p><strong>Cannot reflectively create enum objects</strong> 这个异常的意思是不能使用反射机制创建枚举对象</p>
<br>

<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>我们通过查看newInstance方法的源码发现，<strong>当对枚举类使用newInstance方法时会抛出异常</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/21/singleton/image-20220321201936962.png" alt="image-20220321201936962"></p>
<p>为了防止反射机制破坏懒汉模式，我们可以使用枚举的方式实现单例模式</p>
<blockquote>
<p>枚举是最好的单例模式，同时枚举模式也能保证线程安全</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>sql语句整理</title>
    <url>/2022/03/23/sql/</url>
    <content><![CDATA[<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>学生表创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> student(</span><br><span class="line">Sno <span class="type">CHAR</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">Sname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>, <span class="operator">/</span><span class="operator">/</span>唯一约束</span><br><span class="line">Ssex <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">Sage <span class="type">SMALLINT</span>,</span><br><span class="line">Sdept <span class="type">char</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>课程表创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> course(</span><br><span class="line">Cno <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">Cname <span class="type">char</span>(<span class="number">40</span>) <span class="keyword">not</span> <span class="keyword">NULL</span>,</span><br><span class="line">Cpno <span class="type">char</span>(<span class="number">4</span>),</span><br><span class="line">Ccredit <span class="type">SMALLINT</span> <span class="operator">/</span><span class="operator">/</span>短整型</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>学生选课表创建</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> SC(</span><br><span class="line">Sno <span class="type">char</span>(<span class="number">9</span>),</span><br><span class="line">Cno <span class="type">char</span>(<span class="number">4</span>),</span><br><span class="line">Grade <span class="type">SMALLINT</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="向表中添加数据"><a href="#向表中添加数据" class="headerlink" title="向表中添加数据"></a>向表中添加数据</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>向学生表中添加数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> Student <span class="keyword">values</span></span><br><span class="line">(<span class="number">201215121</span>,<span class="string">&#x27;李勇&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;CS&#x27;</span>),</span><br><span class="line">(<span class="number">201215122</span>,<span class="string">&#x27;刘晨&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;CS&#x27;</span>),</span><br><span class="line">(<span class="number">201215123</span>,<span class="string">&#x27;王敏&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;MA&#x27;</span>),</span><br><span class="line">(<span class="number">201215125</span>,<span class="string">&#x27;张立&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;IS&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>向课程表中添加数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;数据库&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="number">4</span>),</span><br><span class="line">(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;信息系统&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">4</span>),</span><br><span class="line">(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;操作系统&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;数据结构&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="number">4</span>),</span><br><span class="line">(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;数据处理&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;Java语言&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>向学生选课表中添加数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc <span class="keyword">values</span></span><br><span class="line">(<span class="number">201215121</span>,<span class="number">1</span>,<span class="number">92</span>),</span><br><span class="line">(<span class="number">201215121</span>,<span class="number">2</span>,<span class="number">85</span>),</span><br><span class="line">(<span class="number">201215121</span>,<span class="number">3</span>,<span class="number">88</span>),</span><br><span class="line">(<span class="number">201215122</span>,<span class="number">2</span>,<span class="number">58</span>),</span><br><span class="line">(<span class="number">201215122</span>,<span class="number">3</span>,<span class="number">80</span>)</span><br></pre></td></tr></table></figure>



<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p><strong>查询某几列</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno,Sname </span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>

<p><strong>查询所有列</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>

<p><strong>查询全体学生的姓名及其出生年份（使用符号进行数学运算）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,<span class="number">2020</span><span class="operator">-</span>Sage</span><br><span class="line"><span class="keyword">from</span> Student</span><br></pre></td></tr></table></figure>

<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a><strong>条件查询</strong></h4><p><strong>&#x3D; … 语句</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>&lt; … 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询所有年龄在<span class="number">20</span>岁以下的学生姓名及其年龄</span><br><span class="line"><span class="keyword">select</span> Sname,Sage</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sage<span class="operator">&lt;</span><span class="number">20</span></span><br></pre></td></tr></table></figure>

<p><strong>between .. and .. 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询年龄在<span class="number">20</span><span class="number">-23</span>岁（包括<span class="number">20</span>和<span class="number">23</span>）之间的学生的姓名，系别，年龄</span><br><span class="line"><span class="keyword">select</span> Sname,Sdept,Sage</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sage <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>不在<span class="number">20</span><span class="number">-23</span>岁</span><br><span class="line"><span class="keyword">select</span> Sname,Sdept,Sage</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sage <span class="keyword">not</span> <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span></span><br></pre></td></tr></table></figure>

<p><strong>in(… , … , …) 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询计算机科学系（CS），数学系（MA），信息系（<span class="keyword">IS</span>）学生的姓名和性别</span><br><span class="line"><span class="keyword">select</span> Sname,Ssex</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sdept <span class="keyword">in</span>(<span class="string">&#x27;CS&#x27;</span>,<span class="string">&#x27;MA&#x27;</span>,<span class="string">&#x27;IS&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>不在</span><br><span class="line"><span class="keyword">select</span> Sname,Ssex</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sdept <span class="keyword">not</span> <span class="keyword">in</span>(<span class="string">&#x27;CS&#x27;</span>,<span class="string">&#x27;MA&#x27;</span>,<span class="string">&#x27;IS&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>like ‘ … ‘ 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> _表示一个占位符，可以是任何字符</span><br><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">&#x27;欧阳_&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">%</span>表示多个占位符，可以是任何长度的字符串</span><br><span class="line"><span class="keyword">select</span> Sname,Ssex</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sname <span class="keyword">like</span> <span class="string">&#x27;_阳%&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>is null 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询所有有成绩的学生的学号和课程号</span><br><span class="line"><span class="keyword">select</span> Sno,Cno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> grade <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p><strong>and 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询计算机科学系且年龄在<span class="number">20</span>岁以下的学生的姓名</span><br><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span> <span class="keyword">and</span> Sage<span class="operator">&lt;=</span><span class="number">20</span></span><br></pre></td></tr></table></figure>

<p><strong>order by … 语句（写在where语句之后）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询选修了<span class="number">3</span>号课程的学生的学号及其成绩，查询结果按分数的降序排列</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">order</span> <span class="keyword">by</span> 默认升序，<span class="keyword">ASC</span>是升序，<span class="keyword">DESC</span>是降序</span><br><span class="line"><span class="keyword">select</span> Sno,Grade</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Grade <span class="keyword">desc</span> <span class="operator">/</span><span class="operator">/</span>按成绩降序排序</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Sdept,Sage <span class="keyword">DESC</span> <span class="operator">/</span><span class="operator">/</span>先按Sdept升序排序，同Sdept再按降序排序</span><br></pre></td></tr></table></figure>

<h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a><strong>聚集函数</strong></h4><p><strong>count 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询学生总人数</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询选修了课程的学生人数</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>学生可以选多门课程，避免重复需在count函数里加<span class="keyword">distinct</span>短语</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> Sno) <span class="operator">/</span><span class="operator">/</span>按Sno统计个数</span><br><span class="line"><span class="keyword">from</span> sc</span><br></pre></td></tr></table></figure>

<p><strong>avg 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>计算选修<span class="number">1</span>号课程的学生平均成绩</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(Grade)</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>max 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询选修<span class="number">1</span>号课程的学生最高分数</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(Grade)</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>sum 语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询学生<span class="number">201215121</span>选修课程的总学分数</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(Grade)</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> Sno<span class="operator">=</span><span class="string">&#x27;201215121&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>group by … 语句（写在where语句之后）</strong></p>
<p><img src="https://jjw-beiqi.github.io/2022/03/23/sql/image-20220213135437400.png" alt="image-20220213135437400"></p>
<p>group by Sno 只展示出所聚集的属性 Sno ，不展示出Cno；但实际上返回的是上图这样一个关系图，所以在使用 Count(Cno) 聚集函数的时候会在图上统计</p>
<p><strong>注意：</strong></p>
<p><strong>先根据where条件子句进行过来</strong></p>
<p><strong>再根据group by子句进行聚合</strong></p>
<p><strong>最后再根据having子句对聚合结果进行过滤</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询一共有哪几个课程号，并展示出来</span><br><span class="line"><span class="keyword">select</span> Sno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sno</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>求各个课程号及相应的选课人数</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">group</span> up 是将查询结果按某个属性进行分组</span><br><span class="line"><span class="keyword">select</span> Cno ,<span class="built_in">Count</span>(Sno)</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Cno <span class="operator">/</span><span class="operator">/</span>相当只拿出一个Cno当作主键</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询选修了<span class="number">3</span>门以上课程的学生学号</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">having</span>和<span class="keyword">group</span>配合使用，且带聚集函数（能不能单独使用看使用的是哪一种数据库）</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">having</span>作用于组，这里先用<span class="keyword">group</span> <span class="keyword">by</span>按Sno进行分组，再用聚集函数count对每一组进行计数，用<span class="keyword">having</span>提取出满足条件的组</span><br><span class="line"><span class="keyword">select</span> Sno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sno</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">where</span>句中不能用聚集函数作为条件表达式</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询平均成绩大于等于<span class="number">90</span>分的学生学号和平均成绩</span><br><span class="line"><span class="keyword">select</span> Sno,<span class="built_in">avg</span>(Grade)</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sno</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(Grade)<span class="operator">&gt;=</span><span class="number">90</span></span><br></pre></td></tr></table></figure>



<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询每个学生及其选修课的情况</span><br><span class="line"><span class="keyword">select</span> student.<span class="operator">*</span>,sc.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> Student,sc <span class="operator">/</span><span class="operator">/</span>连接条件</span><br><span class="line"><span class="keyword">where</span> student.Sno<span class="operator">=</span>sc.Sno</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> student.Sno,Sname,Ssex,Sage,Sdept,Cno,grade</span><br><span class="line"><span class="keyword">from</span> student,sc</span><br><span class="line"><span class="keyword">where</span> student.sno<span class="operator">=</span>sc.sno</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询选修<span class="number">2</span>号课程且成绩在<span class="number">90</span>分以上的所有学生的学号和姓名</span><br><span class="line"><span class="keyword">select</span> student.Sno,Sname</span><br><span class="line"><span class="keyword">from</span> Student,sc</span><br><span class="line"><span class="keyword">where</span> student.Sno<span class="operator">=</span>sc.Sno <span class="keyword">and</span> </span><br><span class="line">      sc.Cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> </span><br><span class="line">      sc.Grade<span class="operator">&gt;=</span><span class="number">90</span></span><br><span class="line">      </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询每一门课的间接先修课（先修课的先修课）</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>先对一门课找到其先修课，再按此先修课的课程号查找它的先修课，</span><br><span class="line"><span class="keyword">select</span> first.Cno,second.Cpno</span><br><span class="line"><span class="keyword">from</span> Course <span class="keyword">first</span>,Course <span class="keyword">second</span> <span class="operator">/</span><span class="operator">/</span>将表与自身连接，就要取别名</span><br><span class="line"><span class="keyword">where</span> first.Cpno<span class="operator">=</span>second.Cno</span><br></pre></td></tr></table></figure>



<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询与刘晨在同一个系学习的学生</span><br><span class="line"><span class="keyword">select</span> Sno,Sname,Sdept</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sdept <span class="keyword">in</span>(</span><br><span class="line">    <span class="keyword">select</span> Sdept</span><br><span class="line">    <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> Sname<span class="operator">=</span><span class="string">&#x27;刘晨&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>找出每个学生超过他自己选修课程平均成绩的课程号</span><br><span class="line"><span class="keyword">select</span> Sno,Cno</span><br><span class="line"><span class="keyword">from</span> sc x</span><br><span class="line"><span class="keyword">where</span> Grade <span class="operator">&gt;=</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(Grade)</span><br><span class="line">    <span class="keyword">from</span> sc y</span><br><span class="line">    <span class="keyword">where</span> y.Sno<span class="operator">=</span>x.Sno</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询非计算机系中比计算机系任意学生年龄小的学生姓名和年龄</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>任意：<span class="keyword">any</span>   所有:<span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> Sname,Sage</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sage<span class="operator">&lt;</span><span class="keyword">any</span>(</span><br><span class="line">   <span class="keyword">select</span> Sage</span><br><span class="line">   <span class="keyword">from</span> student</span><br><span class="line">   <span class="keyword">where</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询选修了全部课程的学生姓名</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">exists</span> 表示每次从表中选取一个元组进行条件的查询如果能查询到数据则返回<span class="literal">true</span>，否则返回<span class="literal">false</span>；<span class="keyword">not</span> <span class="keyword">exists</span> 语句相反</span><br><span class="line"><span class="keyword">select</span> Sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line">  <span class="keyword">from</span> course</span><br><span class="line">  <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">     <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">     <span class="keyword">from</span> sc</span><br><span class="line">     <span class="keyword">where</span> Sno<span class="operator">=</span>student.Sno <span class="keyword">AND</span> </span><br><span class="line">     Cno<span class="operator">=</span>course.Cno</span><br><span class="line">  )    </span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h4 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询选修了<span class="number">1</span>号课程或则<span class="number">2</span>号课程的学生</span><br><span class="line"><span class="keyword">select</span> Sno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">select</span> Sno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询既选修了课程<span class="number">1</span>又选修了课程<span class="number">2</span>的学生</span><br><span class="line"><span class="keyword">select</span> Sno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line">intersert</span><br><span class="line"><span class="keyword">select</span> Sno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> Cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>





<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>将一个新学生元组</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;201215128&#x27;</span>,<span class="string">&#x27;陈东&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;IS&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>插入一条选课记录</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc(Sno,Cno) <span class="keyword">VALUES</span>(<span class="string">&#x27;201215128&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">insert</span>语句与查询语句结合使用</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>计算数据，存放到表中</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Deptage(Sdept,avg_age)</span><br><span class="line"><span class="keyword">select</span> Sdept,<span class="built_in">avg</span>(Sage)</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sdept </span><br></pre></td></tr></table></figure>



<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a><strong>修改数据</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">update</span>语句与<span class="keyword">where</span>语句结合使用</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>将学生<span class="number">201215121</span>的年龄改为<span class="number">22</span>岁</span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> Sage<span class="operator">=</span><span class="number">22</span></span><br><span class="line"><span class="keyword">where</span> Sno<span class="operator">=</span><span class="string">&#x27;201215121&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>将所有学生的年龄增加<span class="number">1</span>岁</span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> Sage<span class="operator">=</span>Sage<span class="operator">+</span><span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><strong>删除数据</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">delete</span>语句与<span class="keyword">where</span>语句结合使用</span><br><span class="line"><span class="keyword">delete</span> </span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sno<span class="operator">=</span><span class="string">&#x27;201215128&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除计算机系所有学生的选课记录</span><br><span class="line"><span class="keyword">delete</span> </span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span>(</span><br><span class="line">  <span class="keyword">select</span> Sno</span><br><span class="line">  <span class="keyword">from</span> student</span><br><span class="line">  <span class="keyword">where</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized锁、Lock锁简单使用</title>
    <url>/2022/03/19/synchronized%E9%94%81%E3%80%81Lock%E9%94%81%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h1><h3 id="修饰实例方法："><a href="#修饰实例方法：" class="headerlink" title="修饰实例方法："></a>修饰实例方法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被锁的对象是类的实例对象，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SynContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynContainer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Productor</span>(container).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Consumer</span>(container).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Productor</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Productor</span><span class="params">(SynContainer container)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SynContainer = container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Productor</span><span class="params">(SynContainer container)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SynContainer = container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynContainer</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当运行这两个生产者和消费者时，锁住的是SynContainer的实例container，同一时刻只能有一个线程访问这个实例</span></span><br></pre></td></tr></table></figure>



<h3 id="修饰静态方法："><a href="#修饰静态方法：" class="headerlink" title="修饰静态方法："></a>修饰静态方法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被锁的对象是类对象</p>
<h3 id="修饰实例对象"><a href="#修饰实例对象" class="headerlink" title="修饰实例对象:"></a>修饰实例对象:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块，锁住的是该类的实例对象</p>
<h3 id="修饰class对象"><a href="#修饰class对象" class="headerlink" title="修饰class对象:"></a>修饰class对象:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (SynContainer.class)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块，锁住的是该类的类对象</p>
<h3 id="修饰任意实例对象Object"><a href="#修饰任意实例对象Object" class="headerlink" title="修饰任意实例对象Object:"></a>修饰任意实例对象Object:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">synchronize (num)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块，锁住的是配置的实例对象</p>
<p>int对象作为锁</p>
<hr>
<h1 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h1><h3 id="ReentrantLock锁"><a href="#ReentrantLock锁" class="headerlink" title="ReentrantLock锁"></a>ReentrantLock锁</h3><p>相比于synchronized锁，Lock锁是显示的，能够显示的定义同步锁来实现同步</p>
<p>ReentrantLock（可重入锁）类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reentrantLock.lock();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">reentrantLock.unlock();</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestLock1</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestLock1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(lock1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(lock1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(lock1).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestLock1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reentrantLock.lock();  <span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span> (num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(num--);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();  <span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="生产者消费者问题（管程法）"><a href="#生产者消费者问题（管程法）" class="headerlink" title="生产者消费者问题（管程法）"></a>生产者消费者问题（管程法）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">SynContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynContainer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Productor</span>(container).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Productor</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Productor</span><span class="params">(SynContainer container)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">100</span> ; i++)</span><br><span class="line">        container.push(<span class="keyword">new</span> <span class="title class_">Chicken</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(SynContainer container)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">            container.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chicken</span>&#123;</span><br><span class="line">    <span class="type">int</span> id ; <span class="comment">//产品编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chicken</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynContainer</span>&#123;</span><br><span class="line">    <span class="comment">//容器大小</span></span><br><span class="line">    Chicken[] chickens = <span class="keyword">new</span> <span class="title class_">Chicken</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//容器计数器</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者放入产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Chicken chicken)</span>&#123;</span><br><span class="line">        <span class="comment">//如果容器满了，就需要等待消费者消费</span></span><br><span class="line">        <span class="comment">//最好不要用if，应该用while，否则当有多个消费者的时候，会出现脏判断的</span></span><br><span class="line">        <span class="keyword">while</span> (count == chickens.length)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();<span class="comment">//阻塞此线程，并释放锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果容器没满，生产者放入产品</span></span><br><span class="line">        chickens[count] = chicken;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知消费者消费产品</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll(); <span class="comment">//唤醒其他等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者消费产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Chicken <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断能否消费</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待生产者生产，消费者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果可以消费</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="type">Chicken</span> <span class="variable">chicken</span> <span class="operator">=</span> chickens[count];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知生产者生产</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chicken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>synchronized、Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法与二叉查找树和堆的实现</title>
    <url>/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>排序原理：</strong></p>
<p>1、比较相邻的元素，如果前一个元素比后一个元素大，就交换这两个元素的位置</p>
<p>2、对每一对元素都这样处理，最后的出来的结构就是排序完成的结果</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220116195027877.png" alt="image-20220116195027877"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//integer实现了comparable接口，提供了比较的规则</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        Bubble.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line">    <span class="comment">//对数组a中的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=a.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//比较索引j和索引j+1的值</span></span><br><span class="line">                <span class="keyword">if</span> (greater(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否大于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>冒泡排序时间复杂度分析：O（n^2）</strong></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>排序原理：</strong></p>
<p>1、每一次遍历过程中，都假定第一个索引处的元素是最小值，然后依次和其他索引处的值进行比较，直到找到本次遍历最小值</p>
<p>2、交换第一个索引处和最小值所在的索引处的值</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220117162148826-16476725408391.png" alt="image-20220117162148826"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> &#123;</span><br><span class="line">    <span class="comment">//对数组内的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=a.length-<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//定义变量，记录最小索引所在位置，默认为每一次遍历的第一个元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;a.length; j++)&#123;</span><br><span class="line">                <span class="comment">//比较minIndex，与现在索引所在的值</span></span><br><span class="line">                <span class="keyword">if</span> (greater(a[minIndex],a[j]))&#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换最小值和每次遍历的第一个值</span></span><br><span class="line">            exch(a,i,minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否大于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>选择排序时间复杂度分析：O（n^2）</strong></p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>排序原理：</strong></p>
<p>1、将所有元素<strong>分为已排序和未排序</strong></p>
<p>2、将未排序数组的第一个元素向已排序数组中插入</p>
<p>3、倒叙遍历已排序数组，找到小于或等于插入元素的元素，并将插入元素放到这个位置，其余元素向后移动一位</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220117183137041-16476725408392.png" alt="image-20220117183137041"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> &#123;</span><br><span class="line">    <span class="comment">//对数组a中的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">1</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="comment">//比较索引j处的值和索引j-1处的值</span></span><br><span class="line">                <span class="comment">//如果j-1处的值比j大则j--，小就交换</span></span><br><span class="line">                <span class="keyword">if</span> (greater(a[j-<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                    exch(a,j-<span class="number">1</span>,j);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否大于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**插入排序时间复杂度分析：O（n^2）    **</p>
<p><strong>（其本质跟冒泡排序相似）</strong></p>
<hr>
<h3 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h3><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序是插入排序的一种，又叫<strong>”缩小增量排序“</strong>，希尔排序的增量没有固定的规则</p>
<p>希尔排序的时间的时间复杂度为</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/eb39d4c67a9cabbd3a2690a2151ee6cc.svg" alt="img"></p>
<p> ，希尔排序时间复杂度的下界是n*log2n。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。但是比</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/c937d30f3cd06da1cd53133d8a3b4887.svg" alt="img"></p>
<p> 复杂度的算法快得多。</p>
<p><strong>专家们提倡，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法</strong></p>
<p><strong>排序原理：</strong></p>
<p>1、选定一个增量h，按照增量h作为数据分组的依据，对数据进行分组</p>
<p>2、对分好组的每一组数据完成插入排序</p>
<p>3、减小增长量，最小减一，重复第二步</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220117202712044.png" alt="image-20220117202712044"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> &#123;</span><br><span class="line">    <span class="comment">//对数组内的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//根据数组的长度，确定增长量</span></span><br><span class="line">        <span class="type">int</span> h=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h&lt;a.length/<span class="number">2</span>)&#123;</span><br><span class="line">            h=<span class="number">2</span>*h+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//希尔排序</span></span><br><span class="line">        <span class="keyword">while</span> (h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//找待插入的元素</span></span><br><span class="line">            <span class="comment">//从h之后的每一个元素都需要进行跟自己的组进行排序，这是i++的原因</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=h; i&lt;a.length; i++)&#123;</span><br><span class="line">                <span class="comment">//插入排序</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;=h; j-=h)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (greater(a[j-<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                        exch(a,j-<span class="number">1</span>,j);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减小增长量</span></span><br><span class="line">            h=h/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否大于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序体现的是<strong>分而治之的思想</strong></p>
<p><strong>排序原理：</strong></p>
<p>1、尽可能的将一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数为1</p>
<p>2、不断将相邻的两个子组进行合并成一个有序的大组，直到只有一个组为止</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220117214230426.png" alt="image-20220117214230426"></p>
<p>使用辅助数组，对两个子组进行排序，<strong>排序方式与合并两个有序链表的方式类似</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line">    <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] assist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组内的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//初始化辅助数组</span></span><br><span class="line">        assist = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];</span><br><span class="line">        <span class="comment">//定义一个lo变量和hi变量，分别记录数组中最小和最大的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//调用sort重载方法</span></span><br><span class="line">        sort(a,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组a中从索引lo到索引hi的元素进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="comment">//做安全性校验</span></span><br><span class="line">        <span class="keyword">if</span> (hi&lt;=lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个mid变量 将lo到hi之间的数据分成两组</span></span><br><span class="line"><span class="comment">         * sort(a,lo,mid);</span></span><br><span class="line"><span class="comment">         * sort(a,mid+1,hi);</span></span><br><span class="line"><span class="comment">         * 递归分组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别对每一组数据进行排序</span></span><br><span class="line">        sort(a,lo,mid);</span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再把两个组中的数据进行合并</span></span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将两个有序的子组合并成一个有序的大组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="comment">//定义三个指针</span></span><br><span class="line">        <span class="comment">//辅助数组的指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> lo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历，将两有序子组合并</span></span><br><span class="line">        <span class="keyword">while</span> (p1&lt;=mid &amp;&amp; p2&lt;hi)&#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[p1],a[p2]))&#123;</span><br><span class="line">                assist[i++] = a[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                assist[i++] = a[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当其中某一个子组遍历完成，而另一个子组未完成时</span></span><br><span class="line">        <span class="comment">//将剩余元素顺序放入辅助数组中</span></span><br><span class="line">        <span class="keyword">while</span> (p1&lt;=mid)&#123;</span><br><span class="line">            assist[i++] = a[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p2&lt;=hi)&#123;</span><br><span class="line">            assist[i++] = a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将辅助数组中的元素拷贝到原数组的对应位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> index=lo; index&lt;=hi; index++)&#123;</span><br><span class="line">            a[index] = assist[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否小于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span></span><br><span class="line">    <span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>归并排序的时间复杂度分析：O（n logn）</strong></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>排序原理：</strong></p>
<p>1、首先设定一个分界值，通过该分界值将数组分成左右两部分</p>
<p>2、将大于或等于分界值的放到数组右边，小于分界值的放到数值左边</p>
<p>3、重复操作分界值左右两边的元素，最终就得到排序好的数组</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220118201405192.png" alt="image-20220118201405192"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line">    <span class="comment">//对数组内的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">        sort(a,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组a中从索引lo到索引hi的元素进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="comment">//安全性校验</span></span><br><span class="line">        <span class="keyword">if</span> (lo&gt;=hi)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获得分界值的索引，分界值右边比分界值大，左边比分界值小</span></span><br><span class="line"><span class="comment">         * 并已分界值两边分为两组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> partition(a,lo,hi);<span class="comment">//返回的是分界值的索引，分界值位置变换后的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使左子组有序</span></span><br><span class="line">        sort(a,lo,partition-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使右子组有序</span></span><br><span class="line">        sort(a,partition+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法的作用是使用分界值（默认为数组第一个元素）对数组lo到hi的元素进行分组</span></span><br><span class="line"><span class="comment">     * 比分界值大的放右边，比分界值小的放左边</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回分组之后分界值所在的索引（因为分界值一开始的索引为lo，所以最后分界值的位置会发生变化）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="comment">//确定分界值</span></span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">key</span> <span class="operator">=</span> a[lo];</span><br><span class="line">        <span class="comment">//定义两个指针，分别指向待切分元素的最小索引和最大索引的下个位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> lo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> hi+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//先从右往左扫描，找到一个比分界值小的元素然后停止</span></span><br><span class="line">            <span class="keyword">while</span> (less(key,a[--right]))&#123;</span><br><span class="line">                <span class="keyword">if</span> (right == lo)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先从左往右扫描，找到一个比分界值大的元素然后停止</span></span><br><span class="line">            <span class="keyword">while</span> (less(a[++left],key))&#123;</span><br><span class="line">                <span class="keyword">if</span> (left == hi)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束</span></span><br><span class="line">            <span class="keyword">if</span> (left&gt;=right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                exch(a,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换right与分界值，此处不能与left交换，因为left可能大于right，若与letf交换可能会导致，比分界值大的被交换</span></span><br><span class="line">        exch(a,lo,right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较元素v是否小于元素w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span></span><br><span class="line">    <span class="params">(Comparable v, Comparable w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w)&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组元素交换位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序的时间复杂度分析：最优情况：O（nlogn） 最坏情况：O（n^2）</strong></p>
<p><strong>归并排序和快速排序的区别：</strong></p>
<p>归并排序将数组分成两个子数组分别排序，并将有序的子数组归并，从而将整个数组排序</p>
<p>快速排序的方式是当两个数组都有序时，整个数组就有序了</p>
<hr>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p><strong>树的定义：</strong></p>
<p>树是由n个有限结点组成一个具有层次关系的集合。它看起来像一颗倒挂的树</p>
<p><strong>树的特点：</strong></p>
<p>1、每个结点有零个或多个子结点</p>
<p>2、没有父节点的结点为根结点</p>
<p>3、每一个非根节点只有一个父结点</p>
<p>4、每个结点及其后代结点整体上可以看作是一个棵树，称为当前结点的父节点的一个子树</p>
<p><strong>结点的度：</strong></p>
<p>一个结点含有的子树的个数称为该结点的度</p>
<p><strong>叶结点：</strong></p>
<p>度为0的结点也称为叶结点</p>
<p><strong>树的度：</strong></p>
<p>树中所有结点的度的最大值</p>
<p><strong>树的深度：</strong></p>
<p>树中结点的最大层次</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树就是度不超过2的树</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220119200839620-16476728009495.png" alt="image-20220119200839620"></p>
<p><strong>满二叉树：</strong></p>
<p>一个二叉树，如果<strong>每一个层的结点树都达到最大值</strong>，则这个二叉树就是满二叉树</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220119201015460-16476728009506.png" alt="image-20220119201015460"></p>
<p><strong>完全二叉树：</strong></p>
<p>叶结点只能出现在最下层和次下层</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220119201231459-16476728009507.png" alt="image-20220119201231459"></p>
<h5 id="二叉查找树的创建"><a href="#二叉查找树的创建" class="headerlink" title="二叉查找树的创建"></a>二叉查找树的创建</h5><p><strong>插入方法put的实现思想：</strong></p>
<p>1、如果当树中没有任何一个结点，则直接把新结点作为根结点</p>
<p>2、如果当前树不为空，则从根结点开始</p>
<ul>
<li>如果新结点的key小于当前结点的key，则继续找当前结点的左子结点</li>
<li>如果新结点的key大于当前结点的key，则继续找当前结点的右子结点</li>
<li>如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可</li>
</ul>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220120141818232-16476728009508.png" alt="image-20220120141818232"></p>
<p><strong>查询方法get实现思想：</strong></p>
<p>从根结点开始</p>
<ul>
<li>如果要查询的key小于当前结点的key，则继续找当前结点的左子结点</li>
<li>如果要查询的key大于当前结点的key，则继续找当前结点的右子结点</li>
<li>如果要查询的key等于当前结点的key，则返回当前结点的value值</li>
</ul>
<p><strong>删除方法delete实现思想：</strong></p>
<ul>
<li><p>找到被删除结点</p>
</li>
<li><p>找到被删除结点右子树的最小结点minNode</p>
</li>
<li><p>删除右子树中的最小结点</p>
</li>
<li><p>让被删除结点的左子树成为最小结点minNode的左子树，让被删除结点的右子树成为最小结点minNode的右子树</p>
</li>
<li><p>让被删除结点的父结点指向最小结点minNode</p>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;,Value&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root; <span class="comment">//记录根结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N; <span class="comment">//记录树中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向树中插入一个键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key, Value value)</span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给指定树x上，添加一个键值对，并返回添加后的新树</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">put</span><span class="params">(Node x, Key key, Value value)</span>&#123;</span><br><span class="line">        <span class="comment">//如果x子树为null</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key,value,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果x子树不为null</span></span><br><span class="line">        <span class="comment">//比较x结点的键和key的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo((Key) x.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &gt; x.key，继续找右子树</span></span><br><span class="line">            x.right = put(x.right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &lt; x.key，继续找左子树</span></span><br><span class="line">            x.left = put(x.left,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//key = x.key，替换x的value</span></span><br><span class="line">            x.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据key，从树中找出对应的值</span></span><br><span class="line">    <span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从指定的树x中，找出key对应的值</span></span><br><span class="line">    <span class="keyword">private</span> Value <span class="title function_">get</span><span class="params">(Node x, Key key)</span>&#123;</span><br><span class="line">        <span class="comment">//如果x子树为null</span></span><br><span class="line">        <span class="comment">//包含了找不到key值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果x子树不为null</span></span><br><span class="line">        <span class="comment">//比较x结点的键和key的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo((Key) x.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &gt; x.key，继续找右子树</span></span><br><span class="line">            <span class="keyword">return</span> get(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &lt; x.key，继续找左子树</span></span><br><span class="line">            <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//key = x.key，返回x的value</span></span><br><span class="line">            <span class="keyword">return</span> (Value) x.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据key，删除树中对应的键值对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span>&#123;</span><br><span class="line">        delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定树x上的键为key的键值对，并返回删除后的新树</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(Node x, Key key)</span>&#123;</span><br><span class="line">        <span class="comment">//如果x子树为null</span></span><br><span class="line">        <span class="comment">//包含了找不到key值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果x子树不为null</span></span><br><span class="line">        <span class="comment">//比较x结点的键和key的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo((Key) x.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &gt; x.key，继续找右子树</span></span><br><span class="line">            x.right = delete(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//key &lt; x.key，继续找左子树</span></span><br><span class="line">            x.left = delete(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//key = x.key，执行删除操作</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到右子树中最小的结点</span></span><br><span class="line">            <span class="keyword">if</span> (x.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (minNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到并删除右子树中最小的结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">n</span> <span class="operator">=</span> x.right;</span><br><span class="line">            <span class="keyword">while</span> (n.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (n.left.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                    n.left = <span class="literal">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//变换n结点</span></span><br><span class="line">                    n = n.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//让x结点的左子树成为minNode的左子树</span></span><br><span class="line">            minNode.left = x.left;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//让x结点的右子树成为minNode的右子树</span></span><br><span class="line">            minNode.right = x.right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//让x结点的父结点指向minNode</span></span><br><span class="line">            x = minNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//元素个数减一</span></span><br><span class="line">            N--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取树中元素的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="二叉查找树中最小的键"><a href="#二叉查找树中最小的键" class="headerlink" title="二叉查找树中最小的键"></a>二叉查找树中最小的键</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回二叉查找树中最小的键</span></span><br><span class="line"><span class="keyword">public</span> Key <span class="title function_">min</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Key) min(root).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">min</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> min(x.left);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="二叉查找树中最大的键"><a href="#二叉查找树中最大的键" class="headerlink" title="二叉查找树中最大的键"></a>二叉查找树中最大的键</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回二叉查找树中最大的键</span></span><br><span class="line"><span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Key) min(root).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">max</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> max(x.right);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h5><p>很多情况下，我们需要遍历树，由于树状结构和线性结构不一样，它没有办法从头开始依次向后遍历，所以存在如何遍历，也就是按照什么样的<strong>搜索路径</strong>进行遍历的问题</p>
<p>我们可以把二叉树的<strong>低级遍历方式</strong>分为以下三种方式：</p>
<p><strong>1、先序遍历：</strong></p>
<p>先访问根结点，再访问左子树，最后访问右子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用先序遍历，获取整个树中的所有键</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Key&gt; <span class="title function_">preErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    preErgodic(root,keys);</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preErgodic</span><span class="params">(Node x, List&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将x.key放入keys</span></span><br><span class="line">    keys.add((Key) x.key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断左右子树是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="literal">null</span>)&#123;</span><br><span class="line">        preErgodic(x.left,keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        preErgodic(x.right,keys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>2、中序遍历：</strong></p>
<p>先访问左子树，再访问根结点，最后访问右子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用中序遍历，获取整个树中的所有键</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Key&gt; <span class="title function_">midErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    midErgodic(root,keys);</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">midErgodic</span><span class="params">(Node x, List&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断左右子树是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="literal">null</span>)&#123;</span><br><span class="line">        midErgodic(x.left,keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将x.key放入keys</span></span><br><span class="line">    keys.add((Key) x.key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        midErgodic(x.right,keys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3、后序遍历：</strong></p>
<p>先访问左子树，再访问右子树，最后访问根结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用后序遍历，获取整个树中的所有键</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Key&gt; <span class="title function_">afterErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    afterErgodic(root,keys);</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">afterErgodic</span><span class="params">(Node x, List&lt;Key&gt; keys)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断左右子树是否为null</span></span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="literal">null</span>)&#123;</span><br><span class="line">        afterErgodic(x.left,keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        afterErgodic(x.right,keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将x.key放入keys</span></span><br><span class="line">    keys.add((Key) x.key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>高级遍历方式：层序遍历</strong> </p>
<p><strong>实现步骤：</strong></p>
<ul>
<li><p>创建队列，存储每一层的结点</p>
</li>
<li><p>使用循环从队列弹出一个结点</p>
<ul>
<li><p>获取当前结点的key</p>
</li>
<li><p>如果当前结点的左子结点不为空，则把左子结点放入到队列中</p>
</li>
<li><p>如果当前结点的右子结点不为空，则把右子结点放入到队列中</p>
</li>
</ul>
</li>
</ul>
<p><strong>此处使用ArrayList来代替队列</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Key&gt; <span class="title function_">layerErgodic</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Key&gt; keys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认往队列中放入根结点</span></span><br><span class="line">        nodes.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!nodes.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//从队列中弹出结点，把key放入keys中</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            nodes.remove(<span class="number">0</span>);</span><br><span class="line">            keys.add((Key) node.key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断当前结点是否有左子结点，有则放入nodes中</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                nodes.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断当前结点是否有右子结点，有则放入nodes中</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                nodes.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keys;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h5 id="二叉树的最大深度问题"><a href="#二叉树的最大深度问题" class="headerlink" title="二叉树的最大深度问题"></a>二叉树的最大深度问题</h5><p>给定一颗树，计算树的最大深度（树的根结点到最远叶子结点的最长路径上的结点数）</p>
<p><strong>实现步骤：</strong></p>
<ul>
<li>如果根结点为空，则最大深度为0</li>
<li>计算左子树的最大深度</li>
<li>计算右子树的最大深度</li>
<li>当前树的最大深度 &#x3D; 左子树的最大深度和右子树的最大深度中的较大者 + 1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算指定的树的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//x的最大深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左子树的最大深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxL</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//右子树的最大深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxR</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算左子树最大深度</span></span><br><span class="line">        <span class="keyword">if</span> (x.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            maxL = maxDepth(x.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算右子树最大深度</span></span><br><span class="line">        <span class="keyword">if</span> (x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            maxR = maxDepth(x.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较左右子树最大深度，取较大值+1</span></span><br><span class="line">        max = maxL&gt;maxR?maxL+<span class="number">1</span>:maxR+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<hr>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h4><p>堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一颗完全二叉树的数组对象</p>
<p><strong>堆的特性：</strong></p>
<p>1、它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层不满，则要求左满右不满</p>
<p><img src="https://jjw-beiqi.github.io/2022/03/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220123162158170-16464424736501.png" alt="image-20220123162158170"></p>
<p>2、它通常是用数组来实现</p>
<p>具体方法就是将二叉树的结点按照层级顺序放入数组中</p>
<p><strong>如果一个结点为位置为k，则它的父结点则为【k&#x2F;2】，而它的两个子结点的位置则分别为【2k】和【2k+1】</strong></p>
<p>3、每个结点都大于等于它的两个子结点。虽然这样规定，但是子结点的位置顺序并没有规定</p>
<hr>
<h4 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h4><p><strong>insert插入方法的实现</strong></p>
<p>由于堆的定义是父结点大于两个子结点，且堆是由数组实现，所以在我们插入一个比父结点大的元素时就需要从插入元素的位置不断跟其父结点比较，如果父结点比子结点小则交换位置</p>
<p><strong>delMax删除最大元素方法的实现</strong></p>
<p>由于堆的定义，其根结点就是最大值，所以将其删除后将会导致堆的顺序变化，从而导致堆不符合定义；所以这时我们可以暂时把堆中最后一个元素拿出，并放到索引1处，然后使用下沉算法使堆有序</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items; <span class="comment">//用来存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N; <span class="comment">//记录堆中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建容量为capacity的Heap对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.items = (T[])<span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i].compareTo(items[j])&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆中i索引和j索引处的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> items[i];</span><br><span class="line">        items[i] = items[j];</span><br><span class="line">        items[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除堆中最大的元素，并返回这个最大元素</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> items[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换索引1处的元素和最大索引处的元素</span></span><br><span class="line">        exch(<span class="number">1</span>,N);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除最大索引元素</span></span><br><span class="line">        items[N] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素个数减一</span></span><br><span class="line">        N--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让堆有序</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往堆中插入一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="comment">//索引0不使用</span></span><br><span class="line">        items[++N] = t;</span><br><span class="line">        <span class="comment">//使用上浮算法，使堆有序</span></span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//不断比较当前结点和父结点的大小，如果父结点比子结点小，则交换位置</span></span><br><span class="line">        <span class="keyword">while</span> (k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//比较当前结点和父结点的值</span></span><br><span class="line">            <span class="keyword">if</span> (less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">                exch(k/<span class="number">2</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">            k=k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//不断对比当前k结点和其子结点的较大值，如果当前结点小于子节点较大值，则交换位置</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)&#123;</span><br><span class="line">            <span class="comment">//获取当前结点的较大结点</span></span><br><span class="line">            <span class="type">int</span> max; <span class="comment">//记录较大结点所在的索引</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*k+<span class="number">1</span> &lt; N)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(<span class="number">2</span>*k,<span class="number">2</span>*k+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*k;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//比较当前结点和较大子结点的值</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换值</span></span><br><span class="line">            exch(k,max);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//变换k值</span></span><br><span class="line">            k = max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>实现步骤：</strong></p>
<p>1、构造堆</p>
<p>2、得到堆顶元素</p>
<p>3、交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置</p>
<p>4、对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶</p>
<p>5、重复2~4步骤，直到堆中剩余一个元素为止</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="comment">//对source数组中的数据从小到大排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] source)</span>&#123;</span><br><span class="line">        <span class="comment">//构建堆</span></span><br><span class="line">        Comparable[] heap = <span class="keyword">new</span> <span class="title class_">Comparable</span>[source.length+<span class="number">1</span>];</span><br><span class="line">        createHeap(source,heap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个变量，记录未排序的元素中最大的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> heap.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过循环，交换1索引处的元素和排序的元素中最大索引处的值</span></span><br><span class="line">        <span class="keyword">while</span> (N != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//交换元素</span></span><br><span class="line">            exch(heap,<span class="number">1</span>,N);</span><br><span class="line">            <span class="comment">//排序交换后最大元素所在的索引让其不再参加堆的下沉调整</span></span><br><span class="line">            N--;</span><br><span class="line">            <span class="comment">//需要对索引1处的元素进行堆的下沉调整</span></span><br><span class="line">            sink(heap,<span class="number">1</span>,N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把heap中数据复制到原数组source</span></span><br><span class="line">        System.arraycopy(heap,<span class="number">1</span>,source,<span class="number">0</span>,source.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据原数组source，构造出heap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createHeap</span><span class="params">(Comparable[] source, Comparable[] heap)</span>&#123;</span><br><span class="line">        <span class="comment">//把source中的元素拷贝到heap中，heap中的元素就形成一个无序的堆</span></span><br><span class="line">        System.arraycopy(source,<span class="number">0</span>,heap,<span class="number">1</span>,source.length);</span><br><span class="line">        <span class="comment">//对堆中的元素做下沉调整（从长度的一半处开始，往索引1处扫描）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (heap.length)/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            sink(heap,i,heap.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断heap堆中索引i处的元素是否小于索引j处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i].compareTo(heap[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换heap中i索引和j索引处的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] heap, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在heap中，对target处的元素做下沉，范围是0~range</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(Comparable[] heap, <span class="type">int</span> target, <span class="type">int</span> range)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*target&lt;=range)&#123;</span><br><span class="line">            <span class="comment">//1、找出当前结点的较大子结点</span></span><br><span class="line">            <span class="type">int</span> max;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span>*target+<span class="number">1</span>&lt;range)&#123;</span><br><span class="line">                <span class="keyword">if</span> (less(heap,<span class="number">2</span>*target,<span class="number">2</span>*target+<span class="number">1</span>))&#123;</span><br><span class="line">                    max = <span class="number">2</span>*target+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    max = <span class="number">2</span>*target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                max = <span class="number">2</span>*target;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、比较当前结点的值和较大子结点的值</span></span><br><span class="line">            <span class="keyword">if</span> (!less(heap,target,max))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(heap,target,max);</span><br><span class="line">            target = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
